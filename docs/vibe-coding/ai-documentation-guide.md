# AI 문서화 가이드

- **상태**: 승인됨
- **관련 문서**:
  - [AI 문서 수명주기 가이드](ai-documentation-lifecycle-guide.md)
- **변경 이력**:
  - 0.5 (2025-04-02): [Seok Lim] - 최초 문서 작성

## 개요

이 가이드는 AI와 협업하여 소프트웨어를 개발하는 "AI 주도 개발" 방식에 최적화된 문서화 전략을 제시합니다. 문서는 단순한 참조 자료가 아닌 개발 프로세스의 핵심 요소로서, AI와 인간 개발자 간의 효과적인 협업을 가능하게 합니다.

## 목차

1. [핵심 원칙](#핵심-원칙)
2. [4W1H 문서 구조](#4w1h-문서-구조)
3. [문서-구현 병행 전략](#문서-구현-병행-전략)
4. [문서 템플릿](#문서-템플릿)
5. [AI 효과적 활용 전략](#ai-효과적-활용-전략)
6. [성공 사례 및 안티패턴](#성공-사례-및-안티패턴)

## 핵심 원칙

### 1. 문서는 코드의 일부 (Documentation as Code)

- 문서와 코드를 동일한 저장소에서 관리
- 문서에 대한 변경도 PR과 리뷰 프로세스 적용
- 문서의 정확성과 최신성을 자동화된 테스트로 검증

### 2. 단일 진실 소스 (Single Source of Truth)

- 모든 설계 결정과 개발 지침은 문서에 명확히 기록
- 구두로 전달되는 결정사항도 반드시 문서화
- AI와 인간 모두 동일한 정보원을 참조

### 3. 개념 모델 우선주의 (Conceptual Model First)

- 시스템의 개념적 이해가 구체적인 구현보다 우선
- 용어와 핵심 개념의 명확한 정의 제공
- "무엇"과 "왜"가 "어떻게"보다 먼저 문서화

### 4. 적응형 상세화 (Adaptive Detailing)

- 필요한 수준만큼만 초기 문서화, 점진적으로 상세화
- 구현 경험에서 얻은 인사이트를 문서에 지속적으로 반영
- 문서의 깊이와 범위는 프로젝트 진행에 따라 진화

### 5. AI 이해 최적화 (AI Comprehension Optimization)

- AI가 효과적으로 이해할 수 있는 명확하고 체계적인 구조
- 관련 문서 간의 명시적 연결 제공
- 복잡한 결정에 대한 이유 설명을 포함

## 4W1H 문서 구조

4W1H 접근법은 직관적인 질문을 기반으로 문서를 구조화합니다:

- **WHY (왜)**: 이 프로젝트/기능이 왜 필요한가?
- **WHAT (무엇)**: 우리가 구축하는 것은 정확히 무엇인가?
- **HOW (어떻게)**: 이를 어떻게 구현하는가?
- **WHERE (어디서)**: 이 코드/시스템은 어디서 실행되는가?
- **WHEN (언제)**: 이 시스템은 언제 어떻게 변화하고 발전하는가?

이 구조는 다음과 같이 구성됩니다:

```
Project Documentation
├── 🧭 WHY - 목적과 방향
│   ├── Vision - 제품 비전과 해결하려는 문제
│   ├── Principles - 핵심 설계 원칙과 가치
│   └── Success-Metrics - 성공 기준과 평가 방법
│
├── 🗺️ WHAT - 시스템 정의
│   ├── System-Model - 핵심 개념과 용어 정의
│   ├── Architecture - 전체 시스템 구조와 구성요소
│   ├── Data-Model - 주요 데이터 엔티티와 관계
│   └── API-Contract - 내부/외부 인터페이스 정의
│
├── 🛠️ HOW - 구현 가이드
│   ├── Core-Patterns - 핵심 구현 패턴과 예제
│   ├── Technology-Stack - 기술 스택과 사용 방법
│   ├── Quality-Standards - 코드 품질과 테스트 기준
│   └── Common-Challenges - 주요 문제와 해결책
│
├── 🚀 WHERE - 환경과 배포
│   ├── Development - 개발 환경 설정
│   ├── Testing - 테스트 환경 구성
│   ├── Staging - 스테이징 환경 관리
│   └── Production - 운영 환경 배포 및 관리
│
└── 🔄 WHEN - 진화와 운영
    ├── Lifecycle - 시스템 라이프사이클 관리
    ├── Monitoring - 관측성과 알림 체계
    ├── Feedback-Loop - 피드백 수집과 반영 방법
    └── Roadmap - 향후 발전 계획
```

이 구조는 어떤 소프트웨어 프로젝트에도 적용 가능하며, 필요에 따라 확장할 수 있습니다.

## 문서-구현 병행 전략

### 1단계: 기초 문서 작성 (프로젝트 시작)

프로젝트 시작 시 최소한 다음 문서를 작성합니다:

- WHY/Vision - 제품의 목적과 방향성
- WHAT/System-Model/Overview - 핵심 개념 모델
- WHAT/Architecture/Overview - 기본 아키텍처
- HOW/Core-Patterns/[핵심패턴1] - 가장 중요한 패턴
- HOW/Technology-Stack/[핵심기술] - 핵심 기술 가이드

이 최소 문서 세트는 AI가 시스템의 비전과 핵심 구조를 이해하는 데 필수적입니다.

### 2단계: 초기 구현 + 점진적 문서화 (반복 사이클)

다음 단계들로 구성된 사이클을 반복합니다:

A. **기능 구현 단계** (1-2주 기간):

- MVP 문서를 바탕으로 특정 기능/컴포넌트 구현
- 구현 과정에서 발견된 인사이트 기록

B. **문서 업데이트 단계** (구현 직후):

- 구현 경험을 바탕으로 기존 문서 개선
- 다음 기능 구현에 필요한 1-2개 문서 추가 작성

C. **다음 기능 준비 단계** (업데이트 직후):

- 업데이트된 문서를 검토하고 다음 구현 기능 결정
- 새 사이클 시작: 다시 A단계로 돌아가 다음 기능 구현

이 반복적인 접근법을 통해 문서는 실제 구현 경험을 반영하고, 구현은 잘 정의된 문서를 기반으로 이루어집니다. 각 사이클이 완료될 때마다 제품과 문서가 함께 진화합니다.

### 3단계: 영역별 확장 (새로운 기능 도메인 추가)

2단계의 반복 사이클이 기존 도메인 내 기능 구현에 적합하다면, 3단계는 **완전히 새로운 기능 영역(도메인)을 추가**할 때 적용하는 접근법입니다. 이 과정은 다음과 같이 진행됩니다:

A. **개념 모델링 단계**:

- 새 기능 영역의 핵심 개념과 용어 정의
- WHAT/System-Model 섹션에 해당 개념 모델 문서 작성
- 이유: AI가 새 도메인을 정확히 이해하기 위한 기초 제공

B. **아키텍처 통합 단계**:

- 새 기능이 기존 시스템 아키텍처에 미치는 영향 분석
- WHAT/Architecture 문서 업데이트로 통합 지점 명시
- 이유: 기존 시스템과의 일관된 통합 보장

C. **핵심 패턴 정의 단계**:

- 새 영역에서 사용할 1-2개의 핵심 구현 패턴 식별
- HOW/Core-Patterns 섹션에 패턴 문서화
- 이유: 구현 일관성과 재사용성 확보

D. **초기 구현 단계**:

- 정의된 모델과 패턴을 기반으로 구현 시작
- 작은 범위로 시작하여 점진적 확장
- 이유: 패턴의 실효성 검증 및 초기 피드백 확보

E. **문서 확장 및 상세화 단계**:

- 구현 경험을 바탕으로 관련 문서 보강
- 실제 사례, 코드 예제, 발견된 제약사항 추가
- 이유: 이론이 아닌 실제 경험 기반 문서로 발전

이 과정이 완료되면, 새로운 기능 영역이 문서 체계에 통합되고, 이후 해당 영역 내에서는 2단계의 반복 사이클을 통해 점진적으로 기능을 확장해 나갑니다.

**적용 예시**: 메시징 플랫폼에 "사용자 분석" 기능 영역을 새로 추가할 경우, 먼저 분석 관련 개념 모델을 정의하고, 기존 메시징 시스템과의 통합 지점을 아키텍처에 반영한 후, "분석 데이터 수집 패턴"과 "인사이트 도출 패턴"을 문서화한 다음 구현을 시작합니다.

## 문서 템플릿

문서 템플릿은 문서의 목적과 유형에 따라 달라져야 합니다. 4W1H 구조에서 각 카테고리의 문서는 서로 다른 성격과 목적을 가지므로, 아래와 같이 유형별 템플릿을 제안합니다.

### 공통 필수 섹션

모든 문서 유형에 포함되어야 하는 기본 섹션입니다:

```markdown
# [문서 제목]

- **상태**: [초안 | 검토중 | 승인됨 | 폐기됨]
- **관련 문서**:
  - [문서1](document1)
  - [문서2](document2)
- **변경 이력**:
  - 0.6 (YYYY-MM-DD): [작성자] - [변경 내용]
  - 0.5 (YYYY-MM-DD): [작성자] - [이전 변경 내용]

## 개요

[핵심 개념과 목적에 대한 간결한 설명]

## 상세 내용

[주요 내용...]
```

### 1. 개념/전략 문서 템플릿 (WHY, 일부 WHAT)

비전, 원칙, 시스템 모델 등 개념적이고 전략적인 내용을 담는 문서에 적합합니다.

```markdown
# [문서 제목]

[메타데이터 내용...]

## 개요

[개요 내용...]

## 상세 내용

[상세 내용...]

## 원칙 및 가치

- [원칙 1]: [설명]
- [원칙 2]: [설명]
  ...

## 의사결정 기준

[이 개념/전략을 적용할 때 참고할 의사결정 기준]

## 영향 및 의존성

[이 개념/전략이 시스템 다른 부분에 미치는 영향]
```

### 2. 구현 관련 문서 템플릿 (HOW, 일부 WHAT)

코어 패턴, 기술 스택 등 직접적으로 구현과 관련된 문서에 적합합니다.

````markdown
# [문서 제목]

[메타데이터 내용...]

## 개요

[개요 내용...]

## 구현 요구사항

- [요구사항 1]
- [요구사항 2]
  ...

## 설계 결정 및 이유

| 결정 사항 | 채택된 접근법 | 대안     | 선택 이유 |
| --------- | ------------- | -------- | --------- |
| [결정 1]  | [접근법]      | [대안들] | [이유]    |

...

## 코드 예제

```코드 언어
구현 예제 또는 의사 코드
```

## 구현 인사이트

- **발견된 도전 과제**: [구현 중 발견된 문제들]
- **해결책**: [적용된 해결책과 학습된 교훈]
- **성능 고려사항**: [성능 관련 발견 사항]

## 다음 단계

- [다음 구현 단계 또는 개선 사항]

## AI 프롬프트 제안

- **설계 프롬프트**: "[이 컴포넌트 설계를 위한 프롬프트]"
- **구현 프롬프트**: "[구현을 위한 프롬프트]"
````

### 3. 환경/운영 문서 템플릿 (WHERE)

개발, 테스트, 운영 환경 등 배포 및 환경 관련 문서에 적합합니다.

```markdown
# [문서 제목]

[메타데이터 내용...]

## 개요

[개요 내용...]

## 환경 구성

- **인프라**: [인프라 설명]
- **서비스**: [주요 서비스 구성]
- **네트워크**: [네트워크 구성]

## 설정 및 배포 절차

1. [단계 1]
2. [단계 2]
   ...

## 접근 및 권한

- **접근 방법**: [접근 방법 설명]
- **필요 권한**: [권한 요구사항]

## 모니터링 및 유지보수

- **모니터링 도구**: [사용 도구]
- **주요 지표**: [모니터링할 핵심 지표]
- **알림 설정**: [알림 기준]

## 문제 해결 가이드

| 문제 상황 | 원인          | 해결 방법   |
| --------- | ------------- | ----------- |
| [문제 1]  | [가능한 원인] | [해결 단계] |

...
```

### 4. 시간/계획 문서 템플릿 (WHEN)

라이프사이클, 로드맵 등 시간적 요소와 계획에 관한 문서에 적합합니다.

```markdown
# [문서 제목]

[메타데이터 내용...]

## 개요

[개요 내용...]

## 마일스톤 및 일정

| 마일스톤     | 예상 일정 | 담당자   | 상태   |
| ------------ | --------- | -------- | ------ |
| [마일스톤 1] | [날짜]    | [담당자] | [상태] |

...

## 단계별 접근법

1. **[1단계 이름]** (기간)

   - [작업 항목 1]
   - [작업 항목 2]
     ...

2. **[2단계 이름]** (기간)
   ...

## 우선순위 및 의존성

- **높은 우선순위**: [항목들]
- **의존성**: [의존 관계 설명]

## 리스크 및 완화 전략

| 리스크     | 영향             | 가능성           | 완화 전략 |
| ---------- | ---------------- | ---------------- | --------- |
| [리스크 1] | [높음/중간/낮음] | [높음/중간/낮음] | [전략]    |

...
```

### 템플릿 사용 지침

1. **목적 기반 선택**: 문서의 주요 목적에 가장 적합한 템플릿을 선택하세요.

2. **유연한 적용**: 템플릿은 엄격한 규칙이 아닌 가이드라인으로 사용하세요. 필요에 따라 섹션을 추가하거나 제거할 수 있습니다.

3. **일관성 유지**: 공통 섹션(메타데이터, 개요, 변경 이력)은 모든 문서에 포함하여 일관성을 유지하세요.

4. **진화하는 템플릿**: 프로젝트 경험에 따라 템플릿 자체도 발전시키세요. 효과적인 섹션은 유지하고 불필요한 섹션은 조정하세요.

5. **문서 간 참조**: 서로 다른 유형의 문서 간에 명확한 참조를 제공하여 전체 문서 체계가 유기적으로 연결되도록 하세요.

## AI 효과적 활용 전략

AI 주도 개발에서 문서는 AI와 개발자 간 협업의 핵심 매개체입니다. 다음 전략을 통해 문서를 활용한 AI 협업을 극대화할 수 있습니다.

### 1. 문서 기반 프롬프트 설계

각 문서 유형에 맞는 효과적인 프롬프트 패턴을 개발하고 문서화합니다:

**개념 문서(WHY) 활용 예시**

```
시스템: 당신은 [프로젝트명]의 개발을 돕는 AI 어시스턴트입니다. 다음 비전 문서를 기반으로 작업해주세요.

비전 문서: [WHY/Vision 문서 내용 붙여넣기]

사용자: 이 비전에 부합하는 [특정 기능]의 주요 요구사항을 3-5개 제안해주세요.
```

**시스템 정의 문서(WHAT) 활용 예시**

```
시스템: 다음은 [프로젝트명]의 시스템 모델입니다.

[WHAT/System-Model 문서 내용 붙여넣기]

사용자: 이 시스템 모델을 기반으로 [컴포넌트명]에 대한 클래스 다이어그램을 작성해주세요.
```

**구현 문서(HOW) 활용 예시**

```
시스템: 다음은 [프로젝트명]의 [패턴명] 구현 패턴 문서입니다.

[HOW/Core-Patterns 문서 내용 붙여넣기]

사용자: 이 패턴을 적용하여 [특정 기능]을 구현하는 코드를 작성해주세요.
```

### 2. 맥락 설정 최적화

AI에 제공하는 문서 조합을 통해 최적의 맥락을 설정하는 방법:

**기본 → 상세 순서로 제공**

잘못된 예:

```
사용자: 메시지 라우팅 시스템의 구현 코드를 작성해주세요.
```

개선된 예:

```
사용자: 다음 문서들을 차례대로 읽고 메시지 라우팅 시스템 구현 코드를 작성해주세요:

1. 먼저 전체 시스템 모델(WHAT/System-Model)을 읽고 이해하세요.
2. 다음으로 아키텍처 문서(WHAT/Architecture)에서 메시지 흐름을 파악하세요.
3. 마지막으로 메시지 라우팅 패턴(HOW/Core-Patterns/Message-Router)을 확인하세요.

이제 위 문서들의 내용을 기반으로 메시지 라우팅 시스템의 구현 코드를 작성해주세요.
```

**실제 프로젝트 시나리오: 새로운 메시징 채널 추가**

1. 개념 이해 단계:

   ```
   사용자: 다음 Vision과 System-Model 문서를 읽고, 새로운 메시징 채널(Slack)을 추가하는 것이 비전에 부합하는지 분석해주세요.

   [Vision 문서 내용]
   [System-Model 문서 내용]
   ```

2. 아키텍처 영향 분석 단계:

   ```
   사용자: 이제 다음 Architecture 문서와 Channel-Adapters 문서를 읽고, Slack 채널을 추가할 때 시스템 아키텍처에 미치는 영향을 분석해주세요.

   [Architecture 문서 내용]
   [Channel-Adapters 문서 내용]
   ```

3. 구현 계획 단계:

   ```
   사용자: 분석 결과를 바탕으로, Slack 채널 어댑터 구현을 위한 작업 계획을 수립해주세요.
   ```

4. 코드 구현 단계:
   ```
   사용자: 이제 Channel-Adapters 패턴 문서를 참고하여 Slack 어댑터 코드를 구현해주세요.
   ```

### 3. 피드백 루프 설계

AI와의 효과적인 피드백 루프를 설계하는 과정:

**문서-코드-피드백 사이클 예시**

1. 초기 문서 작성:

   ```
   // Message-Router.md 문서 초안 작성
   ```

2. AI 기반 구현:

   ```
   사용자: Message-Router.md 문서를 기반으로 라우터 클래스를 구현해주세요.
   AI: [코드 구현 제공]
   ```

3. 구현 결과 분석:

   ```
   사용자: 구현된 코드를 테스트한 결과, 대용량 메시지 처리 시 병목 현상이 발생했습니다. 이 문제를 분석해주세요.
   AI: [병목 원인 분석 및 해결책 제안]
   ```

4. 문서 업데이트:

   ```
   사용자: 발견된 문제와 해결책을 Message-Router.md 문서에 추가해주세요.
   AI: [문서 업데이트 제안]
   ```

5. 개선된 구현:
   ```
   사용자: 업데이트된 문서를 바탕으로 개선된 라우터 코드를 작성해주세요.
   AI: [개선된 코드 제공]
   ```

**효과적인 피드백 제공 예시**:

```
사용자: 작성한 코드에 대한 피드백입니다:

1. 성능: 대용량 처리 시 메모리 사용량이 예상보다 30% 높았습니다.
2. 가독성: 라우팅 로직이 너무 복잡해 유지보수가 어렵습니다.
3. 확장성: 새 채널 추가 시 코드 변경이 많이 필요했습니다.

이 세 가지 문제를 해결하는 방향으로 코드를 개선해주세요.
```

### 4. AI 한계 관리

AI가 어려워하는 영역을 식별하고 이를 보완하는 문서화 전략:

**명시적 제약조건 문서화**

```markdown
## 구현 제약조건

- **성능 요구사항**: 메시지 처리 지연시간은 100ms 이하여야 함
- **확장성 요구사항**: 초당 10,000개 메시지를 처리할 수 있어야 함
- **리소스 제약**: 서버당 최대 2GB 메모리 사용

## 중요 고려사항

- Elixir의 GenServer를 사용할 경우 상태 관리에 주의해야 함
- 데이터베이스 연결 풀은 최대 100개로 제한됨
- 외부 API 호출은 재시도 메커니즘을 반드시 포함해야 함
```

**단계적 문제 분해 예시**

복잡한 문제를 다룰 때:

```
사용자: 다음 단계로 분해하여 메시지 우선순위 시스템을 구현해주세요:

1. 먼저 우선순위 모델 클래스를 정의해주세요.
2. 다음으로 우선순위 큐 구현을 작성해주세요.
3. 그 다음 기존 라우터에 우선순위 처리 기능을 통합해주세요.
4. 마지막으로 우선순위 조정 API를 작성해주세요.

각 단계마다 중간 결과를 확인하겠습니다.
```

### 5. 실제 AI 주도 개발 워크플로우 예시

**새로운 기능 개발 시나리오**:

1. 개념 정의 단계:

   - WHY 문서 검토 후 새 기능의 비전 부합성 확인
   - WHAT/System-Model 문서를 참조하여 개념 모델 확장

   ```
   사용자: Vision 문서를 검토한 후, 새로운 "사용자 세그먼트" 기능이 우리 제품 비전에 어떻게 부합하는지 분석해주세요.
   ```

2. 설계 단계:

   - WHAT/Architecture 문서를 참조하여 아키텍처 영향 분석
   - HOW/Core-Patterns 문서를 검토하여 적용 가능한 패턴 식별

   ```
   사용자: Architecture 문서와 Core-Patterns 문서를 검토한 후, 사용자 세그먼트 기능을 구현하기 위한 설계안을 제시해주세요.
   ```

3. 구현 계획 단계:

   - 설계안을 바탕으로 구현 작업 분해
   - 각 작업별 우선순위 및 의존성 결정

   ```
   사용자: 제안한 설계안을 바탕으로, 사용자 세그먼트 기능 구현을 위한 작업 목록과 순서를 정리해주세요.
   ```

4. 구현 단계:

   - 작업 목록에 따라 순차적으로 구현
   - 각 구현 단계마다 단위 테스트 작성

   ```
   사용자: 이제 첫 번째 작업인 "세그먼트 모델 클래스" 구현 코드를 작성해주세요. Segment.ex 파일에 정의될 내용입니다.
   ```

5. 문서화 단계:

   - 구현 과정에서 발견된 인사이트로 기존 문서 업데이트
   - 새 기능에 대한 문서 작성

   ```
   사용자: 지금까지의 구현 경험을 바탕으로 Segmentation.md 문서를 작성해주세요. HOW/Core-Patterns 섹션에 추가될 문서입니다.
   ```

6. 검증 단계:

   - 구현된 기능의 테스트 케이스 작성
   - 성능 및 확장성 검증

   ```
   사용자: 세그먼트 기능에 대한 통합 테스트 코드를 작성해주세요. 다양한 세그먼트 조건과 대용량 사용자 데이터 상황을 테스트해야 합니다.
   ```

7. 배포 준비 단계:

   - WHERE 문서를 참조하여 배포 계획 수립
   - 롤백 계획 및 모니터링 전략 준비

   ```
   사용자: Production.md 문서를 참조하여, 세그먼트 기능의 단계적 롤아웃 계획을 작성해주세요.
   ```

이러한 접근법을 통해 AI는 단순히 코드 생성 도구가 아닌, 전체 개발 프로세스의 파트너로 기능하며 문서는 이 협업의 중심축이 됩니다.

## 성공 사례 및 안티패턴

### 성공 사례

- **개념 모델 시각화**: 복잡한 개념을 다이어그램으로 표현
- **변경 이유 문서화**: 설계 결정의 배경과 이유 기록
- **점진적 상세화**: 필요에 따라 문서 깊이 조절
- **코드-문서 연계**: 코드와 문서 간 명확한 연결 유지
- **학습 기반 문서화**: 실제 구현 경험을 문서에 반영

### 안티패턴

- **문서 과잉**: 필요 이상으로 상세한 문서 작성
- **구현 없는 문서화**: 실제 경험 없이 이론적 문서만 작성
- **문서-코드 불일치**: 문서와 실제 구현의 차이 발생
- **지나친 형식주의**: 문서 형식에 집착하여 내용 부실
- **고립된 지식**: 문서 간 연결 없이 단편적 정보만 제공

## 결론

AI 주도 개발을 위한 문서화는 단순한 참조 자료 작성을 넘어, AI와 인간 개발자 모두를 위한 공유된 이해의 기반을 구축하는 과정입니다. 문서는 프로젝트의 핵심 자산으로서, 코드와 동일한 중요성과 관심을 받아야 합니다.

이 가이드에서 제시한 원칙과 전략을 적용하면, 문서는 단지 구현 후의 산출물이 아닌, 개발 프로세스의 핵심 동력이 됩니다. 결과적으로 AI와의 협업은 더욱 효율적이고 효과적으로 이루어지며, 소프트웨어의 품질과 유지보수성이 향상됩니다.

## 부록: 문서화 시작을 위한 체크리스트

1. [ ] WHY 섹션의 비전 문서 작성
2. [ ] 핵심 용어와 개념 정의
3. [ ] 상위 수준 아키텍처 다이어그램 작성
4. [ ] 가장 중요한 구현 패턴 1-2개 문서화
5. [ ] 주요 기술 스택 가이드 준비
6. [ ] 개발 환경 설정 문서 작성
7. [ ] 문서-코드 연계 전략 수립
8. [ ] 문서 리뷰 및 업데이트 프로세스 정의
