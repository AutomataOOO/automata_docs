// File: automata-signal/1-guides/GUIDE-001-getting-started

# [GUIDE-001] 시작하기

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 요약

본 문서는 Automata-Signal 프로젝트의 개발 환경 구축을 위한 단계별 가이드를 제공합니다. Elixir Umbrella 프로젝트 생성부터 Ash Framework 설치, 그리고 기본 구성까지의 과정을 포함합니다.

## 대상 독자

- 신규 개발자
- 개발팀

## 사전 요구사항

Automata-Signal 개발을 시작하기 전에 다음 도구가 설치되어 있어야 합니다:

- **Elixir**: 1.18 이상
- **Erlang/OTP**: 27 이상
- **PostgreSQL**: 17 이상
- **Git**: 최신 버전
- **Flutter**: 최신 안정 버전 (SDK 개발 시)

## 1. Umbrella 프로젝트 생성

> 참고: 실제 개발 환경에서는 이 단계를 생략하고 기존 프로젝트 저장소를 클론하여 작업하는 경우가 일반적입니다. 아래 설명은 프로젝트를 처음부터 새로 생성하는 경우에 참고하세요.

Automata-Signal은 Elixir Umbrella 프로젝트 구조를 사용합니다. 다음 명령으로 프로젝트를 생성합니다:

```bash
# Umbrella 프로젝트 생성
mix new automata --umbrella

# 생성된 디렉토리로 이동
cd automata

# Git 저장소 초기화
git init
git add .
git commit -m "Initial commit: Umbrella project structure"
```

이렇게 하면 다음과 같은 기본 구조가 생성됩니다:

```
automata/
├── .git/
├── .gitignore
├── README.md
├── apps/
├── config/
└── mix.exs
```

## 2. Automata-Signal 앱 생성 및 Ash Framework 설치

Umbrella 프로젝트 내에 automata_signal 앱을 생성하고 Ash Framework와 관련 확장을 설치합니다:

```bash
# apps 디렉토리로 이동
cd apps

# 설치 스크립트 실행
sh <(curl 'https://ash-hq.org/install/automata_signal?install=phoenix') \
    && cd automata_signal && mix igniter.install ash ash_phoenix \
    ash_json_api ash_postgres --yes
```

이 명령은 다음 작업을 수행합니다:

1. Ash 설치 스크립트를 실행하여 automata_signal Phoenix 앱을 생성합니다
2. ash와 ash_phoenix, ash_json_api, ash_postgres 확장을 설치합니다

### 추가 Ash 확장 설치

기본 Ash 확장이 설치된 후, 필요한 추가 확장을 설치합니다:

```bash
# apps/automata_signal 디렉토리에서 실행
mix igniter.install ash_state_machine ash_oban ash_paper_trail ash_archival \
    ash_cloak ash_money ash_double_entry ash_csv --yes
```

이 명령은 다음 Ash 확장 모듈을 설치합니다:

- ash_state_machine: 상태 기계 관리
- ash_oban: 비동기 작업 처리
- ash_paper_trail: 변경 추적
- ash_archival: 논리적 삭제
- ash_cloak: 데이터 암호화
- ash_money: 통화 처리
- ash_double_entry: 이중 원장
- ash_csv: CSV 내보내기

## 3. Ash 설정 적용

앱 생성과 확장 설치가 완료된 후, Ash Framework 초기화를 위해 설정을 적용합니다:

```bash
mix ash.setup
```

## 4. 서버 실행

프로젝트 설정이 완료되면 개발 서버를 실행할 수 있습니다:

```bash
# 개발 서버 실행
mix phx.server

# 또는 대화형 셸과 함께 실행
iex -S mix phx.server
```

## 5. 자주 발생하는 문제 해결

### PostgreSQL 연결 오류

- PostgreSQL 서비스가 실행 중인지 확인
- 사용자 이름과 비밀번호가 올바른지 확인
- 데이터베이스 생성 권한이 있는지 확인

### 의존성 충돌

- `mix deps.unlock --all` 명령으로 의존성 잠금 해제 후 `mix deps.get`을 다시 실행
- 최신 Hex 패키지를 사용 중인지 확인: `mix local.hex`

## 6. 참고 자료

- [Elixir 공식 문서](https://elixir-lang.org/docs.html)
- [Phoenix Framework 가이드](https://hexdocs.pm/phoenix/overview.html)
- [Ash Framework 시작하기 가이드](https://hexdocs.pm/ash/get-started.html)
- [Ash Phoenix 문서](https://hexdocs.pm/ash_phoenix/AshPhoenix.html)
- [Ash JSON API 문서](https://hexdocs.pm/ash_json_api/AshJsonApi.html)
- [Ash Postgres 문서](https://hexdocs.pm/ash_postgres/AshPostgres.html)
- [Oban 문서](https://hexdocs.pm/oban/Oban.html)

---

// File: automata-signal/1-guides/GUIDE-002-project-structure

# [GUIDE-002] 프로젝트 구조

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 요약

본 문서는 Automata-Signal 프로젝트의 전체 디렉토리 구조와 주요 구성 요소에 대한 설명을 제공합니다. 개발자가 프로젝트 구조를 이해하고 필요한 파일을 빠르게 찾을 수 있도록 도움을 줍니다.

## 대상 독자

- 신규 개발자
- 개발팀

## 1. 전체 프로젝트 구조

Automata-Signal 프로젝트는 Elixir Umbrella 구조를 사용하여 여러 관련 애플리케이션을 하나의 프로젝트로 관리합니다. 전체 프로젝트 구조는 다음과 같습니다:

```
automata/                             # Elixir Umbrella 프로젝트 루트
├── .git/                             # Git 저장소
├── .github/                          # GitHub Actions 워크플로우
├── .gitignore                        # Git 무시 파일 목록
├── README.md                         # 프로젝트 루트 README
├── apps/                             # Umbrella 하위 애플리케이션
│   ├── automata_signal/              # 통합 메시징 서비스 앱
│   ├── automata_admin/               # 관리자 인터페이스 앱
│   └── automata_analytics/           # 데이터 분석 앱
├── config/                           # Umbrella 공통 설정
├── docs/                             # 프로젝트 문서
│   └── automata-signal/
│       ├── README.md                 # 프로젝트 개요
│       ├── 1-guides/                 # 개발자 가이드
│       ├── 2-designs/                # 시스템 설계
│       ├── 3-components/             # 컴포넌트
│       ├── 4-sequences/              # 시퀀스
│       ├── 5-references/             # 참조 자료
│       ├── 6-planning/               # 프로젝트 계획
│       └── 7-progress/               # 프로젝트 진행
└── mix.exs                           # Umbrella 프로젝트 설정 파일
```

## 2. 주요 애플리케이션

### 2.1 automata_signal (통합 메시징 서비스 앱)

메시지 전송, 구독 관리, 템플릿 처리 등 핵심 메시징 기능을 담당하는 앱입니다.

```
automata_signal/
├── lib/                      # 소스 코드
│   ├── automata_signal/      # 비즈니스 로직
│   │   ├── resources/        # Ash 리소스 정의
│   │   ├── services/         # 서비스 로직 모듈
│   │   ├── workers/          # ash_oban 비동기 작업자
│   │   ├── adapters/         # 채널별 어댑터 모듈
│   │   ├── templates/        # 메시지 템플릿 시스템
│   │   └── campaigns/        # 캠페인 관리 모듈
│   └── automata_signal_web/  # 웹 인터페이스
│       ├── controllers/      # API 엔드포인트 처리
│       └── views/            # 응답 데이터 포맷팅
├── priv/                     # 정적 파일 및 마이그레이션
│   ├── repo/                 # 데이터베이스 마이그레이션
│   └── static/               # 정적 파일
├── test/                     # 단위 및 통합 테스트
│   ├── automata_signal/      # 비즈니스 로직 테스트
│   └── automata_signal_web/  # 웹 인터페이스 테스트
└── client/                   # Flutter 모바일 클라이언트
    ├── lib/                  # Flutter 앱 소스 코드
    └── test/                 # Flutter 앱 테스트
```

### 2.2 automata_admin (관리자 인터페이스 앱)

시스템 관리, 모니터링 및 보고서 생성을 위한 관리자 인터페이스를 제공하는 앱입니다.

```
automata_admin/
├── lib/
│   ├── automata_admin/       # 관리자 비즈니스 로직
│   └── automata_admin_web/   # 관리자 웹 인터페이스
├── priv/
│   └── static/               # 관리자 UI 정적 파일
└── test/                     # 관리자 앱 테스트
```

### 2.3 automata_analytics (데이터 분석 앱)

메시지 성과 분석, 사용자 참여 지표, 캠페인 성공률 등을 분석하고 시각화하는 앱입니다.

```
automata_analytics/
├── lib/
│   ├── automata_analytics/    # 분석 비즈니스 로직
│   └── automata_analytics_web/ # 분석 웹 인터페이스
├── priv/
└── test/                     # 분석 앱 테스트
```

## 3. 주요 디렉토리 및 파일 설명

### 3.1 메시징 서비스 핵심 구성 요소

#### resources/

Ash Framework 리소스 정의가 포함된 디렉토리입니다. 주요 리소스에는 다음이 포함됩니다:

- `message.ex`: 메시지 리소스 정의
- `subscription.ex`: 구독 리소스 정의
- `user.ex`: 사용자 리소스 정의
- `application.ex`: 애플리케이션 리소스 정의
- `message_template.ex`: 메시지 템플릿 리소스 정의
- `message_campaign.ex`: 캠페인 리소스 정의

#### services/

비즈니스 로직을 담당하는 서비스 모듈이 포함된 디렉토리입니다:

- `message_service.ex`: 메시지 생성 및 전송 로직
- `subscription_service.ex`: 구독 관리 로직
- `template_service.ex`: 템플릿 렌더링 및 변수 치환
- `campaign_service.ex`: 캠페인 처리 및 타겟팅 로직

#### workers/

비동기 작업을 처리하는 Oban 워커가 포함된 디렉토리입니다:

- `message_worker.ex`: 메시지 전송 작업자
- `campaign_worker.ex`: 캠페인 메시지 처리 작업자
- `scheduled_message_worker.ex`: 예약된 메시지 처리 작업자

#### adapters/

다양한 메시징 채널을 위한 어댑터 모듈이 포함된 디렉토리입니다:

- `push_adapter.ex`: 푸시 알림 채널 (iOS/Android)
- `email_adapter.ex`: 이메일 채널 (지원 예정)
- `sms_adapter.ex`: SMS 채널 (지원 예정)
- `kakao_adapter.ex`: 카카오 알림톡 채널 (지원 예정)
- `in_app_adapter.ex`: 인앱 메시지 채널 (지원 예정)

#### templates/

메시지 템플릿 처리를 위한 모듈이 포함된 디렉토리입니다:

- `template_engine.ex`: 템플릿 렌더링 엔진
- `variable_processor.ex`: 변수 처리 및 치환 로직

#### campaigns/

대량 메시지 캠페인 관리를 위한 모듈이 포함된 디렉토리입니다:

- `campaign_manager.ex`: 캠페인 생성 및 관리
- `targeting_engine.ex`: 타겟팅 및 세그먼트 로직
- `scheduling_manager.ex`: 캠페인 예약 및 일정 관리

### 3.2 웹 인터페이스 구성 요소

#### controllers/

API 엔드포인트 처리를 위한 컨트롤러가 포함된 디렉토리입니다:

- `message_controller.ex`: 메시지 관련 API 엔드포인트
- `subscription_controller.ex`: 구독 관련 API 엔드포인트
- `campaign_controller.ex`: 캠페인 관련 API 엔드포인트
- `template_controller.ex`: 템플릿 관련 API 엔드포인트

#### views/

API 응답 포맷팅을 담당하는 뷰 모듈이 포함된 디렉토리입니다:

- `message_view.ex`: 메시지 응답 포맷팅
- `subscription_view.ex`: 구독 응답 포맷팅
- `error_view.ex`: 오류 응답 포맷팅

### 3.3 설정 파일

#### config/

Umbrella 프로젝트 및 각 앱의 설정 파일이 포함된 디렉토리입니다:

- `config.exs`: 공통 설정
- `dev.exs`: 개발 환경 설정
- `test.exs`: 테스트 환경 설정
- `prod.exs`: 프로덕션 환경 설정
- `runtime.exs`: 런타임 설정

### 3.4 문서

#### docs/automata-signal/

프로젝트 문서가 포함된 디렉토리입니다:

- `README.md`: 프로젝트 개요
- `1-guides/`: 개발자 가이드 (설정, 워크플로우, 코딩 표준 등)
- `2-designs/`: 시스템 설계 문서 (아키텍처, 데이터 모델 등)
- `3-components/`: 컴포넌트 설명 (템플릿 엔진, 어댑터 등)
- `4-sequences/`: 시퀀스 문서 (메시지 처리 흐름, 초기화 등)
- `5-references/`: 참조 자료 (API 명세, 상태 코드 등)
- `6-planning/`: 프로젝트 계획 (요구사항, 로드맵 등)
- `7-progress/`: 프로젝트 진행 상황

## 4. 중요 파일 설명

### 4.1 mix.exs

Umbrella 프로젝트의 Elixir 의존성 및 설정을 정의하는 파일입니다. 이 파일은 프로젝트의 모든 앱에 공통으로 적용되는 의존성을 포함합니다.

```elixir
defmodule Automata.MixProject do
  use Mix.Project

  def project do
    [
      apps_path: "apps",
      version: "0.1.0",
      start_permanent: Mix.env() == :prod,
      deps: deps(),
      aliases: aliases()
    ]
  end

  defp deps do
    [
      # 모든 앱에 공통으로 적용되는 의존성
    ]
  end

  defp aliases do
    [
      # 유용한 에일리어스 정의
      setup: ["deps.get", "cmd mix setup --no-archives-check"],
      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"]
    ]
  end
end
```

### 4.2 apps/automata_signal/mix.exs

automata_signal 앱의 의존성 및 설정을 정의하는 파일입니다. 이 앱에 필요한 Ash Framework 및 기타 의존성을 포함합니다.

```elixir
defmodule AutomataSignal.MixProject do
  use Mix.Project

  def project do
    [
      app: :automata_signal,
      version: "0.1.0",
      build_path: "../../_build",
      config_path: "../../config/config.exs",
      deps_path: "../../deps",
      lockfile: "../../mix.lock",
      elixir: "~> 1.18",
      elixirc_paths: elixirc_paths(Mix.env()),
      start_permanent: Mix.env() == :prod,
      aliases: aliases(),
      deps: deps()
    ]
  end

  defp deps do
    [
      # automata_signal 앱에 필요한 의존성
      {:ash, "~> 2.15"},
      {:ash_phoenix, "~> 1.3"},
      {:ash_postgres, "~> 1.3"},
      {:ash_json_api, "~> 0.33.1"},
      {:ash_state_machine, "~> 0.2.0"},
      {:ash_oban, "~> 0.1.4"},
      {:ash_paper_trail, "~> 0.1.4"},
      {:ash_archival, "~> 0.2.0"},
      {:ash_cloak, "~> 0.1.1"},
      {:ash_money, "~> 0.1.2"},
      {:ash_double_entry, "~> 0.1.2"},
      {:ash_csv, "~> 0.1.4"},
      {:pigeon, "~> 2.0.0"}
    ]
  end

  defp aliases do
    [
      setup: ["deps.get", "ecto.setup"],
      "ecto.setup": ["ecto.create", "ecto.migrate", "run priv/repo/seeds.exs"],
      "ecto.reset": ["ecto.drop", "ecto.setup"],
      test: ["ecto.create --quiet", "ecto.migrate --quiet", "test"]
    ]
  end
end
```

### 4.3 .github/workflows/ci.yml

GitHub Actions CI 파이프라인을 정의하는 파일입니다.

### 4.4 .github/workflows/deploy.yml

GitHub Actions를 통한 fly.io 배포 파이프라인을 정의하는 파일입니다.

## 5. 모듈 간 의존성 관계

Automata-Signal 프로젝트의 주요 모듈 간 의존성 관계는 다음과 같습니다:

```mermaid
graph TD
    Controllers[Controllers] --> Services[Services]
    Services --> Resources[Resources]
    Services --> Adapters[Channel Adapters]
    Services --> Templates[Template Engine]
    Workers[Oban Workers] --> Services
    Campaigns[Campaign Manager] --> Services
    Campaigns --> Templates
    Resources --> Database[(PostgreSQL)]
    Adapters --> ExternalServices[External Services]
```

- **Controllers**: API 요청을 처리하고 적절한 서비스를 호출합니다.
- **Services**: 비즈니스 로직을 구현하고 리소스, 어댑터, 템플릿 엔진을 활용합니다.
- **Resources**: 데이터 모델과 데이터베이스 상호작용을 정의합니다.
- **Adapters**: 다양한 메시징 채널과의 통신을 담당합니다.
- **Workers**: 비동기 작업을 처리하고 서비스를 호출합니다.
- **Templates**: 메시지 템플릿을 렌더링하고 변수를 처리합니다.
- **Campaigns**: 대량 메시지 캠페인을 관리하고 서비스와 템플릿 엔진을 활용합니다.

## 6. 확장 및 수정 가이드

### 6.1 새로운 채널 추가

새로운 메시징 채널을 추가하려면 다음 파일을 생성하거나 수정해야 합니다:

1. `adapters/new_channel_adapter.ex`: 새 채널에 대한 어댑터 구현
2. `resources/subscription.ex`: 새 채널 유형 추가
3. `services/message_service.ex`: 새 채널 지원 추가

### 6.2 새로운 앱 추가

Umbrella 프로젝트에 새 앱을 추가하려면:

```bash
cd apps
mix new my_new_app --sup
```

그런 다음 새 앱의 `mix.exs` 파일을 수정하여 Umbrella 프로젝트와 통합합니다.

## 7. 유용한 팁

- **루트 디렉토리에서 작업하기**: 대부분의 mix 명령은 루트 디렉토리에서 실행하는 것이 좋습니다. 이렇게 하면 모든 앱에 명령이 적용됩니다.
- **앱별 작업**: 특정 앱에서만 작업하려면 해당 앱 디렉토리로 이동한 후 명령을 실행합니다.

---

// File: automata-signal/1-guides/GUIDE-003-ai-driven-development-workflow

# [GUIDE-003] AI 주도 개발 워크플로우

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 요약

본 문서는 AI 주도 개발 워크플로우를 설명합니다. 기획/기술 문서를 바탕으로 AI가 자율적으로 계획 수립부터 코드 생성, 테스트, 배포까지 주도하는 프로세스와 인간 개발자의 검토 및 조정 방식을 다룹니다.

## 대상 독자

- 신규 개발자
- 개발팀

## 1. AI 주도 개발 워크플로우 개요

AI 주도 개발 워크플로우는 개발 생산성과 일관성을 극대화합니다:

```mermaid
flowchart TD
    문서작성[문서 작성<br>기획/기술 문서] --> 컨텍스트설정[컨텍스트 설정<br>ModelContextProvider]
    컨텍스트설정 --> Cursor[Cursor Agent 활성화]
    Cursor --> 요구사항분석[요구사항 분석<br>& 구현 계획]
    요구사항분석 --> 코드생성[코드 자동 생성]
    코드생성 --> 테스트생성[테스트 자동 생성]
    테스트생성 --> 결과검증[결과 검증]
    결과검증 -->|이슈 발생| 인간개입[인간 개입<br>& 결정]
    인간개입 --> 방향지시[방향 지시<br>& 컨텍스트 조정]
    방향지시 --> 코드생성
    결과검증 -->|성공| PR생성[PR 생성]
    PR생성 --> 인간검토[인간 검토]
    인간검토 -->|승인| 자동배포[CI/CD 파이프라인<br>자동 배포]
    인간검토 -->|수정 요청| Cursor
```

### 1.1 주요 단계 설명

1. **문서 작성**: 기획/기술 문서 작성 (설계, 요구사항, 데이터 모델 등)
2. **컨텍스트 설정**: 작성된 문서를 Github MCP(ModelContextProvider)에 연결
3. **Cursor Agent 활성화**: Cursor의 AI 에이전트 기능을 통해 자동 개발 시작
4. **요구사항 분석 & 구현 계획**: AI가 문서를 분석하고 구현 계획 수립
5. **코드 자동 생성**: 계획에 따라 코드 자동 생성
6. **테스트 자동 생성**: 구현 코드에 대한 테스트 코드 자동 생성
7. **결과 검증**: 생성된 코드와 테스트 결과 검증
8. **인간 개입 & 결정**: 문제 발생 시 인간 개발자의 결정 요청
9. **PR 생성**: 검증된 코드에 대한 PR 자동 생성
10. **인간 검토**: 최종 코드 검토 및 승인
11. **자동 배포**: CI/CD 파이프라인을 통한 자동 배포

### 1.2 AI와 인간 역할 분담

| 단계          | AI 역할                                 | 인간 역할                              |
| ------------- | --------------------------------------- | -------------------------------------- |
| 문서 작성     | 문서 초안 제안, 형식 검증               | 핵심 요구사항 및 설계 결정 정의        |
| 컨텍스트 설정 | 필요한 컨텍스트 제안                    | Github MCP 연결 및 구성                |
| 요구사항 분석 | 문서 분석, 아키텍처 결정, 작업 분할     | 모호한 부분 명확화, 우선순위 지정      |
| 코드 생성     | 전체 코드 작성, 문서화, 모범 사례 적용  | 병목 지점 해결, 접근법 조정            |
| 테스트 생성   | 테스트 케이스 생성, 테스트 실행 및 분석 | 엣지 케이스 추가, 테스트 범위 확인     |
| 결과 검증     | 코드 품질 분석, 오류 감지, 개선점 제안  | 비즈니스 로직 검증, 도메인 지식 제공   |
| PR 검토       | 자동 코드 리뷰, 개선 제안               | 최종 승인, 비즈니스 요구사항 충족 확인 |
| 배포          | 배포 스크립트 생성, 환경 설정           | 배포 승인, 결과 모니터링               |

## 2. 문서 기반 개발 프로세스

### 2.1 문서 구조와 개발 자동화 연계

AI 주도 개발은 문서 중심 개발 방식을 채택하여 문서가 코드 생성의 기반이 됩니다:

```
docs/
├── 1-guides/         # 개발 가이드 (개발 방식, 규칙)
├── 2-designs/        # 시스템 설계 (아키텍처, 데이터 모델)
├── 3-components/     # 컴포넌트 설계 (주요 모듈 상세 설계)
├── 4-sequences/      # 프로세스 시퀀스 (흐름 및 동작 방식)
├── 5-references/     # 참조 자료 (API 명세, 상태 코드 등)
├── 6-planning/       # 프로젝트 계획 (기능/비기능 요구사항, 개발 일정 및 마일스톤)
└── 7-progress/       # 작업 진행 관리 (설계 문서, 구현 계획, 상태 추적)
```

각 문서 유형이 개발 자동화에 미치는 영향:

| 문서 유형     | AI 개발 영향          | 기여 방식                      |
| ------------- | --------------------- | ------------------------------ |
| 설계 문서     | 아키텍처 및 구조 결정 | 클래스/모듈 구조, 패턴 적용    |
| 데이터 모델   | 스키마 및 관계 정의   | 모델 클래스, 마이그레이션 생성 |
| 컴포넌트 설계 | 구체적 구현 방식      | 세부 로직 및 알고리즘 구현     |
| 시퀀스 문서   | 프로세스 흐름         | 상태 관리 및 트랜지션 구현     |
| API 명세      | 인터페이스 정의       | 컨트롤러 및 라우트 구현        |

### 2.2 ModelContextProvider를 통한 문서 컨텍스트화

Github MCP(ModelContextProvider)는 AI가 개발 문서에 접근할 수 있게 해주는 도구입니다. MCP의 핵심 기능은 다음과 같습니다:

- 문서 저장소 연결: Github 저장소의 문서를 AI에게 지속적으로 접근 가능하게 함

MCP를 통해 문서에 접근한 후, AI는 자체적으로 다음 과정을 수행합니다(워크플로우의 "요구사항 분석 & 구현 계획" 단계):

- 작업에 필요한 문서를 자동으로 선택
- 문서 내용을 분석하여 작업 맥락에 맞게 처리
- 문서 간 관계를 이해하고 통합된 컨텍스트 구성

이를 통해 AI는 작업 유형(기능 개발, 버그 수정 등)에 따라 적절한 문서를 활용합니다. 개발자는 필요한 경우 중요한 문서를 명시적으로 언급하거나 특정 문서를 제외하도록 지시할 수 있습니다.

## 3. Cursor Agent를 활용한 자동 개발 프로세스

### 3.1 Cursor Agent 초기화 및 작업 지시

Cursor에서 AI 주도 개발을 시작하는 기본 명령:

```
Github MCP 컨텍스트를 기반으로 [기능명]을 구현해주세요.
docs의 설계 문서에 따라 구현하되, rules의 코딩 규칙을 준수해주세요.
```

이 명령을 내리면 Cursor Agent는 다음 단계로 진행합니다:

1. Github MCP를 통해 관련 문서 컨텍스트 로드
2. 코딩 규칙 적용
3. 구현 계획 자동 수립 및 표시
4. 개발자 확인 후 구현 시작
5. 코드 생성 및 테스트 진행
6. 결과 공유 및 다음 단계 제안

### 3.2 Agent의 자율적 계획 및 구현 프로세스

Cursor Agent는 다음과 같은 자율적 개발 프로세스를 수행합니다:

```mermaid
flowchart TD
    컨텍스트로드[MCP 컨텍스트 로드] --> 요구사항이해[요구사항 이해]
    요구사항이해 --> 의존성분석[의존성 및 제약사항 분석]
    의존성분석 --> 계획수립[구현 계획 수립]
    계획수립 --> 계획표시[계획 표시 및 인간 확인]
    계획표시 -->|승인| 파일식별[관련 파일 식별]
    계획표시 -->|수정| 계획재조정[계획 재조정]
    계획재조정 --> 계획표시
    파일식별 --> 작업분할[작업 단위 분할]
    작업분할 --> 코드생성[코드 자동 생성]
    코드생성 --> 테스트생성[테스트 코드 생성]
    테스트생성 --> 로컬테스트[로컬 테스트 실행]
    로컬테스트 -->|성공| 코드정리[코드 정리 및 문서화]
    로컬테스트 -->|실패| 오류분석[오류 분석]
    오류분석 -->|자체 해결 가능| 코드수정[코드 수정]
    오류분석 -->|인간 판단 필요| 인간질문[인간에게 질문]
    코드수정 --> 로컬테스트
    인간질문 --> 인간응답[인간 응답]
    인간응답 --> 방향재설정[개발 방향 재설정]
    방향재설정 --> 코드수정
    코드정리 --> 변경요약[변경사항 요약]
    변경요약 --> PR준비[PR 준비]
```

1. **요구사항 이해**: MCP 컨텍스트에서 요구사항 추출 및 분석
2. **구현 계획 수립**: 단계별 구현 계획과 예상 결과물 정의
3. **관련 파일 식별**: 수정이 필요한 기존 파일 및 새로 생성할 파일 식별
4. **작업 단위 분할**: 모듈/클래스/함수 단위로 작업 분할
5. **코드 자동 생성**: 각 작업 단위별 코드 생성
6. **테스트 코드 생성**: 생성된 코드에 대한 테스트 코드 작성
7. **로컬 테스트**: 생성된 코드의 로컬 테스트 실행
8. **오류 분석 및 해결**: 발생한 오류의 자동 분석 및 해결
9. **코드 정리 및 문서화**: 최종 코드 정리 및 인라인 문서 추가
10. **변경사항 요약**: 구현 내용과 변경사항 종합적 요약
11. **PR 준비**: 코드 리뷰를 위한 PR 준비

### 3.3 인간 개입 지점 및 협업 방식

Cursor Agent와 인간 개발자 간의 효과적인 협업을 위한 주요 개입 지점:

| 개입 지점       | 상황                        | 인간 역할           | Agent 역할                  |
| --------------- | --------------------------- | ------------------- | --------------------------- |
| 계획 확인       | 구현 시작 전                | 계획 검토 및 조정   | 계획 수립 및 설명           |
| 아키텍처 결정   | 설계 문서에 없는 결정 필요  | 아키텍처 결정 제공  | 결정에 따른 구현            |
| 모호한 요구사항 | 문서 상 불명확한 사항       | 명확한 방향 제시    | 질문 및 대안 제시           |
| 기술적 병목     | 복잡한 알고리즘/최적화 필요 | 접근법 제안         | 구현 방향 조정              |
| 테스트 실패     | 예상치 못한 테스트 실패     | 원인 분석 지원      | 실패 원인 설명 및 대안 제시 |
| 작업 계획 검토  | 구현 전/중간 변경 시        | 설계/계획 문서 검토 | 설계/계획 문서 초안 작성    |
| 코드 검토       | 구현 완료 후                | 비즈니스 로직 검증  | 설계 준수 확인              |

개입 신호 체계:

```
# Agent가 인간에게 결정 요청
[결정 필요] 메시지 템플릿 엔진의 변수 처리 방식에 대한 결정이 필요합니다:
1. 옵션A: Handlebars 스타일 (`{{var}}`)
2. 옵션B: EEx 스타일 (`<%= var %>`)

# 인간이 Agent에게 방향 제시
[방향 제시] 옵션A를 선택합니다. 기존 문서에 명시된 예제와 일관성을 유지하기 위함입니다.
```

작업 계획 및 진행 관리:

- 대규모 변경 전: Agent는 설계 문서(`7-progress/[작업명]_design.md`)와 구현 계획(`7-progress/[작업명]_plan.md`)을 생성하고 인간의 검토를 기다립니다.
- 진행 상태 추적: Agent는 작업 진행 상황을 `7-progress/status.md` 파일에 기록하고, 각 작업 항목의 상태(완료/진행중/예정)를 표시합니다.

## 4. 개발 산출물 관리 및 통합

### 4.1 코드 생성 및 테스트 자동화

Cursor Agent가 자동으로 생성하는 주요 산출물:

1. **구현 코드**: 설계 문서를 기반으로 한 실제 구현 코드
2. **테스트 코드**: 단위 테스트, 통합 테스트, 기능 테스트
3. **문서화**: 인라인 코드 문서, README, API 문서
4. **마이그레이션 스크립트**: 데이터베이스 스키마 변경 스크립트
5. **구현 보고서**: 결정 사항, 접근 방식, 알고리즘 설명 등

자동 테스트 프로세스:

```mermaid
flowchart LR
    코드생성[코드 생성] --> 단위테스트[단위 테스트 작성]
    단위테스트 --> 통합테스트[통합 테스트 작성]
    통합테스트 --> 테스트실행[테스트 자동 실행]
    테스트실행 -->|성공| 커버리지분석[코드 커버리지 분석]
    테스트실행 -->|실패| 실패분석[실패 원인 분석]
    실패분석 -->|Agent 해결| 코드수정[코드 수정]
    실패분석 -->|인간 판단 필요| 인간개입[인간 개입 요청]
    코드수정 --> 테스트실행
    인간개입 --> 방향설정[방향 설정]
    방향설정 --> 코드수정
    커버리지분석 -->|충분| PR준비[PR 준비]
    커버리지분석 -->|불충분| 테스트추가[테스트 케이스 추가]
    테스트추가 --> 테스트실행
```

### 4.2 PR 생성 및 코드 리뷰 프로세스

자동 생성된 코드의 PR 및 리뷰 프로세스:

1. **변경사항 요약**: 구현된 기능과 접근 방식 요약
2. **자동 PR 생성**: 구현 코드, 테스트, 문서 변경사항 포함
3. **AI 자체 리뷰**: 생성된 코드의 품질, 일관성, 표준 준수 여부 검토
4. **인간 리뷰 요청**: 핵심 검토 포인트 강조 및 리뷰 요청
5. **피드백 수집**: 인간 리뷰어의 피드백 수집
6. **피드백 반영**: 수집된 피드백에 따른 코드 개선
7. **최종 승인**: 인간 리뷰어의 최종 승인 후 병합

PR 템플릿 예시:

```markdown
# 자동 생성된 PR: [기능명]

## 구현 내용

- [주요 구현 기능 요약]
- [접근 방식 및 알고리즘 설명]
- [구현 결정사항 및 이유]

## 변경 파일

- [생성/수정된 파일 목록]

## 테스트 커버리지

- 단위 테스트: [커버리지 %]
- 통합 테스트: [커버리지 %]

## 리뷰 포인트

- [중점적으로 검토할 부분]
- [비즈니스 로직 검증 필요 부분]
- [성능 고려사항]

## 자동 생성 정보

- 생성 기반: [참조 문서 목록]
- Agent 버전: [Agent 버전]
```

### 4.3 CI/CD 통합 및 배포 자동화

AI 생성 코드의 CI/CD 통합 방식:

1. **PR 생성 시 자동 CI**: GitHub Actions를 통한 자동 테스트 및 검증
2. **품질 게이트**: 코드 품질, 테스트 커버리지, 보안 검사 자동화
3. **승인 후 자동 배포**: 승인된 PR의 자동 배포 파이프라인 연동
4. **롤백 준비**: 자동 배포 실패 시 롤백 메커니즘 준비
5. **배포 보고**: 배포 결과 및 성능 지표 자동 수집 및 보고

## 5. 작업 유형별 AI 주도 개발 가이드

### 5.1 새로운 기능 개발

```
Github MCP 컨텍스트를 기반으로 [기능명]을 구현해주세요.

참조 문서:
- 아키텍처: 2-designs/[관련아키텍처].md
- 데이터 모델: 2-designs/[관련데이터모델].md
- 컴포넌트 설계: 3-components/[관련컴포넌트].md

요구사항:
1. [주요 요구사항 1]
2. [주요 요구사항 2]
...

개발 범위:
- 구현 범위: [범위 명시]
- 제외 범위: [제외 범위 명시]
```

Agent는 문서 분석 후 구현 계획을 수립하고, 필요한 코드를 생성합니다.

### 5.2 기존 코드 리팩토링

```
Github MCP 컨텍스트를 기반으로 [모듈/파일명]을 리팩토링해주세요.

리팩토링 목적:
- [리팩토링 목적 설명]

유지해야 할 동작:
- [유지 필요 동작 목록]

개선 방향:
- [개선 방향 목록]

관련 파일:
- [파일 경로 목록]
```

Agent는 기존 코드를 분석하고, 동작을 유지하면서 코드 품질을 향상시키는 리팩토링을 수행합니다.

### 5.3 버그 수정

```
Github MCP 컨텍스트를 기반으로 다음 버그를 수정해주세요:

버그 설명:
- [버그 증상 및 발생 조건]

재현 단계:
1. [재현 단계 1]
2. [재현 단계 2]
...

예상 동작:
- [정상 동작 설명]

현재 동작:
- [현재 버그 동작 설명]

관련 파일:
- [파일 경로 목록]
```

Agent는 버그를 분석하고, 원인을 파악하여 수정 방안을 제시합니다.

### 5.4 성능 최적화

```
Github MCP 컨텍스트를 기반으로 [모듈/기능]의 성능을 최적화해주세요.

현재 성능:
- [현재 성능 지표]

목표 성능:
- [목표 성능 지표]

병목 지점:
- [예상 병목 지점]

제약 사항:
- [고려해야 할 제약사항]
```

Agent는 성능 병목 지점을 분석하고, 최적화 방안을 구현합니다.

### 5.5 테스트 보강

```
Github MCP 컨텍스트를 기반으로 [모듈/기능]의 테스트를 보강해주세요.

현재 커버리지:
- [현재 테스트 커버리지]

목표 커버리지:
- [목표 테스트 커버리지]

중점 테스트 영역:
- [중점적으로 테스트할 영역]

테스트 시나리오:
1. [시나리오 1]
2. [시나리오 2]
...
```

Agent는 기존 테스트를 분석하고, 부족한 테스트 케이스를 추가합니다.

## 6. 문제 해결 및 장애물 극복 전략

### 6.1 AI 개발 한계 상황 및 대응

AI 주도 개발 과정에서 발생할 수 있는 한계 상황과 대응 전략:

| 한계 상황            | 감지 방법                | 대응 전략                                 |
| -------------------- | ------------------------ | ----------------------------------------- |
| 불충분한 컨텍스트    | Agent가 필요 정보 요청   | 관련 문서 추가 또는 인간이 직접 설명      |
| 복잡한 비즈니스 로직 | Agent가 로직 명확화 요청 | 단계별 논리 흐름 설명 또는 의사 코드 제공 |
| 기술적 한계          | Agent가 접근법 요청      | 인간이 고수준 방향 제시                   |
| 외부 시스템 통합     | Agent가 API 명세 요청    | API 문서 참조 추가 또는 모킹 전략 제시    |
| 모호한 설계 결정     | Agent가 결정 요청        | 인간이 명확한 설계 결정 제공              |

### 6.2 효과적인 프롬프트 작성 가이드

AI 주도 개발을 위한 효과적인 프롬프트 작성 방법:

1. **명확한 목표 설정**: 무엇을 구현해야 하는지 명확히 정의
2. **관련 문서 참조**: 참조해야 할 문서를 명시적으로 지정
3. **제약 조건 명시**: 고려해야 할 제약 조건을 명확히 설명
4. **우선순위 지정**: 핵심 요구사항과 선택적 요구사항 구분
5. **예상 결과물 설명**: 기대하는 결과물의 형태와 품질 기준 제시
6. **작업 범위 정의**: 어디까지 구현할지 명확히 지정
7. **관련 계획 참조**: 관련된 요구사항 및 로드맵 문서 참조

효과적인 프롬프트 템플릿:

```
Github MCP 컨텍스트를 기반으로 [작업]을 수행해주세요.

목표:
- [작업의 명확한 목표]

참조 문서:
- [핵심 문서 목록]

요구사항:
- 필수: [필수 요구사항 목록]
- 선택: [선택적 요구사항 목록]

제약 조건:
- [고려해야 할 제약 조건]

예상 결과물:
- [기대하는 결과물 설명]

작업 범위:
- [작업 범위 정의]

작업 결과물:
- 설계 문서: 7-progress/[작업명]_design.md
- 구현 계획: 7-progress/[작업명]_plan.md
```

### 6.3 디버깅 및 문제 해결 프로세스

AI 주도 개발 중 발생하는 문제 해결 프로세스:

```mermaid
flowchart TD
    문제발생[문제 발생 감지] --> 원인분석[Agent의 원인 분석]
    원인분석 -->|자체 해결 가능| 해결방안[해결 방안 제시]
    원인분석 -->|인간 도움 필요| 문제보고[상세 문제 보고]
    문제보고 --> 질문생성[명확한 질문 생성]
    질문생성 --> 인간응답[인간 응답]
    인간응답 --> 응답분석[응답 분석 및 적용]
    응답분석 --> 후속질문[후속 질문 생성]
    후속질문 -->|추가 정보 필요| 인간응답
    응답분석 -->|충분한 정보| 해결방안
    해결방안 --> 구현[해결 방안 구현]
    구현 --> 검증[해결 검증]
    검증 -->|성공| 문서화[해결 과정 문서화]
    검증 -->|실패| 원인분석
```

1. **문제 정확히 정의**: 발생한 문제와 예상 동작의 차이점 명확화
2. **관련 컨텍스트 분석**: 문제와 관련된 코드 및 설계 문서 분석
3. **가설 수립**: 가능한 원인에 대한 여러 가설 수립
4. **가설 검증**: 각 가설을 검증할 수 있는 테스트 수행
5. **해결 방안 구현**: 검증된 원인에 대한 해결 방안 구현
6. **해결 검증**: 구현된 해결 방안의 효과 검증
7. **인간 개입 요청**: 필요 시 명확한 질문과 함께 인간 개입 요청

## 7. 지속적 개선 및 평가

### 7.1 AI 주도 개발 성과 측정

AI 주도 개발의 효과를 측정하기 위한 핵심 지표:

| 지표            | 측정 방법                      | 목표               |
| --------------- | ------------------------------ | ------------------ |
| 개발 속도       | 기능 구현 소요 시간            | 인간 대비 80% 감소 |
| 코드 품질       | 정적 분석 도구 점수            | 90점 이상 유지     |
| 테스트 커버리지 | 단위/통합 테스트 커버리지      | 85% 이상 유지      |
| 버그 발생률     | 프로덕션 배포 후 버그 수       | 인간 대비 50% 감소 |
| 유지보수성      | 코드 복잡도 및 결합도          | 낮은 복잡도 유지   |
| 인간 개입 비율  | AI 개발 과정 중 인간 개입 비율 | 20% 이하 유지      |

### 7.2 피드백 루프 및 개선 프로세스

AI 주도 개발 워크플로우의 지속적 개선을 위한 피드백 루프:

```mermaid
flowchart LR
    개발완료[개발 완료] --> 성과측정[성과 지표 측정]
    성과측정 --> 회고[AI-인간 공동 회고]
    회고 --> 개선점식별[개선 기회 식별]
    개선점식별 --> 문서화[개선 아이디어 문서화]
    문서화 --> 우선순위[개선 우선순위 지정]
    우선순위 --> 구현[개선 사항 구현]
    구현 --> 워크플로우적용[워크플로우 개선 적용]
    워크플로우적용 --> 평가[개선 효과 평가]
    평가 --> 다음개발[다음 개발 사이클]
    다음개발 --> 성과측정
```

1. **정기 회고**: 개발 사이클 완료 후 AI-인간 공동 회고 진행
2. **병목 지점 식별**: 워크플로우의 병목 지점 및 비효율적 과정 파악
3. **개선 아이디어 수집**: AI와 인간 개발자의 개선 아이디어 수집
4. **워크플로우 최적화**: 수집된 피드백을 바탕으로 워크플로우 조정
5. **문서 개선**: 설계 문서 및 가이드라인 지속적 개선
6. **조직 학습**: 성공 사례와 실패 사례를 통한 조직적 학습

### 7.3 학습 및 지식 공유

AI 주도 개발 경험의 축적 및 공유 방법:

1. **성공 패턴 카탈로그**: 효과적인 AI 주도 개발 패턴 문서화
2. **프롬프트 라이브러리**: 효과적인 프롬프트 템플릿 수집 및 공유
3. **장애물 해결 가이드**: 일반적인 문제 및 해결 방법 문서화
4. **워크샵 및 교육**: 팀원 간 AI 주도 개발 기법 공유
5. **지식 베이스**: 프로젝트별 AI 주도 개발 경험 축적
6. **AI 활용 모범 사례**: 효과적인 AI 활용 사례 및 방법 공유

## 8. 보안 및 품질 관리

### 8.1 AI 생성 코드의 보안 검증

AI 생성 코드의 보안성 확보를 위한 프로세스:

1. **자동 보안 검사**: 생성된 코드에 대한 자동 보안 취약점 스캔
2. **비밀 정보 처리 검증**: 민감 정보 처리에 대한 엄격한 검증
3. **권한 관리 검토**: 적절한 권한 부여 및 검증 메커니즘 확인
4. **입력 검증 확인**: 모든 외부 입력에 대한 검증 로직 점검
5. **보안 코드 리뷰**: 보안 관점에서의 추가 코드 리뷰
6. **취약점 DB 검증**: 알려진 취약점 패턴과의 비교 검증

### 8.2 품질 보증 프로세스

AI 생성 코드의 품질 보증을 위한 프로세스:

1. **자동화된 코드 품질 검사**: 정적 분석 도구를 통한 품질 검증
2. **테스트 케이스 충분성 검증**: 테스트 시나리오 및 커버리지 분석
3. **성능 벤치마크**: 주요 기능에 대한 성능 측정 및 기준 충족 확인
4. **코드 스타일 일관성**: 코딩 표준 준수 여부 검증
5. **문서화 품질**: 인라인 문서 및 API 문서 품질 검증
6. **복잡도 분석**: 코드 복잡도 및 유지보수성 분석

### 8.3 법적/윤리적 고려사항

AI 주도 개발에서의 법적/윤리적 고려사항:

1. **라이선스 준수**: 생성 코드의 라이선스 준수 확인
2. **데이터 보호**: 개인정보 및 민감 데이터 처리 관련 규정 준수
3. **공정성 및 편향**: 알고리즘 및 데이터 처리의 공정성 검증
4. **투명성**: 주요 결정 과정 및 근거의 투명한 문서화
5. **책임 소재**: AI 생성 코드에 대한 책임 소재 명확화
6. **법적 요구사항**: 관련 산업 및 지역의 법적 요구사항 준수

---

// File: automata-signal/1-guides/GUIDE-004-ai-coding-standards-ash-framework

# [GUIDE-006] AI 코딩 표준: Ash Framework

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 요약

본 문서는 AI를 활용한 코드 생성 시 Ash Framework에 특화된 코딩 표준을 제시합니다. 리소스 정의, 액션 구현, 확장 모듈 활용 등 Ash Framework 기반 애플리케이션 개발에서 일관성과 품질을 유지하기 위한 규칙과 패턴을 정의합니다.

## 대상 독자

- 신규 개발자
- 개발팀

## 1. 에이전트 지침

- **준수 의무:** 본 문서에 명시된 패턴, 템플릿, 규칙(`*규칙:*`) 및 절차(`*절차:*`)를 **엄격히 준수**하십시오. 단, 제공된 기술 명세서, 요구사항 정의서, 또는 인간 개발자의 명시적인 지침이 본 가이드와 상충될 경우 해당 지침을 우선합니다.
- **우선순위:** 코드 생성 시 명확성, 일관성, 성능, 유지보수성을 최우선으로 고려하십시오. Ash의 선언적 특성을 최대한 활용하십시오.
- **모호성 해결:** 본 가이드에서 다루지 않거나 해석이 모호한 상황 발생 시, 즉시 코드 생성을 중단하고 인간 개발자에게 명확한 지침을 요청하십시오. 추가 정보가 필요하다고 판단될 경우에만, 본 문서 13절에 명시된 공식 Ash 문서를 참조할 수 있으나, 본 가이드의 지침이 우선합니다.
- **피드백 반영:** 코드 리뷰 및 인간 개발자의 피드백(채팅 등)을 통해 생성된 코드를 수정하고 개선하십시오.

## 2. 핵심 원칙 및 개념 (요약)

AI 에이전트가 Ash 코드를 생성하기 위해 이해해야 할 기본 개념입니다. 세부 구현 규칙은 후속 섹션을 참조하십시오.

- **선언적 정의:** Ash는 데이터 모델(Resource)과 그 동작(Action)을 Elixir 코드로 선언합니다. AI는 이 선언적 정의 생성에 집중합니다.
- **핵심 구성:** Resources, Attributes, Relationships, Actions, Calculations, Aggregates, Data Layers, Extensions, Domains. (세부 사항은 각 구현 표준 섹션 참조)

## 3. 표준 구현 워크플로우

### 3.1 파일 생성 순서 (규칙)

다음 순서를 엄격히 준수하여 파일을 생성하고 구현하십시오. 이는 모듈 간 의존성을 관리하고 코드 구조를 일관되게 유지하기 위함입니다.

1. **Behaviours** (Elixir Behaviours, 인터페이스 정의 시)
2. **Ash Resources** (`lib/my_app/domain_name/resources/`) - 도메인별 하위 디렉토리 사용 권장
3. **유틸리티 모듈** (`lib/my_app/support/` 또는 `lib/my_app/utils/`)
4. **서비스/컨텍스트 모듈** (`lib/my_app/domain_name/services/` 또는 `lib/my_app/domain_name/`)
5. **어댑터/통합 모듈** (`lib/my_app/adapters/`)
6. **Ash Domain 모듈** (`lib/my_app/domain_name/domain.ex`) - 도메인 정의
7. **웹 인터페이스 관련** (`lib/my_app_web/controllers/`, `lib/my_app_web/live/` 등)
8. **테스트 코드** (`test/my_app/domain_name/resources/`, `test/my_app_web/` 등 각 단계별 생성)

### 3.2 자동 문서화 및 주석 (규칙)

- 생성하는 모든 Elixir 모듈에는 `@moduledoc` 을 사용하여 모듈의 목적과 역할을 명확히 설명하십시오.
- 생성하는 모든 public 함수(특히 Ash Action, Calculation 등)에는 `@doc` 을 사용하여 파라미터, 반환값, 기능 설명을 포함시키십시오.
- 복잡한 로직, 특정 결정의 근거, 외부 라이브러리 사용법 등 코드 이해에 필요한 부분에는 상세한 구현 주석(`#`)을 추가하십시오.
- **템플릿:**

```elixir
@moduledoc """
[모듈의 역할 및 목적에 대한 간결한 설명]

자동 생성: #{DateTime.utc_now()}
"""

@doc """
[함수/액션의 기능에 대한 설명]

## Parameters
  * `param1`: [파라미터 설명]
  * `changeset`: [Ash Changeset 설명 - 해당 시]

## Returns
  * `{:ok, result}`: [성공 시 반환값 설명]
  * `{:error, reason}`: [실패 시 반환값 설명]

## Examples
    iex> MyModule.function(arg1)
    {:ok, expected_result}
"""
```

## 4. 리소스 정의 표준

### 4.1 기본 구조 (템플릿 준수)

```elixir
defmodule MyApp.DomainName.MyResource do
  use Ash.Resource,
    # 데이터 계층: 명세서 지정 또는 AshPostgres 기본 사용 (규칙)
    data_layer: AshPostgres.DataLayer,
    # 필요한 확장 모듈만 명시 (규칙)
    extensions: [
      # 예: AshStateMachine, AshArchival 등 요구사항 기반 추가
    ]

  # 문서화 (규칙)
  @moduledoc """
  [리소스 설명 - 예: 사용자를 나타내는 리소스]

  자동 생성: #{DateTime.utc_now()}
  """

  # --- 속성, 관계, 액션 등 정의 ---
  # ... (아래 규칙들에 따라 내용 채우기) ...

end
```

### 4.2 속성 정의 (규칙 및 지침)

- **기본 키 (규칙):** `uuid_primary_key :id` 를 사용하십시오.
- **타입 (규칙):** 요구사항의 타입을 Ash 타입(`:string`, `:integer`, `:boolean`, `:utc_datetime_usec`, `:atom`, `:map`, `:decimal` 등)으로 정확히 매핑하십시오. 불명확 시 `:string` 사용 후 주석 명시 및 인간 확인 요청.
- **Null 허용 (규칙):** 요구사항에 '필수' 명시 시 `allow_nil?: false` 설정. 그 외는 기본값(`true`).
- **제약 조건 (규칙):** `constraints: [...]` 를 사용하여 명시된 제약 조건(`max_length`, `one_of`, `format` 등)을 **반드시** 구현하십시오.
- **타임스탬프 (규칙):** `timestamps()` 헬퍼를 사용하십시오 (별도 요구사항 없을 시).
- **민감 데이터 (지침):** 명백히 민감하거나 요구사항에 명시 시 `sensitive?: true` 추가 (`AshCloak` 사용 전제, 7.5절 참조).
- **비공개 속성 (지침):** 내부용 속성은 `private?: true` 설정.

```elixir
# attributes 블록 예시
attributes do
  uuid_primary_key :id # 규칙
  attribute :email, :string, allow_nil?: false, constraints: [format: ~r/@/] # 규칙 (필수, 형식 검증)
  attribute :failed_login_attempts, :integer, default: 0, allow_nil?: false # 지침 (기본값)
  attribute :settings, :map, default: %{} # 지침 (Map 타입)
  attribute :status, :atom, allow_nil?: false, default: :active, constraints: [one_of: [:active, :inactive, :pending]] # 규칙 (Atom 타입, 제약)
  attribute :api_token, :string, private?: true, sensitive?: true # 지침 (비공개, 민감)
  timestamps() # 규칙
end
```

### 4.3 관계 정의 (규칙 및 지침)

- **타입 선택 (규칙):** 요구사항 기반 정확한 관계 타입(`belongs_to`, `has_many`, `has_one`, `many_to_many`) 선택.
- **속성 명명 (규칙):** Ash 기본 명명 규칙(`관계명_id`) 사용. 예외 시 `source_attribute`, `destination_attribute` 명시.
- **Null 허용 (규칙):** `belongs_to` 관계 외래 키 필수 시 `allow_nil? false` 명시.
- **무결성 (`attribute_constraints`) (규칙):** 요구사항의 `on_delete`/`on_update` 정책 구현. 명시 없을 시 `on_delete: :nilify, on_update: :update` 기본 적용 또는 소유 관계 시 `on_delete: :delete_all` 고려 후 주석 명시.

```elixir
# relationships 블록 예시
relationships do
  belongs_to :user, MyApp.Accounts.User do
    allow_nil? false # 규칙 (필수 관계)
    attribute_constraints on_delete: :delete_all # 규칙 (소유 관계 시 일반적)
  end

  has_many :comments, MyApp.Blog.Comment

  many_to_many :tags, MyApp.Blog.Tag, through: MyApp.Blog.PostTag
end
```

### 4.4 계산 및 집계 (지침)

- `calculations`, `aggregates` 블록 내 `expr/1` 로 구현.
- `expr` 로직은 단순하게 유지. 복잡 로직은 서비스 계층으로 분리.

### 4.5 리소스 레벨 설정 (`resource do ... end`) (규칙)

- `AshArchival` 사용 시: `base_filter? true` **반드시** 추가 (7.2절 규칙).
- 기타 필요한 설정(예: `plural_name`, `description`) 추가.

## 5. 액션 구현 패턴

### 5.1 액션 타입 및 명명 (규칙)

- 기본 CRUD는 `defaults [...]` 우선 사용.
- 커스텀 액션은 타입과 명확한 동사 기반 이름(예: `create :register`, `update :approve`) 사용.

### 5.2 입력 처리 (`accept`, `argument`) (규칙)

- 모든 예상 입력 파라미터 명시적 정의. 상세 설정 필요 시 `argument` 사용.

### 5.3 유효성 검사 (`validate`) (규칙)

- 요구사항의 모든 유효성 검사 규칙 구현. 내장 검증자 우선 사용.

### 5.4 변경 로직 (`change`) (규칙)

- 내장 변경자(`set_attribute`, `manage_relationship`, `transition_state` 등) 우선 사용.
- 비밀번호 해싱 필요 시, 적절한 해싱 메커니즘(예: Comeonin 또는 Elixir 내장 기능 활용)을 사용하여 구현하거나 관련 서비스 호출.

### 5.5 복잡 로직 (`manual`) (지침)

- DSL로 구현 불가 시 **제한적** 사용. 코드는 간결하게, 상세 주석 필수. 핵심 로직은 별도 함수/모듈 분리 고려.

### 5.6 훅 (`after_action` 등) (지침)

- 요구사항의 부수 효과는 훅과 별도 훅 모듈로 구현.
- **규칙:** 훅 내 시간 소요/실패 가능 작업은 백그라운드(`AshOban`) 처리.

### 5.7 트랜잭션 (`transactional?`) (규칙)

- `create`, `update`, `destroy` 액션은 기본값 `true` 유지.
- 롤백 불가 작업 포함 시, 명시적 요구사항/인간 지침 하에만 `false` 고려.

## 6. 쿼리 및 데이터 로딩 표준

### 6.1 필터링 (`filter`, `expr/1`) (규칙)

- 동적 필터링은 **반드시** `expr/1` 사용.
- 외부 변수 사용 시 **반드시** `^` (pin operator) 사용.

### 6.2 데이터 로딩 (`load`) (★★ 중요 규칙 ★★)

- 쿼리 결과에서 관계/계산/집계 속성 접근 전, **반드시** `Ash.Query.load/2` 로 명시적 로드.
- N+1 방지를 위해 요구사항/코드 컨텍스트 분석하여 필요한 `load` 결정.

### 6.3 페이지네이션 (규칙)

- 목록 조회 시 요구사항 따라 구현. 기본 `Ash.Query.page/2` 사용. 대규모 데이터 시 `Ash.Query.paginate(:keyset)` 고려 (인간 확인).

### 6.4 필드 선택 (`select`) (지침)

- 성능 최적화 요구사항 명시 시에만 사용. 기본은 전체 필드 로드.

## 7. 확장 모듈 사용 규칙

### 7.1 `AshStateMachine` (상태/전이 필요 시)

- `extensions` 추가, `state_machine` 블록 정의, 전이 액션 구현.

### 7.2 `AshArchival` (논리적 삭제 요구 시)

- `extensions` 추가, `resource do base_filter? true end` **반드시** 설정.
- **규칙:** 기본 사용 시 `:archived_at` 직접 정의 금지.

### 7.3 `AshPaperTrail` (변경 이력 요구 시)

- `extensions` 추가, `paper_trail` 블록 설정 (추적 대상, 액터 등).

### 7.4 `AshOban` (비동기 작업 요구 시)

- `extensions` 추가, `oban_job` 블록 설정 (워커, 큐, 트리거, 인자).

### 7.5 `AshCloak` (필드 암호화 요구 시)

- `extensions` 추가, 속성에 `sensitive?: true` 추가, `encrypted_attributes` 블록 설정 (Vault 지정).
- Vault 설정 확인 (필요시 인간 요청).

## 8. 데이터 계층 및 마이그레이션 절차

### 8.1 데이터 계층 (규칙)

- 지정 없을 시 `AshPostgres.DataLayer` 사용.

### 8.2 마이그레이션 생성 (★★ 필수 절차 ★★)

- 리소스 `attributes`/`relationships` 변경 후 **반드시** `mix ash_postgres.generate_migrations` 실행 및 생성 파일 커밋.

### 8.3 마이그레이션 실행 (규칙)

- 개발/테스트 시 `mix ecto.migrate` 실행.
- 릴리스 프로세스에 마이그레이션 실행 포함 확인.

## 9. 도메인 및 API 생성 표준

### 9.1 도메인 정의 (`Ash.Domain`) (규칙)

- 요구사항에 따라 애플리케이션의 논리적 경계(예: 블로그 관리, 사용자 계정)별로 `Ash.Domain` 모듈을 생성하여 리소스를 구성하고 상호작용을 정의하십시오.
- `use Ash.Domain`으로 시작하며, `resources` 블록 내에 해당 도메인에 속한 리소스나 레지스트리를 명시하십시오.
- 필요한 도메인 레벨 인가 정책 등을 설정할 수 있습니다.

```elixir
defmodule MyApp.Blog do # 파일 경로: lib/my_app/blog/blog.ex
  use Ash.Domain

  # Domain 레벨 설정 (필요시)
  # authorization do ... end

  resources do
    # 해당 도메인에 속한 리소스 등록
    resource MyApp.Blog.Post
    resource MyApp.Blog.Comment
    resource MyApp.Blog.Tag
    resource MyApp.Blog.PostTag # ManyToMany 중간 리소스 포함
    # registry MyApp.BlogRegistry # 레지스트리 사용 가능
  end
end
```

### 9.2 JSON:API (`AshJsonApi`) (규칙)

- RESTful API는 JSON:API 표준을 따르는 `AshJsonApi` 사용을 기본으로 함 (별도 요구사항 없을 시).
- Phoenix `router.ex`에서 `AshJsonApi.Router`로 포워딩하고, `domains:` 옵션에 노출할 `Ash.Domain` 모듈 목록을 지정하십시오.
- `accepts ["json-api"]` 플러그 및 인증/인가 플러그를 파이프라인에 설정하십시오.

```elixir
# lib/my_app_web/router.ex
pipeline :api do
  plug :accepts, ["json-api"]
  # plug MyAppWeb.Plugs.ApiAuth
end

scope "/api/v1" do
  pipe_through :api

  forward "/", AshJsonApi.Router,
    # `apis:` 대신 `domains:` 사용 (Ash 3.x)
    domains: [MyApp.Blog, MyApp.Accounts] # 노출할 Domain 모듈 목록
end
```

## 10. Phoenix 통합 패턴

### 10.1 폼 (`AshPhoenix.Form`) (권장)

- 리소스 기반 웹 폼에 우선 사용.

### 10.2 LiveView (`AshPhoenix.LiveView`) (권장)

- LiveView에서 Ash 데이터 사용 시 헬퍼 우선 사용 (`stream!`, `load` 등 함수 이름 변경 가능성 유의).

### 10.3 컨트롤러 (규칙)

- 이제 `Ash.Domain` 모듈을 통해 액션을 실행합니다 (예: `MyApp.Blog.create(Post, params)`). 또는 리소스 모듈의 액션을 직접 호출할 수도 있습니다 (`MyApp.Blog.Post.create(params)`).
- `{:ok, ...}` / `{:error, ...}` 결과 명시적 처리.

```elixir
# Controller 예시 (Domain 모듈 사용)
def create(conn, %{"post" => post_params}) do
  # actor/tenant 설정 가능
  # conn = Ash.Plug.set_context(conn, %{actor: conn.assigns.current_user})

  # Domain 모듈을 통해 액션 실행
  case MyApp.Blog.create(Post, post_params, context: conn.assigns.context) do
    {:ok, post} ->
      # 성공 처리
    {:error, changeset} ->
      # 실패 처리 (폼 다시 렌더링 등)
  end
end
```

## 11. 테스팅 절차 및 템플릿

### 11.1 테스트 유형 (규칙)

- Resource, Data Layer, Integration 테스트 **반드시** 생성.
- 요구된 커버리지 충족.

### 11.2 리소스 테스트 (DataCase) (템플릿 준수)

```elixir
defmodule MyApp.DomainName.MyResourceTest do
  use MyApp.DataCase # 프로젝트의 DataCase 사용

  alias MyApp.DomainName.MyResource
  alias MyApp.DomainName # Domain 모듈 alias

  setup do
    # 필요한 초기 데이터 생성
    :ok
  end

  describe "Basic CRUD" do
    test "create resource with valid attributes" do
      attrs = %{field1: "value1"}

      # Domain 모듈 통해 액션 실행 (선호) 또는 리소스 모듈 직접 사용
      assert {:ok, resource} = DomainName.create(MyResource, attrs)
      # 또는 assert {:ok, resource} = MyResource.create(attrs)

      # 검증
      assert resource.id != nil
      assert resource.field1 == "value1"
    end

    test "create resource fails with invalid attributes" do
      attrs = %{field1: nil} # 필수 필드 누락

      assert {:error, changeset} = DomainName.create(MyResource, attrs)
      # 또는 assert {:error, changeset} = MyResource.create(attrs)

      # 에러 내용 검증
      assert errors_on(changeset).field1 != nil
    end
    # ... read, update, destroy 테스트 ...
  end

  # ... describe 블록 (Custom Actions, Validations 등) ...
end
```

### 11.3 데이터 계층 테스트 초점

- 트랜잭션 롤백, DB 제약 조건, `on_delete` 동작 검증.

### 11.4 통합 테스트 초점

- API 엔드포인트(Request/Response 검증, Auth 포함), 주요 사용자 플로우 검증.
- 실제 DB 상태 변화 확인.

## 12. 성능 고려사항

다음 성능 규칙을 코드 생성 시 기본적으로 고려해야 합니다.

- **규칙:** N+1 방지를 위해 `Ash.Query.load/2`를 적극적으로 사용하십시오.
- **규칙:** 시간이 오래 걸리는 작업은 `AshOban` 등을 이용해 백그라운드로 처리하십시오.
- **지침:** 대량 데이터 처리가 필요한 경우 배치(chunking) 처리를 구현하십시오.
- **지침:** 쿼리 성능 확보를 위해 필요한 DB 인덱스를 생성하고 확인하십시오 (마이그레이션 절차 참조).

## 13. 코드 템플릿 참조

이 문서의 다음 섹션에서 제시된 기본 구조 및 템플릿을 참조하여 코드를 생성하십시오.

- 리소스 기본 구조: 4.1절
- 리소스 테스트 기본 구조: 11.2절
- 도메인 모듈 기본 구조: 9.1절

## 14. 참조 문서 링크

본 가이드에서 다루지 않거나 해석이 모호한 경우 다음 공식 문서를 참조하되, **본 가이드의 규칙 및 패턴을 우선 적용**하십시오.

- **ash**: https://hexdocs.pm/ash/
- **ash_phoenix**: https://hexdocs.pm/ash_phoenix/
- **ash_json_api**: https://hexdocs.pm/ash_json_api/
- **ash_postgres**: https://hexdocs.pm/ash_postgres/
- **ash_state_machine**: https://hexdocs.pm/ash_state_machine/
- **ash_oban**: https://hexdocs.pm/ash_oban/
- **ash_paper_trail**: https://hexdocs.pm/ash_papertrail/ (Ash 통합)
- **ash_archival**: https://hexdocs.pm/ash_archival/
- **ash_cloak**: https://hexdocs.pm/ash_cloak/
- **ash_money**: https://hexdocs.pm/ash_money/
- **ash_double_entry**: https://hexdocs.pm/ash_double_entry/
- **ash_csv**: https://hexdocs.pm/ash_csv/

---

// File: automata-signal/1-guides/GUIDE-004-coding-standards-new

# [GUIDE-004] 코딩 표준

| 버전 | 날짜       | 변경 내용                                              |
| ---- | ---------- | ------------------------------------------------------ |
| 1.1  | 2025-04-14 | 문서 개선 - 일반/특화 부분 구분, vibe-coding 내용 통합 |
| 1.0  | 2025-04-02 | 최초 문서 작성                                         |

## 요약

본 문서는 Automata-Signal 프로젝트의 코딩 표준과 가이드라인을 정의합니다. 코드의 일관성, 가독성, 유지보수성을 높이기 위한 규칙과 권장사항을 제공합니다. 재사용 가능한 일반 원칙과 프로젝트 특화 표준을 명확히 구분하여 다른 프로젝트에서도 활용할 수 있도록 구성했습니다.

## 대상 독자

- 신규 개발자
- 개발팀

## 1. 일반 코딩 원칙 (재사용 가능)

### 1.1 SOLID 원칙 준수

모든 프로젝트는 다음 SOLID 원칙을 따라야 합니다:

- **S (Single Responsibility)**: 각 모듈은 하나의 책임만 가져야 합니다.
- **O (Open-Closed)**: 코드는 확장에는 열려있고 수정에는 닫혀있어야 합니다.
- **L (Liskov Substitution)**: 하위 타입은 상위 타입을 대체할 수 있어야 합니다.
- **I (Interface Segregation)**: 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 합니다.
- **D (Dependency Inversion)**: 고수준 모듈은 저수준 모듈에 의존하지 않아야 합니다.

### 1.2 코드 품질 원칙

- **단순성**: 항상 복잡한 솔루션보다 단순한 솔루션을 우선시합니다.
- **DRY (Don't Repeat Yourself)**: 코드 중복을 피하고 기존 기능을 재사용합니다.
- **명확성**: 성능 최적화보다 코드 명확성을 우선시합니다.
- **일관성**: 전체 코드베이스에서 일관된 패턴과 관행을 유지합니다.
- **효율성**: 명확성을 희생하지 않으면서 코드를 최적화합니다.
- **파일 크기**: 파일은 간결하게 유지하고, 200-300줄 이내로 하며, 필요에 따라 리팩토링합니다.

### 1.3 일반 문서화 원칙

- **모듈 문서화**: 모든 모듈 상단에는 모듈의 목적과 책임을 간략하게 설명하는 주석을 추가합니다.
- **함수 문서화**: 함수와 메서드에는 다음 정보를 포함하는 주석을 작성합니다:
  - 함수의 목적
  - 매개변수 설명
  - 반환 값 설명
  - 발생 가능한 예외
- **복잡한 로직 설명**: 복잡한 로직이나 알고리즘은 단계별로 주석을 추가하여 설명합니다.
- **비즈니스 규칙 기록**: 코드에 구현된 비즈니스 규칙이나 중요한 결정 사항을 주석으로 기록합니다.
- **성능 고려사항**: 성능에 영향을 미치는 최적화나 특별한 고려사항을 주석으로 설명합니다.
- **임시 해결책 표시**: TODO 주석으로 임시적인 해결책이나 향후 개선이 필요한 부분을 명확히 표시합니다.
- **문서 최신화**: 주석은 코드와 함께 업데이트하여 항상 최신 상태를 유지합니다.

### 1.4 일반 오류 처리 원칙

- **예측 가능한 오류**: 예상되는 오류 상황을 명시적으로 처리합니다.
- **조기 실패**: 오류가 발생하면 가능한 한 빨리 실패하여 문제 전파를 방지합니다.
- **명확한 오류 메시지**: 오류 메시지는 문제와 가능한 해결 방법을 명확히 설명해야 합니다.
- **오류 로깅**: 중요한 오류는 적절한 컨텍스트와 함께 로깅합니다.
- **오류 계층**: 오류는 의미 있는 계층 구조로 구성하여 특정 유형의 오류를 쉽게 포착할 수 있게 합니다.

### 1.5 일반 리팩토링 가이드라인

리팩토링을 고려해야 하는 상황:

- 코드 중복이 발생한 경우
- 함수나 모듈이 너무 커진 경우
- 기능이 추가됨에 따라 기존 설계가 적합하지 않게 된 경우
- 성능 문제가 발생한 경우
- 테스트가 어려워진 경우

리팩토링 절차:

1. 리팩토링 범위와 목표를 명확히 정의
2. 현재 코드의 동작을 테스트로 문서화
3. 리팩토링 계획 문서 작성
4. 작은 단위로 나누어 리팩토링 수행
5. 각 단계마다 테스트 실행

## 2. Elixir 코딩 표준 (언어 특화)

### 2.1 파일 구조

- 파일당 200-300줄을 초과하지 않도록 합니다.
- 파일명은 스네이크 케이스(snake_case)로 작성합니다.
- 모듈 구조는 논리적 계층에 따라 구성합니다.

### 2.2 명명 규칙

- **모듈명**: 파스칼 케이스(PascalCase)를 사용합니다.

  ```elixir
  defmodule AutomataSignal.Adapters.PushAdapter do
  ```

- **함수명**: 스네이크 케이스(snake_case)를 사용합니다.

  ```elixir
  def send_message(message) do
  ```

- **변수명**: 스네이크 케이스(snake_case)를 사용합니다.

  ```elixir
  user_subscription = get_subscription(user_id)
  ```

- **상수**: 대문자 스네이크 케이스(UPPER_SNAKE_CASE)를 사용합니다.

  ```elixir
  @MAX_RETRY_COUNT 5
  ```

- **타입 지정자**: 타입 지정자는 스네이크 케이스(snake_case)를 사용합니다.
  ```elixir
  @type subscription_status :: integer()
  ```

### 2.3 모듈 구조

모듈은 다음 순서로 구성합니다:

1. 모듈 문서화 (필수)
2. `@moduledoc`
3. `use`, `import`, `alias`, `require` 문
4. 모듈 속성 (`@attribute`)
5. 타입 정의 (`@type`, `@typep`)
6. 콜백 정의 (`@callback`)
7. 함수 매크로 (`defmacro`)
8. 공개 함수 (`def`)
9. 비공개 함수 (`defp`)

```elixir
defmodule AutomataSignal.Adapters.PushAdapter do
  @moduledoc """
  푸시 알림 채널 어댑터 모듈.
  iOS(APNS)와 Android(FCM) 플랫폼에 푸시 알림을 전송합니다.
  """

  alias AutomataSignal.Resources.Message
  alias AutomataSignal.Resources.Subscription

  @apns_config %{
    cert: {:file, "path/to/cert.pem"},
    key: {:file, "path/to/key.pem"},
    mode: :prod
  }

  @type push_result :: {:ok, map()} | {:error, map()}

  @callback send_message(message :: Message.t()) :: push_result()

  @impl true
  def send_message(%Message{subscription: subscription} = message) do
    # 구현 내용
  end

  defp format_payload(message) do
    # 내부 구현
  end
end
```

### 2.4 함수 작성 가이드라인

- 함수는 가능한 짧게 유지하고, 하나의 책임만 가져야 합니다.
- 함수 본문은 가급적 8-10줄을 넘지 않도록 합니다.
- 다형성을 활용하여 조건문 대신 함수 패턴 매칭을 사용합니다.
- 파이프 연산자(`|>`)를 사용하여 데이터 변환 과정을 명확히 표현합니다.

```elixir
# 나쁜 예
def process_message(message) do
  msg = validate_message(message)
  if msg != nil do
    msg = transform_message(msg)
    if msg != nil do
      send_message(msg)
    else
      {:error, :transform_failed}
    end
  else
    {:error, :validation_failed}
  end
end

# 좋은 예
def process_message(message) do
  message
  |> validate_message()
  |> transform_message()
  |> send_message()
end

defp validate_message(nil), do: {:error, :validation_failed}
defp validate_message(message), do: {:ok, message}

defp transform_message({:error, reason}), do: {:error, reason}
defp transform_message({:ok, message}), do: {:ok, transform(message)}

defp send_message({:error, reason}), do: {:error, reason}
defp send_message({:ok, message}), do: do_send(message)
```

### 2.5 Elixir 문서화 표준

- 모든 공개 함수는 `@doc` 문서화를 가져야 합니다.
- 복잡한 비공개 함수도 문서화하는 것이 좋습니다.
- 문서화는 함수의 목적, 매개변수, 반환값, 발생 가능한 오류를 설명해야 합니다.
- 예제 코드를 제공하면 더 좋습니다.

````elixir
@doc """
메시지를 적절한 푸시 서비스(APNS 또는 FCM)로 전송합니다.

## 매개변수
  - message: 전송할 메시지 (Message 구조체)

## 반환값
  - {:ok, %{provider_message_id: String.t()}} - 성공적으로 전송된 경우
  - {:error, %{reason: atom(), details: map()}} - 전송 실패 시

## 예제
    ```
    message = %Message{title: "알림 제목", body: "내용", subscription: subscription}
    {:ok, response} = PushAdapter.send_message(message)
    ```
"""
def send_message(%Message{} = message) do
  # 구현 내용
end
````

### 2.6 Elixir 오류 처리 가이드라인

- 오류는 명시적으로 처리하고, 가능한 한 빨리 실패합니다.
- 예외 대신 결과 튜플(`{:ok, result}` 또는 `{:error, reason}`)을 사용합니다.
- 실패 이유를 명확하게 표현합니다.
- 오류 정보는 가능한 한 구체적이어야 합니다.

```elixir
# 나쁜 예
def divide(a, b) do
  a / b
rescue
  _ -> nil
end

# 좋은 예
def divide(_, 0), do: {:error, :division_by_zero}
def divide(a, b), do: {:ok, a / b}
```

## 3. Ash Framework 활용 가이드라인 (프레임워크 특화)

### 3.1 리소스 정의

- 리소스 속성은 논리적 그룹으로 구성합니다.
- 관계는 명확히 정의하고 적절한 참조 무결성 제약조건을 설정합니다.
- 계산된 속성은 `calculations` 블록에 정의합니다.
- 모든 리소스는 자체 파일에 정의합니다.

```elixir
defmodule AutomataSignal.Resources.Message do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [AshStateMachine.Resource]

  attributes do
    uuid_primary_key :id

    # 메시지 내용 관련 속성
    attribute :title, :string
    attribute :body, :string
    attribute :data, :map, default: %{}

    # 관계 식별자
    attribute :user_id, :uuid
    attribute :subscription_id, :uuid
    attribute :application_id, :uuid
    attribute :campaign_id, :uuid, allow_nil?: true

    # 상태 관련 속성
    attribute :status, :atom do
      constraints [one_of: [:pending, :successful, :failed, :errored, :received, :converted]]
      default :pending
    end

    attribute :channel_type, :atom do
      constraints [one_of: [:push, :email, :sms, :kakao_talk, :in_app]]
    end

    # 타임스탬프
    timestamps()
    attribute :sent_at, :utc_datetime
    attribute :received_at, :utc_datetime
    attribute :converted_at, :utc_datetime
    attribute :failed_at, :utc_datetime

    # 오류 관련 속성
    attribute :error_reason, :string
    attribute :error_details, :map, default: %{}
    attribute :version_history, :map, default: %{}
  end

  # ... 상태 머신, 관계, 액션 등 ...
end
```

### 3.2 확장 모듈 활용

각 Ash 확장 모듈을 적절히 활용합니다:

- **ash_state_machine**: 메시지 상태 전이 모델링

  ```elixir
  state_machine do
    field :status
    initial_states [:pending]
    transitions do
      transition :send, from: [:pending], to: :successful
      transition :fail, from: [:pending, :successful], to: :failed
      # ...
    end
  end
  ```

- **ash_oban**: 비동기 작업 처리

  ```elixir
  oban_job do
    queue :messages
    priority 3
    max_attempts 5
    unique [:message_id]
  end
  ```

- **ash_paper_trail**: 변경 이력 추적

  ```elixir
  paper_trail do
    track_attribute :status
    track_attribute :error_details
  end
  ```

- **ash_archival**: 소프트 삭제 처리

  ```elixir
  archival do
    archive_attribute :is_archived
    archive_timestamp_attribute :archived_at
  end
  resource do
    base_filter? true
  end
  ```

- **ash_cloak**: 민감 데이터 암호화
  ```elixir
  encrypted_attributes do
    attribute :token
  end
  ```

### 3.3 액션 및 쿼리 정의

- 읽기 전용 쿼리는 `queries` 블록에 정의합니다.
- 복잡한 업데이트 로직은 `changes` 함수를 사용합니다.
- 액션에는 적절한 인증 및 권한 설정을 포함합니다.

```elixir
actions do
  defaults [:create, :read, :update, :destroy]

  create :send do
    accept [:title, :body, :data, :subscription_id]
    change set_attribute(:status, :pending)
    change relate_actor(:application)
  end

  update :mark_as_sent do
    accept []
    change transition_state(:send)
    change set_attribute(:sent_at, &DateTime.utc_now/0)
  end
end

queries do
  query :by_user, :all do
    filter expr(user_id == ^arg(:user_id))
  end

  query :pending_messages, :all do
    filter expr(status == :pending)
  end
end
```

### 3.4 데이터 로딩 및 관계 처리

- **명시적 로딩**: 관계, 계산된 속성, 집계는 `Ash.Query.load/2`로 명시적으로 로드합니다.
- **N+1 방지**: 관계를 통한 데이터 접근 시 N+1 쿼리 문제를 방지하기 위해 사전 로딩을 사용합니다.
- **필드 선택**: 필요한 필드만 `select`로 지정하여 성능을 최적화합니다.

```elixir
def get_message_with_related_data(id) do
  Message
  |> Ash.Query.filter(id == ^id)
  |> Ash.Query.load([:user, :subscription])
  |> Ash.Query.load([:read_status])
  |> Ash.Query.select([:title, :body, :status])
  |> Automata.Signal.read_one()
end
```

## 4. Flutter SDK 코딩 표준 (프로젝트 특화)

### 4.1 파일 구조

- 파일은 논리적 계층에 따라 구성합니다.
- 파일 이름은 스네이크 케이스(snake_case)를 사용합니다.
- 각 클래스는 자체 파일에 정의합니다.

```
lib/
  src/
    core/           # 핵심 기능 및 유틸리티
    managers/       # 기능별 관리자 클래스
    models/         # 데이터 모델
    network/        # API 통신 관련
    utils/          # 유틸리티 함수
  automata_signal.dart  # 메인 SDK 진입점
```

### 4.2 명명 규칙

- **클래스명**: 파스칼 케이스(PascalCase)를 사용합니다.

  ```dart
  class SubscriptionManager { ... }
  ```

- **변수/메소드명**: 카멜 케이스(camelCase)를 사용합니다.

  ```dart
  String deviceToken;
  Future<void> registerPushSubscription() { ... }
  ```

- **상수**: 대문자 스네이크 케이스(UPPER_SNAKE_CASE)를 사용합니다.

  ```dart
  const int MAX_RETRY_COUNT = 5;
  ```

- **프라이빗 멤버**: 언더스코어(\_)로 시작합니다.
  ```dart
  String _apiKey;
  void _initialize() { ... }
  ```

### 4.3 클래스 구조

클래스는 다음 순서로 구성합니다:

1. 상수 및 정적 변수
2. 인스턴스 변수
3. 생성자
4. 팩토리 생성자
5. 게터/세터
6. 공개 메소드
7. 비공개 메소드

```dart
class SubscriptionManager {
  // 상수 및 정적 변수
  static const int MAX_RETRIES = 3;

  // 인스턴스 변수
  final String _appId;
  Map<String, String> _subscriptionIds = {};

  // 생성자
  SubscriptionManager(this._appId);

  // 팩토리 생성자
  factory SubscriptionManager.fromConfig(AutomataSignalConfig config) {
    return SubscriptionManager(config.appId);
  }

  // 게터/세터
  Map<String, String> get subscriptionIds => _subscriptionIds;

  // 공개 메소드
  Future<String?> registerPushSubscription() async {
    // 구현
  }

  // 비공개 메소드
  Future<Map<String, dynamic>> _collectDeviceInfo() async {
    // 구현
  }
}
```

### 4.4 비동기 코드 가이드라인

- `async`/`await`를 사용하여 비동기 코드를 작성합니다.
- 모든 예외는 적절히 처리합니다.
- 오류 전파가 필요한 경우 명시적으로 예외를 다시 던집니다.

```dart
// 좋은 예
Future<void> initialize() async {
  try {
    await _loadPreferences();
    await _registerDeviceToken();
    await _restoreUser();
  } catch (e) {
    _logger.error('Initialization failed: $e');
    rethrow; // 상위 레벨에서 처리하도록 다시 던짐
  }
}
```

### 4.5 Flutter 문서화 표준

- 모든 공개 클래스 및 메소드는 문서 주석을 가져야 합니다.
- 문서 주석은 메소드의 목적, 매개변수, 반환값, 발생 가능한 예외를 설명해야 합니다.

```dart
/// 푸시 알림 구독을 등록합니다.
///
/// 기기의 푸시 토큰을 서버에 등록하고 구독 ID를 반환합니다.
/// 이미 등록된 경우 기존 구독 ID를 반환합니다.
///
/// 반환값: 등록된 구독 ID 또는 오류 발생 시 null
///
/// 예외:
/// - [NetworkException]: 서버 연결 실패 시
/// - [InvalidTokenException]: 유효하지 않은 토큰일 경우
Future<String?> registerPushSubscription() async {
  // 구현
}
```

## 5. API 설계 가이드라인 (재사용 가능)

### 5.1 RESTful API 디자인

- 리소스 중심으로 API를 설계합니다.
- HTTP 메소드를 적절히 활용합니다 (GET, POST, PUT, DELETE).
- URL은 명사를 사용하고, 동사는 피합니다.
- 복수형 명사를 사용합니다 (/messages, /subscriptions).

### 5.2 API 경로 규칙

```
# 기본 경로
/api/v1/applications
/api/v1/users
/api/v1/subscriptions
/api/v1/messages
/api/v1/templates
/api/v1/campaigns

# 중첩 리소스
/api/v1/applications/:id/subscriptions
/api/v1/users/:id/subscriptions
/api/v1/campaigns/:id/messages
```

### 5.3 요청/응답 형식

- 모든 요청 및 응답 본문은 JSON 형식을 사용합니다.
- 응답에는 일관된 구조를 사용합니다.

```json
// 성공 응답
{
  "status": "success",
  "data": {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "title": "알림 제목",
    "body": "알림 내용"
  }
}

// 오류 응답
{
  "status": "error",
  "error": {
    "code": "invalid_token",
    "message": "유효하지 않은 토큰입니다.",
    "details": { ... }
  }
}
```

### 5.4 상태 코드 사용

- **200 OK**: 성공적인 요청
- **201 Created**: 리소스 생성 성공
- **400 Bad Request**: 클라이언트 오류
- **401 Unauthorized**: 인증 필요
- **403 Forbidden**: 권한 없음
- **404 Not Found**: 리소스 없음
- **429 Too Many Requests**: 요청 제한 초과
- **500 Internal Server Error**: 서버 오류

## 6. 성능 최적화 가이드라인 (재사용 가능)

### 6.1 데이터베이스 최적화

- 적절한 인덱스를 사용합니다.
- 대량 쿼리는 배치 작업으로 처리합니다.
- 트랜잭션을 적절히 사용합니다.
- 데이터베이스 연결 풀을 효율적으로 관리합니다.

```elixir
# 배치 삽입 예시
def create_campaign_messages(campaign, subscriptions) do
  subscriptions
  |> Enum.chunk_every(500)  # 500개씩 배치 처리
  |> Enum.each(fn batch ->
    Ash.transaction(fn ->
      Enum.map(batch, fn subscription ->
        create_message_for_subscription(campaign, subscription)
      end)
    end)
  end)
end
```

### 6.2 메모리 관리

- 대량의 데이터는 스트림으로 처리합니다.
- 불필요한 데이터 복사를 피합니다.
- 자원 사용량을 모니터링합니다.

```elixir
# 스트림 처리 예시
defmodule AutomataSignal.Services.CampaignService do
  def process_large_campaign(campaign) do
    AutomataSignal.Repo.stream(
      from(s in Subscription, where: s.application_id == ^campaign.application_id)
    )
    |> Stream.chunk_every(1000)
    |> Stream.each(fn subscriptions ->
      create_messages_for_subscriptions(campaign, subscriptions)
    end)
    |> Stream.run()
  end
end
```

### 6.3 네트워크 최적화

- 요청/응답 페이로드를 최소화합니다.
- 적절한 캐싱을 사용합니다.
- 연결 풀링을 구현합니다.
- 비율 제한을 적용합니다.

## 7. 테스트 코딩 표준 (재사용 가능)

### 7.1 테스트 파일 구조

- 테스트 파일은 테스트 대상 모듈 구조를 반영합니다.
- 파일 이름은 `[module_name]_test.exs` 형식을 사용합니다.

```
test/
  automata_signal/
    resources/
      message_test.exs
      subscription_test.exs
    services/
      message_service_test.exs
    adapters/
      push_adapter_test.exs
```

### 7.2 테스트 그룹화

- `describe` 블록을 사용하여 관련 테스트를 그룹화합니다.
- 테스트 이름은 명확하고 설명적이어야 합니다.

```elixir
defmodule AutomataSignal.Adapters.PushAdapterTest do
  use AutomataSignal.DataCase
  alias AutomataSignal.Adapters.PushAdapter

  describe "send_message/1" do
    test "successfully sends iOS push notification" do
      # 테스트 내용
    end

    test "successfully sends Android push notification" do
      # 테스트 내용
    end

    test "returns error for invalid token" do
      # 테스트 내용
    end
  end

  describe "map_error/1" do
    test "maps APNS errors correctly" do
      # 테스트 내용
    end

    test "maps FCM errors correctly" do
      # 테스트 내용
    end
  end
end
```

### 7.3 테스트 데이터 설정

- 각 테스트에 필요한 데이터만 설정합니다.
- 공통 설정은 `setup` 블록을 사용합니다.
- 팩토리 패턴을 사용하여 테스트 데이터를 생성합니다.

```elixir
defmodule AutomataSignal.Factory do
  def build(:message) do
    %{
      title: "Test Title",
      body: "Test Body",
      data: %{},
      status: :pending,
      channel_type: :push
    }
  end

  def build(:subscription) do
    %{
      token: "test_token",
      type: :iOSPush,
      subscription_status: 1
    }
  end

  # 팩토리 헬퍼 함수
  def build(factory_name, attrs) do
    factory_name
    |> build()
    |> Map.merge(attrs)
  end
end

# 테스트에서 사용
test "successfully sends iOS push notification" do
  subscription = Factory.build(:subscription, type: :iOSPush)
  message = Factory.build(:message, subscription: subscription)

  assert {:ok, _response} = PushAdapter.send_message(message)
end
```

### 7.4 모의 객체 및 스텁

- `mox` 라이브러리를 사용하여 외부 의존성을 모킹합니다.
- 테스트 헬퍼 모듈을 사용하여 반복적인 모킹 코드를 추상화합니다.

```elixir
# 모킹 설정
defmodule AutomataSignal.MockAPNS do
  @behaviour AutomataSignal.APNS.Behaviour

  def push(notification, _config) do
    send(self(), {:apns_push, notification})
    {:ok, %{id: "mock_id"}}
  end
end

# 테스트에서 사용
test "sends notification to APNS" do
  subscription = Factory.build(:subscription, type: :iOSPush)
  message = Factory.build(:message, subscription: subscription)

  PushAdapter.send_message(message)

  assert_received {:apns_push, notification}
  assert notification.token == subscription.token
  assert notification.notification.title == message.title
end
```

## 8. 코드 리뷰 체크리스트 (재사용 가능)

코드 리뷰 시 다음 사항을 확인합니다:

### 8.1 일반 사항

- [ ] 코드가 기능 요구사항을 충족하는가?
- [ ] 코드가 이해하기 쉬운가?
- [ ] 변수 및 함수 이름이 의미 있는가?
- [ ] 주석이 명확하고 필요한 곳에 있는가?
- [ ] 중복 코드가 없는가?

### 8.2 성능 및 보안

- [ ] 데이터베이스 쿼리가 최적화되어 있는가?
- [ ] 리소스 사용이 효율적인가?
- [ ] 민감한 데이터가 적절히 암호화되어 있는가?
- [ ] 입력 데이터가 적절히 검증되는가?
- [ ] 오류 처리가 적절한가?

### 8.3 테스트

- [ ] 테스트 코드가 있는가?
- [ ] 테스트가 모든 중요한 경로를 커버하는가?
- [ ] 테스트가 이해하기 쉬운가?
- [ ] 테스트가 안정적으로 실행되는가?

### 8.4 문서화

- [ ] 필요한 모든 함수와 모듈이 문서화되어 있는가?
- [ ] 문서가 명확하고 정확한가?
- [ ] 복잡한 로직이 문서화되어 있는가?

## 9. 코드 품질 도구 (프로젝트 특화)

### 9.1 정적 분석 도구

프로젝트에서는 다음과 같은 코드 품질 도구를 사용합니다:

- **Credo**: Elixir 코드 스타일 및 일관성 검사
- **Dialyxir**: 타입 검사
- **Sobelow**: 보안 취약점 분석
- **ExCoveralls**: 테스트 커버리지 측정 및 보고
- **dart_code_metrics**: Flutter/Dart 코드 품질 검사

### 9.2 설정 방법

다음과 같이 `mix.exs` 파일에 설정합니다:

```elixir
defp deps do
  [
    {:credo, "~> 1.6", only: [:dev, :test], runtime: false},
    {:dialyxir, "~> 1.2", only: [:dev, :test], runtime: false},
    {:sobelow, "~> 0.11", only: [:dev, :test], runtime: false},
    {:excoveralls, "~> 0.14", only: :test},
    # ... 기타 의존성
  ]
end

def project do
  [
    # ... 기타 설정
    test_coverage: [tool: ExCoveralls],
    preferred_cli_env: [
      coveralls: :test,
      "coveralls.detail": :test,
      "coveralls.post": :test,
      "coveralls.html": :test,
      "coveralls.github": :test
    ]
  ]
end
```

### 9.3 CI 통합

코드 품질 도구는 로컬 개발 환경뿐만 아니라 CI 환경에서도 자동으로 실행되어야 합니다. 지속적 통합을 통해 모든 변경사항에 대해 품질 검사를 수행합니다:

- 코드 형식 검사: `mix format --check-formatted`
- 코드 스타일 및 일관성 검사: `mix credo --strict`
- 타입 검사: `mix dialyxir`
- 보안 취약점 분석: `mix sobelow --config`
- 테스트 커버리지 측정: `mix coveralls.github`

CI/CD 파이프라인 설정에 대한 자세한 내용은 [GUIDE-005] 배포 워크플로우 문서를 참조하세요.

---

// File: automata-signal/1-guides/GUIDE-004-coding-standards

# [GUIDE-004] 코딩 표준

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 요약

본 문서는 Automata-Signal 프로젝트의 코딩 표준과 가이드라인을 정의합니다. 코드의 일관성, 가독성, 유지보수성을 높이기 위한 규칙과 권장사항을 제공합니다.

## 대상 독자

- 신규 개발자
- 개발팀

## 1. 일반 원칙

### 1.1 SOLID 원칙 준수

Automata-Signal은 다음 SOLID 원칙을 따릅니다:

- **S (Single Responsibility)**: 각 모듈은 하나의 책임만 가져야 합니다.
- **O (Open-Closed)**: 코드는 확장에는 열려있고 수정에는 닫혀있어야 합니다.
- **L (Liskov Substitution)**: 하위 타입은 상위 타입을 대체할 수 있어야 합니다.
- **I (Interface Segregation)**: 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 합니다.
- **D (Dependency Inversion)**: 고수준 모듈은 저수준 모듈에 의존하지 않아야 합니다.

### 1.2 코드 품질 원칙

- **단순성**: 항상 복잡한 솔루션보다 단순한 솔루션을 우선시합니다.
- **DRY (Don't Repeat Yourself)**: 코드 중복을 피하고 기존 기능을 재사용합니다.
- **명확성**: 성능 최적화보다 코드 명확성을 우선시합니다.
- **일관성**: 전체 코드베이스에서 일관된 패턴과 관행을 유지합니다.

### 1.3 문서화 원칙

- 모든 모듈, 함수, 프로토콜에는 문서 주석을 작성해야 합니다.
- 복잡한 로직이나 비즈니스 규칙은 주석으로 설명해야 합니다.
- 문서화는 코드와 함께 업데이트되어야 합니다.

## 2. Elixir 코딩 표준

### 2.1 파일 구조

- 파일당 200-300줄을 초과하지 않도록 합니다.
- 파일명은 스네이크 케이스(snake_case)로 작성합니다.
- 모듈 구조는 논리적 계층에 따라 구성합니다.

```elixir
# 권장 디렉토리 구조
lib/
  automata_signal/
    resources/       # Ash 리소스 정의
    services/        # 비즈니스 로직
    workers/         # 비동기 작업자
    adapters/        # 채널 어댑터
    templates/       # 템플릿 엔진
    campaigns/       # 캠페인 관리
  automata_signal_web/
    controllers/     # API 컨트롤러
    views/           # 응답 포맷팅
```

### 2.2 명명 규칙

- **모듈명**: 파스칼 케이스(PascalCase)를 사용합니다.

  ```elixir
  defmodule AutomataSignal.Adapters.PushAdapter do
  ```

- **함수명**: 스네이크 케이스(snake_case)를 사용합니다.

  ```elixir
  def send_message(message) do
  ```

- **변수명**: 스네이크 케이스(snake_case)를 사용합니다.

  ```elixir
  user_subscription = get_subscription(user_id)
  ```

- **상수**: 대문자 스네이크 케이스(UPPER_SNAKE_CASE)를 사용합니다.

  ```elixir
  @MAX_RETRY_COUNT 5
  ```

- **타입 지정자**: 타입 지정자는 스네이크 케이스(snake_case)를 사용합니다.
  ```elixir
  @type subscription_status :: integer()
  ```

### 2.3 모듈 구조

모듈은 다음 순서로 구성합니다:

1. 모듈 문서화 (필수)
2. `@moduledoc`
3. `use`, `import`, `alias`, `require` 문
4. 모듈 속성 (`@attribute`)
5. 타입 정의 (`@type`, `@typep`)
6. 콜백 정의 (`@callback`)
7. 함수 매크로 (`defmacro`)
8. 공개 함수 (`def`)
9. 비공개 함수 (`defp`)

```elixir
defmodule AutomataSignal.Adapters.PushAdapter do
  @moduledoc """
  푸시 알림 채널 어댑터 모듈.
  iOS(APNS)와 Android(FCM) 플랫폼에 푸시 알림을 전송합니다.
  """

  alias AutomataSignal.Resources.Message
  alias AutomataSignal.Resources.Subscription

  @apns_config %{
    cert: {:file, "path/to/cert.pem"},
    key: {:file, "path/to/key.pem"},
    mode: :prod
  }

  @type push_result :: {:ok, map()} | {:error, map()}

  @callback send_message(message :: Message.t()) :: push_result()

  @impl true
  def send_message(%Message{subscription: subscription} = message) do
    # 구현 내용
  end

  defp format_payload(message) do
    # 내부 구현
  end
end
```

### 2.4 함수 작성 가이드라인

- 함수는 가능한 짧게 유지하고, 하나의 책임만 가져야 합니다.
- 함수 본문은 가급적 8-10줄을 넘지 않도록 합니다.
- 다형성을 활용하여 조건문 대신 함수 패턴 매칭을 사용합니다.
- 파이프 연산자(`|>`)를 사용하여 데이터 변환 과정을 명확히 표현합니다.

```elixir
# 나쁜 예
def process_message(message) do
  msg = validate_message(message)
  if msg != nil do
    msg = transform_message(msg)
    if msg != nil do
      send_message(msg)
    else
      {:error, :transform_failed}
    end
  else
    {:error, :validation_failed}
  end
end

# 좋은 예
def process_message(message) do
  message
  |> validate_message()
  |> transform_message()
  |> send_message()
end

defp validate_message(nil), do: {:error, :validation_failed}
defp validate_message(message), do: {:ok, message}

defp transform_message({:error, reason}), do: {:error, reason}
defp transform_message({:ok, message}), do: {:ok, transform(message)}

defp send_message({:error, reason}), do: {:error, reason}
defp send_message({:ok, message}), do: do_send(message)
```

### 2.5 문서화 표준

- 모든 공개 함수는 `@doc` 문서화를 가져야 합니다.
- 복잡한 비공개 함수도 문서화하는 것이 좋습니다.
- 문서화는 함수의 목적, 매개변수, 반환값, 발생 가능한 오류를 설명해야 합니다.
- 예제 코드를 제공하면 더 좋습니다.

````elixir
@doc """
메시지를 적절한 푸시 서비스(APNS 또는 FCM)로 전송합니다.

## 매개변수
  - message: 전송할 메시지 (Message 구조체)

## 반환값
  - {:ok, %{provider_message_id: String.t()}} - 성공적으로 전송된 경우
  - {:error, %{reason: atom(), details: map()}} - 전송 실패 시

## 예제
    ```
    message = %Message{title: "알림 제목", body: "내용", subscription: subscription}
    {:ok, response} = PushAdapter.send_message(message)
    ```
"""
def send_message(%Message{} = message) do
  # 구현 내용
end
````

### 2.6 오류 처리 가이드라인

- 오류는 명시적으로 처리하고, 가능한 한 빨리 실패합니다.
- 예외 대신 결과 튜플(`{:ok, result}` 또는 `{:error, reason}`)을 사용합니다.
- 실패 이유를 명확하게 표현합니다.
- 오류 정보는 가능한 한 구체적이어야 합니다.

```elixir
# 나쁜 예
def divide(a, b) do
  a / b
rescue
  _ -> nil
end

# 좋은 예
def divide(_, 0), do: {:error, :division_by_zero}
def divide(a, b), do: {:ok, a / b}
```

## 3. Ash Framework 활용 가이드라인

### 3.1 리소스 정의

- 리소스 속성은 논리적 그룹으로 구성합니다.
- 관계는 명확히 정의하고 적절한 참조 무결성 제약조건을 설정합니다.
- 계산된 속성은 `calculations` 블록에 정의합니다.
- 모든 리소스는 자체 파일에 정의합니다.

```elixir
defmodule AutomataSignal.Resources.Message do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [AshStateMachine.Resource]

  attributes do
    uuid_primary_key :id

    # 메시지 내용 관련 속성
    attribute :title, :string
    attribute :body, :string
    attribute :data, :map, default: %{}

    # 관계 식별자
    attribute :user_id, :uuid
    attribute :subscription_id, :uuid
    attribute :application_id, :uuid
    attribute :campaign_id, :uuid, allow_nil?: true

    # 상태 관련 속성
    attribute :status, :atom do
      constraints [one_of: [:pending, :successful, :failed, :errored, :received, :converted]]
      default :pending
    end

    attribute :channel_type, :atom do
      constraints [one_of: [:push, :email, :sms, :kakao_talk, :in_app]]
    end

    # 타임스탬프
    timestamps()
    attribute :sent_at, :utc_datetime
    attribute :received_at, :utc_datetime
    attribute :converted_at, :utc_datetime
    attribute :failed_at, :utc_datetime

    # 오류 관련 속성
    attribute :error_reason, :string
    attribute :error_details, :map, default: %{}
    attribute :version_history, :map, default: %{}
  end

  # ... 상태 머신, 관계, 액션 등 ...
end
```

### 3.2 확장 모듈 활용

각 Ash 확장 모듈을 적절히 활용합니다:

- **ash_state_machine**: 메시지 상태 전이 모델링

  ```elixir
  state_machine do
    field :status
    initial_states [:pending]
    transitions do
      transition :send, from: [:pending], to: :successful
      transition :fail, from: [:pending, :successful], to: :failed
      # ...
    end
  end
  ```

- **ash_oban**: 비동기 작업 처리

  ```elixir
  oban_job do
    queue :messages
    priority 3
    max_attempts 5
    unique [:message_id]
  end
  ```

- **ash_paper_trail**: 변경 이력 추적

  ```elixir
  paper_trail do
    track_attribute :status
    track_attribute :error_details
  end
  ```

- **ash_archival**: 소프트 삭제 처리

  ```elixir
  archival do
    archive_attribute :is_archived
    archive_timestamp_attribute :archived_at
  end
  ```

- **ash_cloak**: 민감 데이터 암호화
  ```elixir
  encrypted_attributes do
    attribute :token
  end
  ```

### 3.3 액션 및 쿼리 정의

- 읽기 전용 쿼리는 `queries` 블록에 정의합니다.
- 복잡한 업데이트 로직은 `changes` 함수를 사용합니다.
- 액션에는 적절한 인증 및 권한 설정을 포함합니다.

```elixir
actions do
  defaults [:create, :read, :update, :destroy]

  create :send do
    accept [:title, :body, :data, :subscription_id]
    change set_attribute(:status, :pending)
    change relate_actor(:application)
  end

  update :mark_as_sent do
    accept []
    change transition_state(:send)
    change set_attribute(:sent_at, &DateTime.utc_now/0)
  end
end

queries do
  query :by_user, :all do
    filter expr(user_id == ^arg(:user_id))
  end

  query :pending_messages, :all do
    filter expr(status == :pending)
  end
end
```

## 4. Flutter SDK 코딩 표준

### 4.1 파일 구조

- 파일은 논리적 계층에 따라 구성합니다.
- 파일 이름은 스네이크 케이스(snake_case)를 사용합니다.
- 각 클래스는 자체 파일에 정의합니다.

```
lib/
  src/
    core/           # 핵심 기능 및 유틸리티
    managers/       # 기능별 관리자 클래스
    models/         # 데이터 모델
    network/        # API 통신 관련
    utils/          # 유틸리티 함수
  automata_signal.dart  # 메인 SDK 진입점
```

### 4.2 명명 규칙

- **클래스명**: 파스칼 케이스(PascalCase)를 사용합니다.

  ```dart
  class SubscriptionManager { ... }
  ```

- **변수/메소드명**: 카멜 케이스(camelCase)를 사용합니다.

  ```dart
  String deviceToken;
  Future<void> registerPushSubscription() { ... }
  ```

- **상수**: 대문자 스네이크 케이스(UPPER_SNAKE_CASE)를 사용합니다.

  ```dart
  const int MAX_RETRY_COUNT = 5;
  ```

- **프라이빗 멤버**: 언더스코어(\_)로 시작합니다.
  ```dart
  String _apiKey;
  void _initialize() { ... }
  ```

### 4.3 클래스 구조

클래스는 다음 순서로 구성합니다:

1. 상수 및 정적 변수
2. 인스턴스 변수
3. 생성자
4. 팩토리 생성자
5. 게터/세터
6. 공개 메소드
7. 비공개 메소드

```dart
class SubscriptionManager {
  // 상수 및 정적 변수
  static const int MAX_RETRIES = 3;

  // 인스턴스 변수
  final String _appId;
  Map<String, String> _subscriptionIds = {};

  // 생성자
  SubscriptionManager(this._appId);

  // 팩토리 생성자
  factory SubscriptionManager.fromConfig(AutomataSignalConfig config) {
    return SubscriptionManager(config.appId);
  }

  // 게터/세터
  Map<String, String> get subscriptionIds => _subscriptionIds;

  // 공개 메소드
  Future<String?> registerPushSubscription() async {
    // 구현
  }

  // 비공개 메소드
  Future<Map<String, dynamic>> _collectDeviceInfo() async {
    // 구현
  }
}
```

### 4.4 비동기 코드 가이드라인

- `async`/`await`를 사용하여 비동기 코드를 작성합니다.
- 모든 예외는 적절히 처리합니다.
- 오류 전파가 필요한 경우 명시적으로 예외를 다시 던집니다.

```dart
// 좋은 예
Future<void> initialize() async {
  try {
    await _loadPreferences();
    await _registerDeviceToken();
    await _restoreUser();
  } catch (e) {
    _logger.error('Initialization failed: $e');
    rethrow; // 상위 레벨에서 처리하도록 다시 던짐
  }
}
```

### 4.5 문서화 표준

- 모든 공개 클래스 및 메소드는 문서 주석을 가져야 합니다.
- 문서 주석은 메소드의 목적, 매개변수, 반환값, 발생 가능한 예외를 설명해야 합니다.

```dart
/// 푸시 알림 구독을 등록합니다.
///
/// 기기의 푸시 토큰을 서버에 등록하고 구독 ID를 반환합니다.
/// 이미 등록된 경우 기존 구독 ID를 반환합니다.
///
/// 반환값: 등록된 구독 ID 또는 오류 발생 시 null
///
/// 예외:
/// - [NetworkException]: 서버 연결 실패 시
/// - [InvalidTokenException]: 유효하지 않은 토큰일 경우
Future<String?> registerPushSubscription() async {
  // 구현
}
```

## 5. API 설계 가이드라인

### 5.1 RESTful API 디자인

- 리소스 중심으로 API를 설계합니다.
- HTTP 메소드를 적절히 활용합니다 (GET, POST, PUT, DELETE).
- URL은 명사를 사용하고, 동사는 피합니다.
- 복수형 명사를 사용합니다 (/messages, /subscriptions).

### 5.2 API 경로 규칙

```
# 기본 경로
/api/v1/applications
/api/v1/users
/api/v1/subscriptions
/api/v1/messages
/api/v1/templates
/api/v1/campaigns

# 중첩 리소스
/api/v1/applications/:id/subscriptions
/api/v1/users/:id/subscriptions
/api/v1/campaigns/:id/messages
```

### 5.3 요청/응답 형식

- 모든 요청 및 응답 본문은 JSON 형식을 사용합니다.
- 응답에는 일관된 구조를 사용합니다.

```json
// 성공 응답
{
  "status": "success",
  "data": {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "title": "알림 제목",
    "body": "알림 내용"
  }
}

// 오류 응답
{
  "status": "error",
  "error": {
    "code": "invalid_token",
    "message": "유효하지 않은 토큰입니다.",
    "details": { ... }
  }
}
```

### 5.4 상태 코드 사용

- **200 OK**: 성공적인 요청
- **201 Created**: 리소스 생성 성공
- **400 Bad Request**: 클라이언트 오류
- **401 Unauthorized**: 인증 필요
- **403 Forbidden**: 권한 없음
- **404 Not Found**: 리소스 없음
- **429 Too Many Requests**: 요청 제한 초과
- **500 Internal Server Error**: 서버 오류

## 6. 성능 최적화 가이드라인

### 6.1 데이터베이스 최적화

- 적절한 인덱스를 사용합니다.
- 대량 쿼리는 배치 작업으로 처리합니다.
- 트랜잭션을 적절히 사용합니다.
- 데이터베이스 연결 풀을 효율적으로 관리합니다.

```elixir
# 배치 삽입 예시
def create_campaign_messages(campaign, subscriptions) do
  subscriptions
  |> Enum.chunk_every(500)  # 500개씩 배치 처리
  |> Enum.each(fn batch ->
    Ash.transaction(fn ->
      Enum.map(batch, fn subscription ->
        create_message_for_subscription(campaign, subscription)
      end)
    end)
  end)
end
```

### 6.2 메모리 관리

- 대량의 데이터는 스트림으로 처리합니다.
- 불필요한 데이터 복사를 피합니다.
- 자원 사용량을 모니터링합니다.

```elixir
# 스트림 처리 예시
defmodule AutomataSignal.Services.CampaignService do
  def process_large_campaign(campaign) do
    AutomataSignal.Repo.stream(
      from(s in Subscription, where: s.application_id == ^campaign.application_id)
    )
    |> Stream.chunk_every(1000)
    |> Stream.each(fn subscriptions ->
      create_messages_for_subscriptions(campaign, subscriptions)
    end)
    |> Stream.run()
  end
end
```

### 6.3 네트워크 최적화

- 요청/응답 페이로드를 최소화합니다.
- 적절한 캐싱을 사용합니다.
- 연결 풀링을 구현합니다.
- 비율 제한을 적용합니다.

## 7. 테스트 코딩 표준

### 7.1 테스트 파일 구조

- 테스트 파일은 테스트 대상 모듈 구조를 반영합니다.
- 파일 이름은 `[module_name]_test.exs` 형식을 사용합니다.

```
test/
  automata_signal/
    resources/
      message_test.exs
      subscription_test.exs
    services/
      message_service_test.exs
    adapters/
      push_adapter_test.exs
```

### 7.2 테스트 그룹화

- `describe` 블록을 사용하여 관련 테스트를 그룹화합니다.
- 테스트 이름은 명확하고 설명적이어야 합니다.

```elixir
defmodule AutomataSignal.Adapters.PushAdapterTest do
  use AutomataSignal.DataCase
  alias AutomataSignal.Adapters.PushAdapter

  describe "send_message/1" do
    test "successfully sends iOS push notification" do
      # 테스트 내용
    end

    test "successfully sends Android push notification" do
      # 테스트 내용
    end

    test "returns error for invalid token" do
      # 테스트 내용
    end
  end

  describe "map_error/1" do
    test "maps APNS errors correctly" do
      # 테스트 내용
    end

    test "maps FCM errors correctly" do
      # 테스트 내용
    end
  end
end
```

### 7.3 테스트 데이터 설정

- 각 테스트에 필요한 데이터만 설정합니다.
- 공통 설정은 `setup` 블록을 사용합니다.
- 팩토리 패턴을 사용하여 테스트 데이터를 생성합니다.

```elixir
defmodule AutomataSignal.Factory do
  def build(:message) do
    %{
      title: "Test Title",
      body: "Test Body",
      data: %{},
      status: :pending,
      channel_type: :push
    }
  end

  def build(:subscription) do
    %{
      token: "test_token",
      type: :iOSPush,
      subscription_status: 1
    }
  end

  # 팩토리 헬퍼 함수
  def build(factory_name, attrs) do
    factory_name
    |> build()
    |> Map.merge(attrs)
  end
end

# 테스트에서 사용
test "successfully sends iOS push notification" do
  subscription = Factory.build(:subscription, type: :iOSPush)
  message = Factory.build(:message, subscription: subscription)

  assert {:ok, _response} = PushAdapter.send_message(message)
end
```

### 7.4 모의 객체 및 스텁

- `mox` 라이브러리를 사용하여 외부 의존성을 모킹합니다.
- 테스트 헬퍼 모듈을 사용하여 반복적인 모킹 코드를 추상화합니다.

```elixir
# 모킹 설정
defmodule AutomataSignal.MockAPNS do
  @behaviour AutomataSignal.APNS.Behaviour

  def push(notification, _config) do
    send(self(), {:apns_push, notification})
    {:ok, %{id: "mock_id"}}
  end
end

# 테스트에서 사용
test "sends notification to APNS" do
  subscription = Factory.build(:subscription, type: :iOSPush)
  message = Factory.build(:message, subscription: subscription)

  PushAdapter.send_message(message)

  assert_received {:apns_push, notification}
  assert notification.token == subscription.token
  assert notification.notification.title == message.title
end
```

## 8. 코드 리뷰 체크리스트

코드 리뷰 시 다음 사항을 확인합니다:

### 8.1 일반 사항

- [ ] 코드가 기능 요구사항을 충족하는가?
- [ ] 코드가 이해하기 쉬운가?
- [ ] 변수 및 함수 이름이 의미 있는가?
- [ ] 주석이 명확하고 필요한 곳에 있는가?
- [ ] 중복 코드가 없는가?

### 8.2 성능 및 보안

- [ ] 데이터베이스 쿼리가 최적화되어 있는가?
- [ ] 리소스 사용이 효율적인가?
- [ ] 민감한 데이터가 적절히 암호화되어 있는가?
- [ ] 입력 데이터가 적절히 검증되는가?
- [ ] 오류 처리가 적절한가?

### 8.3 테스트

- [ ] 테스트 코드가 있는가?
- [ ] 테스트가 모든 중요한 경로를 커버하는가?
- [ ] 테스트가 이해하기 쉬운가?
- [ ] 테스트가 안정적으로 실행되는가?

### 8.4 문서화

- [ ] 필요한 모든 함수와 모듈이 문서화되어 있는가?
- [ ] 문서가 명확하고 정확한가?
- [ ] 복잡한 로직이 문서화되어 있는가?

## 9. 코드 품질 도구

### 9.1 정적 분석 도구

프로젝트에서는 다음과 같은 코드 품질 도구를 사용합니다:

- **Credo**: Elixir 코드 스타일 및 일관성 검사
- **Dialyxir**: 타입 검사
- **Sobelow**: 보안 취약점 분석
- **ExCoveralls**: 테스트 커버리지 측정 및 보고
- **dart_code_metrics**: Flutter/Dart 코드 품질 검사

### 9.2 설정 방법

다음과 같이 `mix.exs` 파일에 설정합니다:

```elixir
defp deps do
  [
    {:credo, "~> 1.6", only: [:dev, :test], runtime: false},
    {:dialyxir, "~> 1.2", only: [:dev, :test], runtime: false},
    {:sobelow, "~> 0.11", only: [:dev, :test], runtime: false},
    {:excoveralls, "~> 0.14", only: :test},
    # ... 기타 의존성
  ]
end

def project do
  [
    # ... 기타 설정
    test_coverage: [tool: ExCoveralls],
    preferred_cli_env: [
      coveralls: :test,
      "coveralls.detail": :test,
      "coveralls.post": :test,
      "coveralls.html": :test,
      "coveralls.github": :test
    ]
  ]
end
```

### 9.3 CI 통합

코드 품질 도구는 로컬 개발 환경뿐만 아니라 CI 환경에서도 자동으로 실행되어야 합니다. 지속적 통합을 통해 모든 변경사항에 대해 품질 검사를 수행합니다:

- 코드 형식 검사: `mix format --check-formatted`
- 코드 스타일 및 일관성 검사: `mix credo --strict`
- 타입 검사: `mix dialyxir`
- 보안 취약점 분석: `mix sobelow --config`
- 테스트 커버리지 측정: `mix coveralls.github`

프로젝트의 CI/CD 파이프라인 구성 및 GitHub Actions 워크플로우에 대한 자세한 내용은 [GUIDE-003] 개발 워크플로우 문서를 참조하세요.

## 10. 리팩토링 가이드라인

### 10.1 리팩토링 시점

다음과 같은 경우 리팩토링을 고려해야 합니다:

- 코드 중복이 발생한 경우
- 함수나 모듈이 너무 커진 경우
- 기능이 추가됨에 따라 기존 설계가 적합하지 않게 된 경우
- 성능 문제가 발생한 경우
- 테스트가 어려워진 경우

### 10.2 리팩토링 계획

리팩토링 전에는 다음을 준비합니다:

1. 리팩토링 범위와 목표를 명확히 정의
2. 현재 코드의 동작을 테스트로 문서화
3. 리팩토링 계획 문서 작성 (`../7-progress/[이슈명]_refactoring.md`)
4. 작은 단위로 나누어 리팩토링 수행
5. 각 단계마다 테스트 실행

### 10.3 리팩토링 승인

큰 규모의 리팩토링은 다음 절차를 따릅니다:

1. 리팩토링 계획 제출
2. 팀 리뷰 및 논의
3. 승인 후 리팩토링 진행
4. 완료 후 코드 리뷰

---

// File: automata-signal/1-guides/GUIDE-005-cicd-pipeline

# [GUIDE-005] CI/CD 파이프라인

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 요약

본 문서는 Automata-Signal 프로젝트의 CI/CD(지속적 통합 및 배포) 파이프라인을 설명합니다. GitHub Actions를 활용한 코드 품질 검증, 테스트 자동화, 그리고 다중 환경 배포 프로세스에 대한 상세 내용을 제공합니다.

## 대상 독자

- 신규 개발자
- 개발팀

## 1. CI/CD 파이프라인 개요

Automata-Signal 프로젝트는 GitHub Actions를 통해 완전 자동화된 CI/CD 파이프라인을 구현합니다. 이 파이프라인은 코드 품질 검증부터 다중 환경 자동 배포까지의 전체 과정을 자동화합니다.

### 1.1 파이프라인 흐름

```mermaid
flowchart TD
    PR[코드 변경/PR] --> QA[코드 품질 검사]
    QA --> Tests[테스트 실행]
    Tests --> Result{결과}
    Result -->|성공| Branch{브랜치?}
    Result -->|실패| Fail[빌드 실패]
    Branch -->|develop| DevDeploy[개발 환경 배포]
    Branch -->|main| ProdDeploy[프로덕션 환경 배포]
    Branch -->|기타| End[완료]
    DevDeploy --> End
    ProdDeploy --> ProdMigrate[마이그레이션 실행]
    ProdMigrate --> End
```

### 1.2 주요 구성 요소

1. **코드 품질 검증**: 코드 형식, 스타일, 보안 취약점 등 검사
2. **자동화된 테스트**: 단위 테스트, 통합 테스트 실행 및 커버리지 측정
3. **환경별 배포**: 특정 브랜치 변경에 따른 자동 배포
   - 개발(Development): develop 브랜치 변경 시
   - 스테이징(Staging): 수동 워크플로우 트리거 시
   - 프로덕션(Production): main 브랜치 변경 시 (다중 리전 배포)

## 2. GitHub Actions 워크플로우

### 2.1 워크플로우 파일 구성

CI/CD 파이프라인은 `.github/workflows/ci_cd.yml` 파일에 정의되어 있습니다:

```yaml
# .github/workflows/ci_cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

jobs:
  verify:
    name: Code Quality & Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: automata_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v3
      - uses: erlef/setup-beam@v1
        with:
          otp-version: '27'
          elixir-version: '1.18'

      - name: Cache deps
        uses: actions/cache@v3
        with:
          path: deps
          key: ${{ runner.os }}-mix-${{ hashFiles(format('{0}{1}', github.workspace, '/mix.lock')) }}
          restore-keys: |
            ${{ runner.os }}-mix-

      - name: Cache _build
        uses: actions/cache@v3
        with:
          path: _build
          key: ${{ runner.os }}-build-${{ hashFiles(format('{0}{1}', github.workspace, '/mix.lock')) }}
          restore-keys: |
            ${{ runner.os }}-build-

      - name: Install Dependencies
        run: mix deps.get

      - name: Check Formatting
        run: mix format --check-formatted

      - name: Run Credo
        run: mix credo --strict

      - name: Run Dialyxir
        run: mix dialyxir

      - name: Run Sobelow
        run: mix sobelow --config

      - name: Run Tests with Coverage
        run: mix coveralls.github
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy_dev:
    name: Deploy to Development
    needs: verify
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - name: Deploy to Development
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl deploy --app automata-signal-dev --config fly.dev.toml

  deploy_staging:
    name: Deploy to Staging
    needs: verify
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - uses: actions/checkout@v3
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - name: Deploy to Staging
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl deploy --app automata-signal-staging --config fly.staging.toml

  deploy_production:
    name: Deploy to Production
    needs: verify
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production

    steps:
      - uses: actions/checkout@v3
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - name: Deploy to Production
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          for region in nrt fra syd; do
            flyctl deploy --app automata-signal-$region --config fly.prod.$region.toml
          done

      - name: Run Migrations
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl ssh console --app automata-signal-nrt --command "/app/bin/automata eval 'Automata.Release.migrate'"
```

### 2.2 트리거 이벤트

워크플로우는 다음 이벤트에 의해 트리거됩니다:

1. **push**: main 또는 develop 브랜치에 코드가 푸시될 때
2. **pull_request**: main 또는 develop 브랜치로 PR이 생성될 때
3. **workflow_dispatch**: 수동으로 워크플로우를 실행할 때

### 2.3 작업(Jobs) 구성

워크플로우는 다음 작업들로 구성됩니다:

1. **verify**: 코드 품질 검사 및 테스트 실행
2. **deploy_dev**: 개발 환경 배포 (develop 브랜치에 변경 사항이 있을 때)
3. **deploy_staging**: 스테이징 환경 배포 (수동 트리거 시)
4. **deploy_production**: 프로덕션 환경 배포 (main 브랜치에 변경 사항이 있을 때)

## 3. 코드 품질 및 테스트 검증

### 3.1 사용되는 도구

`verify` 작업에서는 다음 코드 품질 도구가 사용됩니다:

| 도구        | 명령                           | 목적                         |
| ----------- | ------------------------------ | ---------------------------- |
| Formatter   | `mix format --check-formatted` | 코드 형식 일관성 검사        |
| Credo       | `mix credo --strict`           | 코드 스타일 및 일관성 검사   |
| Dialyxir    | `mix dialyxir`                 | 타입 검사                    |
| Sobelow     | `mix sobelow --config`         | 보안 취약점 분석             |
| ExCoveralls | `mix coveralls.github`         | 테스트 커버리지 측정 및 보고 |

### 3.2 데이터베이스 서비스

테스트 실행 시 다음과 같이 PostgreSQL 서비스가 제공됩니다:

```yaml
services:
  postgres:
    image: postgres:17
    env:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: automata_test
    ports:
      - 5432:5432
    options: >-
      --health-cmd pg_isready
      --health-interval 10s
      --health-timeout 5s
      --health-retries 5
```

### 3.3 캐싱 최적화

빌드 시간을 단축하기 위해 다음 항목을 캐싱합니다:

1. **deps 디렉토리**: 의존성 라이브러리 캐싱
2. **\_build 디렉토리**: 컴파일된 결과물 캐싱

```yaml
- name: Cache deps
  uses: actions/cache@v3
  with:
    path: deps
    key: ${{ runner.os }}-mix-${{ hashFiles(format('{0}{1}', github.workspace, '/mix.lock')) }}
    restore-keys: |
      ${{ runner.os }}-mix-

- name: Cache _build
  uses: actions/cache@v3
  with:
    path: _build
    key: ${{ runner.os }}-build-${{ hashFiles(format('{0}{1}', github.workspace, '/mix.lock')) }}
    restore-keys: |
      ${{ runner.os }}-build-
```

## 4. 환경별 배포 구성

### 4.1 배포 프로세스

각 환경에 대한 배포 작업은 다음과 같은 조건과 단계로 구성됩니다:

#### 개발 환경 배포

```yaml
deploy_dev:
  name: Deploy to Development
  needs: verify
  if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
  runs-on: ubuntu-latest

  steps:
    - uses: actions/checkout@v3
    - uses: superfly/flyctl-actions/setup-flyctl@master
    - name: Deploy to Development
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        flyctl deploy --app automata-signal-dev --config fly.dev.toml
```

#### 스테이징 환경 배포

```yaml
deploy_staging:
  name: Deploy to Staging
  needs: verify
  if: github.event_name == 'workflow_dispatch'
  runs-on: ubuntu-latest
  environment: staging

  steps:
    - uses: actions/checkout@v3
    - uses: superfly/flyctl-actions/setup-flyctl@master
    - name: Deploy to Staging
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        flyctl deploy --app automata-signal-staging --config fly.staging.toml
```

#### 프로덕션 환경 배포

```yaml
deploy_production:
  name: Deploy to Production
  needs: verify
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  runs-on: ubuntu-latest
  environment: production

  steps:
    - uses: actions/checkout@v3
    - uses: superfly/flyctl-actions/setup-flyctl@master
    - name: Deploy to Production
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        for region in nrt fra syd; do
          flyctl deploy --app automata-signal-$region --config fly.prod.$region.toml
        done

    - name: Run Migrations
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        flyctl ssh console --app automata-signal-nrt --command "/app/bin/automata eval 'Automata.Release.migrate'"
```

### 4.2 환경별 구성 파일

각 환경은 별도의 구성 파일을 사용합니다:

| 환경     | 구성 파일                | 애플리케이션 이름          |
| -------- | ------------------------ | -------------------------- |
| 개발     | fly.dev.toml             | automata-signal-dev        |
| 스테이징 | fly.staging.toml         | automata-signal-staging    |
| 프로덕션 | fly.prod.`{region}`.toml | automata-signal-`{region}` |

### 4.3 환경 승인 프로세스

스테이징 및 프로덕션 환경은 GitHub Environments를 통한 승인 프로세스를 적용할 수 있습니다:

```yaml
environment: staging
```

```yaml
environment: production
```

이를 통해 배포 전 지정된 리뷰어의 승인을 요구할 수 있습니다.

## 5. 비밀 관리

### 5.1 GitHub Secrets

워크플로우에서 사용되는 비밀은 GitHub Secrets를 통해 관리됩니다:

- **GITHUB_TOKEN**: GitHub API 접근을 위한 토큰 (GitHub에서 자동 제공)
- **FLY_API_TOKEN**: fly.io API 접근을 위한 토큰

비밀은 다음과 같이 환경 변수로 접근합니다:

```yaml
env:
  FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
```

### 5.2 환경별 비밀 관리

환경별로 다른 비밀을 사용해야 하는 경우, GitHub Environments 기능을 활용하여 환경별 비밀을 구성할 수 있습니다.

## 6. 모니터링 및 피드백

### 6.1 워크플로우 실행 모니터링

GitHub Actions 대시보드에서 워크플로우 실행 상태를 모니터링할 수 있습니다:

- GitHub 저장소 → Actions 탭 → CI/CD Pipeline 워크플로우

### 6.2 빌드 상태 배지

README.md 파일에 다음과 같은 빌드 상태 배지를 추가하여 최신 빌드 상태를 표시할 수 있습니다:

```markdown
![CI/CD Pipeline](https://github.com/{owner}/{repo}/actions/workflows/ci_cd.yml/badge.svg)
```

### 6.3 테스트 커버리지 보고서

ExCoveralls를 통해 생성된 테스트 커버리지 보고서는 GitHub Actions의 실행 결과에서 확인할 수 있습니다.

## 7. 문제 해결

### 7.1 일반적인 문제

| 문제                | 해결 방법                                                  |
| ------------------- | ---------------------------------------------------------- |
| 의존성 설치 실패    | `mix.lock` 파일이 저장소에 포함되어 있는지 확인            |
| 테스트 실패         | 로컬에서 `mix test`를 실행하여 문제 확인                   |
| 포맷팅 검사 실패    | `mix format`을 실행한 후 변경사항 커밋                     |
| 코드 품질 검사 실패 | `mix credo --strict`를 로컬에서 실행하여 문제 확인 및 수정 |
| 배포 실패           | fly.io 구성 파일이 올바른지 확인                           |

### 7.2 디버깅 방법

GitHub Actions의 실행 로그를 확인하여 오류의 원인을 파악할 수 있습니다:

1. GitHub 저장소 → Actions 탭 → 해당 워크플로우 실행 → 실패한 작업 클릭
2. 오류가 발생한 단계의 로그 확인

### 7.3 수동 워크플로우 실행

문제 해결을 위해 워크플로우를 수동으로 실행할 수 있습니다:

1. GitHub 저장소 → Actions 탭 → CI/CD Pipeline 워크플로우 → Run workflow 버튼
2. 필요한 경우 브랜치 선택 후 실행

## 8. 파이프라인 확장 및 커스터마이징

### 8.1 새 작업 추가

새로운 작업을 추가하려면 `jobs` 섹션에 다음과 같이 정의합니다:

```yaml
jobs:
  # 기존 작업들...

  new_job_name:
    name: New Job Description
    runs-on: ubuntu-latest
    needs: [verify] # 의존하는 작업 지정

    steps:
      - uses: actions/checkout@v3
      # 필요한 단계 추가
```

### 8.2 환경 추가

새로운 환경(예: QA)을 추가하려면 다음과 같이 설정합니다:

```yaml
deploy_qa:
  name: Deploy to QA
  needs: verify
  if: github.event_name == 'push' && github.ref == 'refs/heads/qa'
  runs-on: ubuntu-latest
  environment: qa

  steps:
    - uses: actions/checkout@v3
    - uses: superfly/flyctl-actions/setup-flyctl@master
    - name: Deploy to QA
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        flyctl deploy --app automata-signal-qa --config fly.qa.toml
```

### 8.3 통합 추가

알림 시스템(Slack, Teams 등)과의 통합은 다음과 같이 추가할 수 있습니다:

```yaml
- name: Slack Notification
  uses: 8398a7/action-slack@v3
  with:
    status: ${{ job.status }}
    fields: repo,message,commit,author,action,workflow
  env:
    SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  if: always() # 성공/실패 상관없이 항상 알림 전송
```

## 9. 모범 사례

### 9.1 워크플로우 최적화

1. **캐싱 활용**: 의존성과 빌드 결과물을 캐싱하여 실행 시간 단축
2. **매트릭스 빌드**: 여러 버전의 Elixir/OTP로 테스트해야 하는 경우 매트릭스 전략 사용
3. **필요한 작업만 실행**: 조건부 실행을 통해 필요한 작업만 수행

### 9.2 보안 강화

1. **비밀 관리**: 모든 민감한 정보는 GitHub Secrets로 관리
2. **최소 권한**: 각 작업에 필요한 최소한의 권한만 부여
3. **의존성 검사**: `mix hex.audit`를 통한 의존성 취약점 검사 추가

### 9.3 배포 안전성

1. **점진적 롤아웃**: 중요 변경사항은 단계적으로 배포
2. **Canary 배포**: 일부 사용자에게만 새 버전 배포 후 모니터링
3. **자동 롤백**: 중요 지표 이상 시 자동 롤백 메커니즘 구현

## 10. 참고 자료

- [GitHub Actions 공식 문서](https://docs.github.com/en/actions)
- [fly.io 배포 가이드](https://fly.io/docs/languages-and-frameworks/elixir/)
- [ExCoveralls 문서](https://github.com/parroty/excoveralls)
- [Credo 문서](https://github.com/rrrene/credo)
- [Dialyxir 문서](https://github.com/jeremyjh/dialyxir)
- [Sobelow 문서](https://github.com/nccgroup/sobelow)

---

// File: automata-signal/1-guides/GUIDE-005-deployment-workflow

# [GUIDE-005] 배포 워크플로우

| 버전 | 날짜       | 변경 내용                                   |
| ---- | ---------- | ------------------------------------------- |
| 1.1  | 2025-04-14 | 문서 개선 - 배포 워크플로우 중심으로 재구성 |
| 1.0  | 2025-04-02 | 최초 문서 작성                              |

## 요약

본 문서는 Automata-Signal 프로젝트의 배포 워크플로우를 설명합니다. GitHub Actions를 활용한 CI/CD(지속적 통합 및 배포) 파이프라인과 다중 환경 배포 프로세스에 대한 상세 내용을 제공합니다. 배포 인프라의 세부 구조는 [DESIGN-004] 운영 아키텍처 문서를 참조하세요.

## 대상 독자

- 신규 개발자
- 개발팀
- 운영팀

## 1. 배포 워크플로우 개요

Automata-Signal 프로젝트는 GitHub Actions를 통해 완전 자동화된 CI/CD 파이프라인을 구현합니다. 이 파이프라인은 코드 품질 검증부터 다중 환경/리전 자동 배포까지의 전체 과정을 자동화합니다.

### 1.1 파이프라인 흐름

```mermaid
flowchart TD
    PR[코드 변경/PR] --> QA[코드 품질 검사]
    QA --> Tests[테스트 실행]
    Tests --> Result{결과}
    Result -->|성공| Branch{브랜치?}
    Result -->|실패| Fail[빌드 실패]
    Branch -->|develop| DevDeploy[개발 환경 배포]
    Branch -->|main| ProdDeploy[프로덕션 환경 배포]
    Branch -->|기타| End[완료]
    DevDeploy --> End
    ProdDeploy --> ProdMigrate[마이그레이션 실행]
    ProdMigrate --> End
```

### 1.2 주요 구성 요소

1. **코드 품질 검증**: 코드 형식, 스타일, 보안 취약점 등 검사
2. **자동화된 테스트**: 단위 테스트, 통합 테스트 실행 및 커버리지 측정
3. **환경별 배포**: 특정 브랜치 변경에 따른 자동 배포
   - 개발(Development): develop 브랜치 변경 시
   - 스테이징(Staging): 수동 워크플로우 트리거 시
   - 프로덕션(Production): main 브랜치 변경 시 (다중 리전 배포)

## 2. GitHub Actions 워크플로우

### 2.1 워크플로우 파일 구성

CI/CD 파이프라인은 `.github/workflows/ci_cd.yml` 파일에 정의되어 있습니다:

```yaml
# .github/workflows/ci_cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  workflow_dispatch:

jobs:
  verify:
    name: Code Quality & Tests
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:17
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: automata_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v3
      - uses: erlef/setup-beam@v1
        with:
          otp-version: '27'
          elixir-version: '1.18'

      - name: Cache deps
        uses: actions/cache@v3
        with:
          path: deps
          key: ${{ runner.os }}-mix-${{ hashFiles(format('{0}{1}', github.workspace, '/mix.lock')) }}
          restore-keys: |
            ${{ runner.os }}-mix-

      - name: Cache _build
        uses: actions/cache@v3
        with:
          path: _build
          key: ${{ runner.os }}-build-${{ hashFiles(format('{0}{1}', github.workspace, '/mix.lock')) }}
          restore-keys: |
            ${{ runner.os }}-build-

      - name: Install Dependencies
        run: mix deps.get

      - name: Check Formatting
        run: mix format --check-formatted

      - name: Run Credo
        run: mix credo --strict

      - name: Run Dialyxir
        run: mix dialyxir

      - name: Run Sobelow
        run: mix sobelow --config

      - name: Run Tests with Coverage
        run: mix coveralls.github
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  deploy_dev:
    name: Deploy to Development
    needs: verify
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - name: Deploy to Development
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl deploy --app automata-signal-dev --config fly.dev.toml

  deploy_staging:
    name: Deploy to Staging
    needs: verify
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - uses: actions/checkout@v3
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - name: Deploy to Staging
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl deploy --app automata-signal-staging --config fly.staging.toml

  deploy_production:
    name: Deploy to Production
    needs: verify
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production

    steps:
      - uses: actions/checkout@v3
      - uses: superfly/flyctl-actions/setup-flyctl@master
      - name: Deploy to Production
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          for region in nrt fra syd; do
            flyctl deploy --app automata-signal-$region --config fly.prod.$region.toml
          done

      - name: Run Migrations
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl ssh console --app automata-signal-nrt --command "/app/bin/automata eval 'Automata.Release.migrate'"
```

### 2.2 트리거 이벤트

워크플로우는 다음 이벤트에 의해 트리거됩니다:

1. **push**: main 또는 develop 브랜치에 코드가 푸시될 때
2. **pull_request**: main 또는 develop 브랜치로 PR이 생성될 때
3. **workflow_dispatch**: 수동으로 워크플로우를 실행할 때

### 2.3 작업(Jobs) 구성

워크플로우는 다음 작업들로 구성됩니다:

1. **verify**: 코드 품질 검사 및 테스트 실행
2. **deploy_dev**: 개발 환경 배포 (develop 브랜치에 변경 사항이 있을 때)
3. **deploy_staging**: 스테이징 환경 배포 (수동 트리거 시)
4. **deploy_production**: 프로덕션 환경 배포 (main 브랜치에 변경 사항이 있을 때)

## 3. 코드 품질 및 테스트 검증

### 3.1 사용되는 도구

`verify` 작업에서는 다음 코드 품질 도구가 사용됩니다:

| 도구        | 명령                           | 목적                         |
| ----------- | ------------------------------ | ---------------------------- |
| Formatter   | `mix format --check-formatted` | 코드 형식 일관성 검사        |
| Credo       | `mix credo --strict`           | 코드 스타일 및 일관성 검사   |
| Dialyxir    | `mix dialyxir`                 | 타입 검사                    |
| Sobelow     | `mix sobelow --config`         | 보안 취약점 분석             |
| ExCoveralls | `mix coveralls.github`         | 테스트 커버리지 측정 및 보고 |

### 3.2 데이터베이스 서비스

테스트 실행 시 다음과 같이 PostgreSQL 서비스가 제공됩니다:

```yaml
services:
  postgres:
    image: postgres:17
    env:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: automata_test
    ports:
      - 5432:5432
    options: >-
      --health-cmd pg_isready
      --health-interval 10s
      --health-timeout 5s
      --health-retries 5
```

### 3.3 캐싱 최적화

빌드 시간을 단축하기 위해 다음 항목을 캐싱합니다:

1. **deps 디렉토리**: 의존성 라이브러리 캐싱
2. **\_build 디렉토리**: 컴파일된 결과물 캐싱

```yaml
- name: Cache deps
  uses: actions/cache@v3
  with:
    path: deps
    key: ${{ runner.os }}-mix-${{ hashFiles(format('{0}{1}', github.workspace, '/mix.lock')) }}
    restore-keys: |
      ${{ runner.os }}-mix-

- name: Cache _build
  uses: actions/cache@v3
  with:
    path: _build
    key: ${{ runner.os }}-build-${{ hashFiles(format('{0}{1}', github.workspace, '/mix.lock')) }}
    restore-keys: |
      ${{ runner.os }}-build-
```

## 4. 환경별 배포 구성

### 4.1 배포 프로세스

각 환경에 대한 배포 작업은 다음과 같은 조건과 단계로 구성됩니다:

#### 개발 환경 배포

```yaml
deploy_dev:
  name: Deploy to Development
  needs: verify
  if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
  runs-on: ubuntu-latest

  steps:
    - uses: actions/checkout@v3
    - uses: superfly/flyctl-actions/setup-flyctl@master
    - name: Deploy to Development
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        flyctl deploy --app automata-signal-dev --config fly.dev.toml
```

#### 스테이징 환경 배포

```yaml
deploy_staging:
  name: Deploy to Staging
  needs: verify
  if: github.event_name == 'workflow_dispatch'
  runs-on: ubuntu-latest
  environment: staging

  steps:
    - uses: actions/checkout@v3
    - uses: superfly/flyctl-actions/setup-flyctl@master
    - name: Deploy to Staging
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        flyctl deploy --app automata-signal-staging --config fly.staging.toml
```

#### 프로덕션 환경 배포

```yaml
deploy_production:
  name: Deploy to Production
  needs: verify
  if: github.event_name == 'push' && github.ref == 'refs/heads/main'
  runs-on: ubuntu-latest
  environment: production

  steps:
    - uses: actions/checkout@v3
    - uses: superfly/flyctl-actions/setup-flyctl@master
    - name: Deploy to Production
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        for region in nrt fra syd; do
          flyctl deploy --app automata-signal-$region --config fly.prod.$region.toml
        done

    - name: Run Migrations
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        flyctl ssh console --app automata-signal-nrt --command "/app/bin/automata eval 'Automata.Release.migrate'"
```

### 4.2 환경별 구성 파일

각 환경은 별도의 구성 파일을 사용합니다:

| 환경     | 구성 파일                | 애플리케이션 이름          |
| -------- | ------------------------ | -------------------------- |
| 개발     | fly.dev.toml             | automata-signal-dev        |
| 스테이징 | fly.staging.toml         | automata-signal-staging    |
| 프로덕션 | fly.prod.`{region}`.toml | automata-signal-`{region}` |

### 4.3 환경 승인 프로세스

스테이징 및 프로덕션 환경은 GitHub Environments를 통한 승인 프로세스를 적용하고 있습니다:

```yaml
environment: staging
```

```yaml
environment: production
```

이를 통해 배포 전 지정된 리뷰어의 승인을 요구할 수 있습니다. 프로덕션 환경의 경우 다음 단계로 구성됩니다:

1. 코드 변경 main 브랜치 병합
2. CI/CD 파이프라인 자동 트리거
3. 코드 품질 및 테스트 검증
4. 지정된 리뷰어에게 배포 승인 요청
5. 리뷰어 승인 후 자동 배포
6. 다중 리전에 순차적 배포
7. 마이그레이션 실행

## 5. 비밀 관리

### 5.1 GitHub Secrets

워크플로우에서 사용되는 비밀은 GitHub Secrets를 통해 관리됩니다:

- **GITHUB_TOKEN**: GitHub API 접근을 위한 토큰 (GitHub에서 자동 제공)
- **FLY_API_TOKEN**: fly.io API 접근을 위한 토큰

비밀은 다음과 같이 환경 변수로 접근합니다:

```yaml
env:
  FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
```

### 5.2 환경별 비밀 관리

환경별로 다른 비밀을 사용해야 하는 경우, GitHub Environments 기능을 활용하여 환경별 비밀을 구성할 수 있습니다:

1. GitHub 저장소 → Settings → Environments → 해당 환경 선택
2. Environment secrets 섹션에서 해당 환경에만 적용되는 비밀 추가
3. 워크플로우 파일에서 `environment: [환경명]` 설정

이를 통해 개발, 스테이징, 프로덕션 환경에 서로 다른 API 키, 인증 정보 등을 안전하게 관리할 수 있습니다.

## 6. 배포 전략

### 6.1 무중단 배포

Automata-Signal은 무중단 배포(Zero-Downtime Deployment)를 위해 롤링 업데이트 전략을 채택하고 있습니다:

```toml
# fly.toml 파일의 배포 설정
[deploy]
  strategy = "rolling"
  release_command = "eval 'Automata.Release.migrate'"
```

롤링 업데이트 과정:

1. 새 버전의 애플리케이션 이미지 빌드
2. 기존 인스턴스 중 하나를 새 버전으로 교체
3. 상태 점검을 통해 새 인스턴스의 정상 작동 확인
4. 정상 작동 시 트래픽을 새 인스턴스로 전환
5. 나머지 인스턴스를 순차적으로 교체

### 6.2 블루-그린 배포 옵션

중요한 변경사항의 경우, 필요에 따라 블루-그린 배포 방식을 수동으로 구성할 수 있습니다:

1. 새로운 애플리케이션 인스턴스(그린) 배포
2. 테스트 및 검증 수행
3. 트래픽을 이전 인스턴스(블루)에서 새 인스턴스(그린)로 전환
4. 문제 발생 시 빠르게 이전 인스턴스로 롤백

블루-그린 배포를 위한 수동 워크플로우:

```yaml
deploy_blue_green:
  name: Blue-Green Deployment
  needs: verify
  if: github.event_name == 'workflow_dispatch'
  runs-on: ubuntu-latest
  environment: production

  steps:
    - uses: actions/checkout@v3
    - uses: superfly/flyctl-actions/setup-flyctl@master
    - name: Deploy Green Environment
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        flyctl deploy --app automata-signal-green --config fly.green.toml

    # 검증 단계
    - name: Verify Green Environment
      run: |
        # 상태 확인 및 테스트 실행

    # 트래픽 전환
    - name: Switch Traffic
      run: |
        # DNS 또는 로드 밸런서 설정 업데이트
```

### 6.3 카나리 배포 옵션

점진적인 롤아웃을 위해 카나리 배포 방식도 선택할 수 있습니다:

1. 새 버전을 소수의 사용자 또는 리전에만 배포
2. 모니터링 및 성능 데이터 수집
3. 문제가 없을 경우 점진적으로 배포 범위 확장
4. 이슈 발생 시 영향 범위를 최소화하면서 롤백

## 7. 데이터베이스 마이그레이션

### 7.1 마이그레이션 실행 절차

데이터베이스 마이그레이션은 다음 절차에 따라 실행됩니다:

1. 마이그레이션 스크립트 생성: `mix ash_postgres.generate_migrations`
2. 테스트 환경에서 마이그레이션 검증: `mix ecto.migrate`
3. 프로덕션 배포 후 마이그레이션 실행:

```yaml
- name: Run Migrations
  env:
    FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
  run: |
    flyctl ssh console --app automata-signal-nrt --command "/app/bin/automata eval 'Automata.Release.migrate'"
```

### 7.2 안전한 마이그레이션 실행

데이터베이스 마이그레이션 실행 시 다음 안전 조치를 적용합니다:

1. **백업 생성**: 마이그레이션 전 데이터베이스 백업 수행
2. **하위 호환성**: 롤링 업데이트 동안 구 버전과 신 버전 공존을 고려한 마이그레이션 설계
3. **롤백 계획**: 마이그레이션 실패 시 이전 상태로 복원할 수 있는 롤백 계획 마련
4. **대규모 변경 분할**: 대규모 스키마 변경은 여러 단계로 분할하여 위험 최소화

## 8. 모니터링 및 피드백

### 8.1 워크플로우 실행 모니터링

GitHub Actions 대시보드에서 워크플로우 실행 상태를 모니터링할 수 있습니다:

- GitHub 저장소 → Actions 탭 → CI/CD Pipeline 워크플로우

### 8.2 빌드 상태 배지

README.md 파일에 다음과 같은 빌드 상태 배지를 추가하여 최신 빌드 상태를 표시할 수 있습니다:

```markdown
![CI/CD Pipeline](https://github.com/{owner}/{repo}/actions/workflows/ci_cd.yml/badge.svg)
```

### 8.3 테스트 커버리지 보고서

ExCoveralls를 통해 생성된 테스트 커버리지 보고서는 GitHub Actions의 실행 결과에서 확인할 수 있습니다. 또한 GitHub의 PR 페이지에서도 커버리지 정보를 확인할 수 있습니다.

### 8.4 배포 알림

팀 커뮤니케이션 도구(Slack, Teams 등)에 배포 알림을 전송하도록 구성할 수 있습니다:

```yaml
- name: Slack Notification
  uses: 8398a7/action-slack@v3
  with:
    status: ${{ job.status }}
    fields: repo,message,commit,author,action,workflow
  env:
    SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
  if: always() # 성공/실패 상관없이 항상 알림 전송
```

## 9. 문제 해결

### 9.1 일반적인 문제

| 문제                | 해결 방법                                                  |
| ------------------- | ---------------------------------------------------------- |
| 의존성 설치 실패    | `mix.lock` 파일이 저장소에 포함되어 있는지 확인            |
| 테스트 실패         | 로컬에서 `mix test`를 실행하여 문제 확인                   |
| 포맷팅 검사 실패    | `mix format`을 실행한 후 변경사항 커밋                     |
| 코드 품질 검사 실패 | `mix credo --strict`를 로컬에서 실행하여 문제 확인 및 수정 |
| 배포 실패           | fly.io 구성 파일이 올바른지 확인                           |

### 9.2 디버깅 방법

GitHub Actions의 실행 로그를 확인하여 오류의 원인을 파악할 수 있습니다:

1. GitHub 저장소 → Actions 탭 → 해당 워크플로우 실행 → 실패한 작업 클릭
2. 오류가 발생한 단계의 로그 확인

### 9.3 수동 워크플로우 실행

문제 해결을 위해 워크플로우를 수동으로 실행할 수 있습니다:

1. GitHub 저장소 → Actions 탭 → CI/CD Pipeline 워크플로우 → Run workflow 버튼
2. 필요한 경우 브랜치 선택 후 실행

## 10. 배포 워크플로우 확장 및 커스터마이징

### 10.1 새 작업 추가

새로운 작업을 추가하려면 `jobs` 섹션에 다음과 같이 정의합니다:

```yaml
jobs:
  # 기존 작업들...

  new_job_name:
    name: New Job Description
    runs-on: ubuntu-latest
    needs: [verify] # 의존하는 작업 지정

    steps:
      - uses: actions/checkout@v3
      # 필요한 단계 추가
```

### 10.2 환경 추가

새로운 환경(예: QA)을 추가하려면 다음과 같이 설정합니다:

```yaml
deploy_qa:
  name: Deploy to QA
  needs: verify
  if: github.event_name == 'push' && github.ref == 'refs/heads/qa'
  runs-on: ubuntu-latest
  environment: qa

  steps:
    - uses: actions/checkout@v3
    - uses: superfly/flyctl-actions/setup-flyctl@master
    - name: Deploy to QA
      env:
        FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN }}
      run: |
        flyctl deploy --app automata-signal-qa --config fly.qa.toml
```

### 10.3 통합 추가

알림 시스템, 모니터링 도구 등과의 통합을 추가할 수 있습니다:

```yaml
# Datadog 통합 예시
- name: Push Metrics to Datadog
  run: |
    curl -X POST "https://api.datadoghq.com/api/v1/series" \
    -H "Content-Type: application/json" \
    -H "DD-API-KEY: ${{ secrets.DATADOG_API_KEY }}" \
    -d @- << EOF
    {
      "series": [
        {
          "metric": "deployment.count",
          "points": [[$(date +%s), 1]],
          "tags": ["env:${{ github.ref_name }}", "app:automata-signal"]
        }
      ]
    }
    EOF
```

## 11. 배포 모범 사례

### 11.1 워크플로우 최적화

1. **캐싱 활용**: 의존성과 빌드 결과물을 캐싱하여 실행 시간 단축
2. **매트릭스 빌드**: 여러 버전의 Elixir/OTP로 테스트해야 하는 경우 매트릭스 전략 사용
3. **필요한 작업만 실행**: 조건부 실행을 통해 필요한 작업만 수행

### 11.2 보안 강화

1. **비밀 관리**: 모든 민감한 정보는 GitHub Secrets로 관리
2. **최소 권한**: 각 작업에 필요한 최소한의 권한만 부여
3. **의존성 검사**: `mix hex.audit`를 통한 의존성 취약점 검사 추가

### 11.3 배포 안전성

1. **점진적 롤아웃**: 중요 변경사항은 단계적으로 배포
2. **자동 롤백**: 중요 지표 이상 시 자동 롤백 메커니즘 구현
3. **배포 창**: 위험이 낮은 시간대에 배포 일정 계획

## 12. 참고 자료

- [GitHub Actions 공식 문서](https://docs.github.com/en/actions)
- [fly.io 배포 가이드](https://fly.io/docs/languages-and-frameworks/elixir/)
- [ExCoveralls 문서](https://github.com/parroty/excoveralls)
- [Credo 문서](https://github.com/rrrene/credo)
- [Dialyxir 문서](https://github.com/jeremyjh/dialyxir)
- [Sobelow 문서](https://github.com/nccgroup/sobelow)

## 13. 관련 문서

- [DESIGN-004] 운영 아키텍처 - 배포 인프라 구조에 대한 상세 정보
- [GUIDE-003] 개발 워크플로우 - AI 주도 개발과 CI/CD 통합 방법
- [GUIDE-004] 코딩 표준 - 코드 품질 도구 설정 및 사용 방법

---

// File: automata-signal/1-guides/GUIDE-006-framework-specific

# [GUIDE-006] Ash Framework 특화 가이드

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-14 | 최초 문서 작성 |

## 요약

본 문서는 Automata-Signal 프로젝트에서 Ash Framework를 효과적으로 활용하는 방법에 대한 상세 가이드를 제공합니다. Ash 리소스 정의, 확장 모듈 활용, 액션 구현, 쿼리, 데이터 로딩 등 Ash Framework 특화 내용을 집중적으로 다룹니다. 이 가이드는 Elixir 기반 프로젝트에서 재사용 가능한 참조 자료로 활용할 수 있습니다.

## 대상 독자

- Ash Framework를 사용하는 개발자
- Elixir 백엔드 개발자
- 시스템 아키텍트

## 1. Ash Framework 개요

### 1.1 Ash Framework란?

Ash Framework는 Elixir 기반의 선언적 데이터 모델링 및 관리 프레임워크입니다. 다음과 같은 핵심 특징을 가집니다:

- **선언적 리소스 정의**: 도메인 모델을 명확하고 응집력 있게 정의
- **확장 가능한 아키텍처**: 플러그인 형태의 다양한 확장 모듈 지원
- **풍부한 쿼리 API**: 복잡한 쿼리를 간결하게 작성 가능
- **강력한 인증/인가**: 세밀한 접근 제어 매커니즘 제공
- **다양한 데이터 계층**: PostgreSQL, Mnesia 등 다양한 백엔드 지원

### 1.2 주요 구성 요소

Ash Framework는 다음 주요 구성 요소로 이루어져 있습니다:

- **Resource**: 도메인 모델 정의 (엔티티, 속성, 관계)
- **Action**: 리소스에 대한 작업 정의 (생성, 조회, 수정, 삭제, 커스텀 작업)
- **Query**: 리소스 데이터 쿼리 및 필터링
- **Domain**: 관련 리소스 그룹화 및 접근 규칙 관리
- **Registry**: 리소스 등록 및 검색
- **DataLayer**: 데이터 저장 및 조회 추상화
- **Extension**: 기능 확장 모듈 (상태 기계, 아카이빙, 감사 추적 등)

## 2. Ash 리소스 정의 가이드

### 2.1 리소스 기본 구조

```elixir
defmodule MyApp.Resources.MyResource do
  use Ash.Resource,
    data_layer: AshPostgres.DataLayer,
    extensions: [
      # 필요한 확장 모듈만 추가
    ]

  # 속성 정의
  attributes do
    # ...
  end

  # 관계 정의
  relationships do
    # ...
  end

  # 액션 정의
  actions do
    # ...
  end

  # 계산된 속성
  calculations do
    # ...
  end

  # 집계 정의
  aggregates do
    # ...
  end
end
```

### 2.2 속성 정의 모범 사례

속성(attribute)은 리소스의 데이터 필드를 정의합니다:

```elixir
attributes do
  # 기본 키 (항상 첫 번째로 정의)
  uuid_primary_key :id

  # 기본 속성 정의
  attribute :name, :string do
    # 제약 조건
    constraints [required: true, min_length: 2, max_length: 100]
    # 기본값
    default "Unnamed"
    # 설명 (문서화)
    description "사용자 이름"
  end

  # 열거형(enum) 속성
  attribute :status, :atom do
    constraints [one_of: [:active, :inactive, :pending]]
    default :pending
    description "사용자 상태"
  end

  # 구조화된 데이터
  attribute :metadata, :map, default: %{}

  # 타임스탬프 (created_at, updated_at)
  timestamps()

  # 민감 정보 (암호화 필요)
  attribute :api_key, :string, sensitive?: true

  # 비공개 속성 (API 응답에서 제외)
  attribute :internal_notes, :string, private?: true

  # 사용자 정의 타입
  attribute :coords, MyApp.Types.GeoPoint
end
```

#### 속성 정의 규칙

1. **기본 키**: 항상 `uuid_primary_key :id`를 속성 블록 최상단에 정의합니다.
2. **논리적 그룹화**: 관련 속성을 함께 그룹화하고 그룹 간에 주석으로 구분합니다.
3. **제약 조건**: 모든 필수 필드에 `constraints [required: true]`를 명시합니다.
4. **기본값**: 적절한 기본값을 제공하여 데이터 일관성을 유지합니다.
5. **설명**: 복잡한 속성에는 `description` 메타데이터를 추가합니다.

### 2.3 관계 정의 모범 사례

관계(relationship)는 리소스 간의 연결을 정의합니다:

```elixir
relationships do
  # 일대다 관계
  has_many :messages, MyApp.Resources.Message do
    destination_attribute :user_id
    description "사용자가 보낸 메시지"
  end

  # 다대일 관계
  belongs_to :organization, MyApp.Resources.Organization do
    allow_nil? false # 필수 관계
    attribute_constraints on_delete: :delete_all # 소유 관계
    description "사용자가 속한 조직"
  end

  # 일대일 관계
  has_one :profile, MyApp.Resources.Profile do
    destination_attribute :user_id
    description "사용자 프로필"
  end

  # 다대다 관계
  many_to_many :projects, MyApp.Resources.Project do
    through MyApp.Resources.ProjectMember
    source_attribute_on_join_resource :user_id
    destination_attribute_on_join_resource :project_id
    description "사용자가 참여하는 프로젝트"
  end
end
```

#### 관계 정의 규칙

1. **관계 유형**: 정확한 관계 유형(`has_many`, `belongs_to`, `has_one`, `many_to_many`)을 선택합니다.
2. **속성 명명**: 기본 외래 키 이름은 `{관계명}_id`입니다. 다른 이름을 사용할 경우 `source_attribute` 또는 `destination_attribute`를 명시합니다.
3. **무결성 제약 조건**: `on_delete`, `on_update` 정책을 명확히 설정합니다.
4. **필수 관계**: 필수 관계는 `allow_nil? false`로 설정합니다.
5. **설명**: 각 관계의 의미를 `description`에 명시합니다.

### 2.4 계산 및 집계 정의

계산된 속성과 집계는 리소스의 데이터를 기반으로 동적으로 계산된 값을 정의합니다:

```elixir
# 계산된 속성
calculations do
  # 간단한 계산
  calculate :full_name, :string, expr(first_name <> " " <> last_name)

  # 조건부 계산
  calculate :subscription_status_text, :string, expr(
    case subscription_status do
      1 -> "활성"
      0 -> "대기 중"
      -1 -> "만료됨"
      _ -> "알 수 없음"
    end
  )

  # 관계를 사용한 계산
  calculate :has_messages, :boolean, expr(count(messages) > 0)
end

# 집계 정의
aggregates do
  # 단순 카운트
  count :message_count, :messages

  # 합계
  sum :total_purchases, :orders, :amount

  # 평균
  average :average_rating, :reviews, :rating

  # 최소/최대
  max :last_login, :login_events, :timestamp
  min :first_login, :login_events, :timestamp
end
```

#### 계산 및 집계 규칙

1. **표현식 사용**: 계산된 속성은 `expr/1` 매크로를 사용하여 정의합니다.
2. **성능 고려**: 복잡한 계산은 성능에 영향을 줄 수 있으므로 최적화합니다.
3. **명시적 로딩**: 계산 및 집계를 사용하기 전에 `Ash.Query.load/2`로 명시적으로 로드합니다.

## 3. Ash 확장 모듈 활용 가이드

### 3.1 AshStateMachine

상태 전이 관리를 위한 확장 모듈입니다:

```elixir
use Ash.Resource,
  extensions: [AshStateMachine.Resource]

attributes do
  # ...
  attribute :status, :atom do
    constraints [one_of: [:pending, :approved, :rejected, :completed]]
    default :pending
  end
  # ...
end

state_machine do
  # 상태 필드 지정
  field :status

  # 초기 상태 정의
  initial_states [:pending]

  # 상태 전이 규칙
  transitions do
    transition :approve, from: [:pending], to: :approved
    transition :reject, from: [:pending], to: :rejected
    transition :complete, from: [:approved], to: :completed
    transition :reopen, from: [:rejected, :completed], to: :pending
  end

  # 전이 전/후 동작 정의
  on_transition :approve do
    # 전이 전 검증
    prevent_transition unless: fn changeset, _ ->
      has_approval_permission?(changeset)
    end

    # 전이 시 속성 변경
    set_attribute :approved_at, &DateTime.utc_now/0
    set_attribute :approver_id, fn changeset, _ ->
      Ash.Changeset.get_context(changeset).actor.id
    end
  end
end

# 액션에서 상태 전이 사용
actions do
  update :approve do
    accept []
    change transition_state(:approve)
  end

  update :reject do
    accept [:rejection_reason]
    change transition_state(:reject)
  end
end
```

#### AshStateMachine 모범 사례

1. **상태 필드**: 상태 필드는 `:atom` 타입으로 정의하고 유효한 상태 목록을 `constraints [one_of: [...]]`로 제한합니다.
2. **전이 규칙**: 모든 가능한 상태 전이를 명시적으로 정의합니다.
3. **전이 동작**: 상태 변경 시 추가 동작(타임스탬프 설정, 사용자 기록 등)을 `on_transition` 블록에 정의합니다.
4. **액션 연결**: 상태 전이를 위한 전용 액션을 정의하고 `transition_state/1`를 사용합니다.

### 3.2 AshArchival

논리적 삭제(소프트 삭제)를 위한 확장 모듈입니다:

```elixir
use Ash.Resource,
  extensions: [AshArchival.Resource]

# 아카이브 속성 설정
archival do
  # 아카이브 여부를 저장할 속성
  archive_attribute :archived
  # 아카이브 시간을 저장할 속성
  archive_timestamp_attribute :archived_at
end

# 중요: 아카이브된 레코드를 기본적으로 필터링
resource do
  base_filter? true
end

# 아카이브/복원 액션
actions do
  # 아카이브 액션
  update :archive do
    accept []
    change archive()
  end

  # 복원 액션
  update :unarchive do
    accept []
    change unarchive()
  end

  # 아카이브된 항목 포함 조회
  read :read_with_archived do
    prepare build(load: false)
  end
end
```

#### AshArchival 모범 사례

1. **base_filter 활성화**: 항상 `resource do base_filter? true end`를 설정하여 아카이브된 레코드가 기본적으로 필터링되도록 합니다.
2. **아카이브 액션**: 명시적인 아카이브/복원 액션을 정의합니다.
3. **아카이브 시간 기록**: `archive_timestamp_attribute` 설정으로 아카이브 시간을 자동으로 기록합니다.
4. **아카이브 포함 쿼리**: 필요한 경우 아카이브된 항목을 포함한 조회 액션을 별도로 정의합니다.

### 3.3 AshPaperTrail

변경 이력 추적을 위한 확장 모듈입니다:

```elixir
use Ash.Resource,
  extensions: [AshPaperTrail.Resource]

# 변경 이력 설정
paper_trail do
  # 추적할 속성 지정
  track_attribute :status
  track_attribute :assigned_to_id

  # 관계 업데이트 추적
  track_relationship_updates? true

  # 액터(변경 주체) 추적
  monitor_actor? true
  track_actor? true

  # 변경 사유(선택사항)
  track_reason? true
end

# 액션 설정
actions do
  update :assign do
    accept [:assigned_to_id]

    # 변경 사유 요구
    argument :reason, :string do
      allow_nil? false
    end

    # 변경 사유 설정
    change set_context_attribute(:paper_trail_reason, fn changeset ->
      Ash.Changeset.get_argument(changeset, :reason)
    end)
  end
end
```

#### AshPaperTrail 모범 사례

1. **추적 대상 선택**: 변경 이력이 필요한 중요 속성만 `track_attribute`로 지정합니다.
2. **액터 추적**: 변경 주체를 추적하려면 `monitor_actor?` 및 `track_actor?`를 활성화합니다.
3. **변경 사유**: 중요한 변경의 경우 `track_reason?`를 활성화하고 액션에서 변경 사유를 요구합니다.
4. **컨텍스트 활용**: 액션 실행 시 `Ash.ContextHelpers.set_actor/2`로 액터를 설정합니다.

### 3.4 AshOban

비동기 작업 처리를 위한 확장 모듈입니다:

```elixir
use Ash.Resource,
  extensions: [AshOban.Resource]

# Oban 작업 설정
oban_job do
  # 큐 이름
  queue :messages

  # 우선순위 (낮을수록 높은 우선순위)
  priority 3

  # 최대 재시도 횟수
  max_attempts 5

  # 고유 작업 식별 (중복 방지)
  unique [:message_id]

  # 작업 유효 기간
  max_age 24 * 60 * 60

  # 실행할 워커 지정
  worker MyApp.Workers.MessageWorker

  # 태그 (분류 및 필터링용)
  tags ["message", "notification"]
end

# 액션에서 작업 예약
actions do
  create :schedule_message do
    accept [:title, :body, :recipient_id]

    # 예약 시간(선택)
    argument :scheduled_at, :utc_datetime do
      allow_nil? true
    end

    # Oban 작업으로 실행
    run_oban_job fn changeset ->
      # 작업 인자 설정
      args = %{
        message_id: Ash.Changeset.get_context(changeset, :message_id),
        recipient_id: Ash.Changeset.get_attribute(changeset, :recipient_id)
      }

      # 예약 시간 설정
      scheduled_at = Ash.Changeset.get_argument(changeset, :scheduled_at)

      if scheduled_at do
        {:ok, args, [scheduled_at: scheduled_at]}
      else
        {:ok, args}
      end
    end
  end
end
```

#### AshOban 모범 사례

1. **적절한 큐 선택**: 작업 유형에 맞는 큐를 선택하여 우선순위 및 처리량을 관리합니다.
2. **고유성 관리**: 중복 작업 방지를 위해 `unique` 파라미터를 설정합니다.
3. **재시도 전략**: 중요 작업은 `max_attempts`를 높게 설정하고, 일시적 실패 시 지수 백오프 재시도 전략을 구현합니다.
4. **작업 메타데이터**: `tags`를 사용하여 작업 분류 및 모니터링을 용이하게 합니다.

### 3.5 AshCloak

민감 데이터 암호화를 위한 확장 모듈입니다:

```elixir
use Ash.Resource,
  extensions: [AshCloak.Resource]

attributes do
  # ...
  # 암호화가 필요한 속성
  attribute :email, :string, sensitive?: true
  attribute :phone_number, :string, sensitive?: true
  attribute :api_token, :string, sensitive?: true
  # ...
end

# 암호화 설정
encrypted_attributes do
  # 암호화할 속성 지정
  attribute :email
  attribute :phone_number
  attribute :api_token

  # 사용할 Vault 지정 (선택사항)
  vault MyApp.Vault.EmailVault, for: [:email]
  vault MyApp.Vault.PhoneVault, for: [:phone_number]
  vault MyApp.Vault.TokenVault, for: [:api_token]
end
```

#### AshCloak 모범 사례

1. **민감 데이터 식별**: 개인 식별 정보, 인증 정보, 금융 정보 등 민감한 데이터를 식별하고 `sensitive?: true`로 표시합니다.
2. **Vault 설정**: 데이터 유형별로 적절한 Vault를 설정합니다.
3. **키 관리**: 암호화 키를 안전하게 관리하고 정기적으로 교체합니다.

```elixir
# Vault 설정 예시
config :ash_cloak, repo: MyApp.Repo

config :ash_cloak, MyApp.Vault.EmailVault,
  keys: [
    %{tag: "1", key: :base64.decode("..."), default: true}
  ]
```

### 3.6 AshMoney 및 AshDoubleEntry

통화 처리 및 이중 원장 회계를 위한 확장 모듈입니다:

```elixir
use Ash.Resource,
  extensions: [
    AshMoney.Resource,
    AshDoubleEntry.Resource
  ]

attributes do
  # ...
  # 통화 속성
  attribute :price, :money
  attribute :balance, :money, default: 0
  # ...
end

# 이중 원장 설정
double_entry do
  # 계정 정의
  account :balance do
    # 연결할 속성
    change_attribute :balance
    # 계정 유형 (금액 증가 방향)
    credit_type :increase
    debit_type :decrease
  end
end

# 액션에서 이중 원장 사용
actions do
  # 입금 액션
  update :deposit do
    accept []

    # 입금액 인자
    argument :amount, :decimal do
      allow_nil? false
      constraints [greater_than: 0]
    end

    # 이중 원장 거래
    change double_entry_credit(:balance) do
      # 금액 설정
      amount fn changeset ->
        Ash.Changeset.get_argument(changeset, :amount)
      end

      # 거래 설명
      description "사용자 입금"

      # 메타데이터
      metadata fn changeset ->
        %{
          user_id: Ash.Changeset.get_attribute(changeset, :id),
          method: Ash.Changeset.get_argument(changeset, :method)
        }
      end
    end
  end

  # 출금 액션
  update :withdraw do
    accept []

    # 출금액 인자
    argument :amount, :decimal do
      allow_nil? false
      constraints [greater_than: 0]
    end

    # 이중 원장 거래
    change double_entry_debit(:balance) do
      # 금액 설정
      amount fn changeset ->
        Ash.Changeset.get_argument(changeset, :amount)
      end

      # 거래 설명
      description "사용자 출금"

      # 메타데이터
      metadata fn changeset ->
        %{
          user_id: Ash.Changeset.get_attribute(changeset, :id),
          method: Ash.Changeset.get_argument(changeset, :method)
        }
      end
    end
  end
end
```

#### AshMoney 및 AshDoubleEntry 모범 사례

1. **통화 속성**: 모든 금액 필드는 `:money` 타입으로 정의합니다.
2. **계정 유형**: 각 계정의 `credit_type` 및 `debit_type`을 비즈니스 규칙에 맞게 설정합니다.
3. **거래 메타데이터**: 모든 거래에 충분한 컨텍스트 정보를 메타데이터로 포함합니다.
4. **거래 설명**: 명확한 거래 설명을 제공하여 감사 추적이 용이하도록 합니다.

## 4. Ash 액션 구현 가이드

### 4.1 기본 CRUD 액션

```elixir
actions do
  # 기본 CRUD 액션 활성화
  defaults [:create, :read, :update, :destroy]

  # 부분 활성화도 가능
  # defaults [:create, :read]
end
```

### 4.2 커스텀 액션 정의

#### 생성 액션

```elixir
actions do
  # 사용자 등록 액션
  create :register do
    # 허용할 속성
    accept [:email, :password, :first_name, :last_name]

    # 추가 인자
    argument :terms_accepted, :boolean do
      allow_nil? false
      constraints [must_be: true]
    end

    # 유효성 검증
    validate confirm(:password, :password_confirmation)
    validate present([:email, :password])

    # 속성 변경
    change set_attribute(:role, :user)
    change set_attribute(:status, :pending)

    # 비밀번호 해싱
    change fn changeset ->
      password = Ash.Changeset.get_attribute(changeset, :password)
      hashed_password = Bcrypt.hash_pwd_salt(password)
      Ash.Changeset.set_attribute(changeset, :password_hash, hashed_password)
      |> Ash.Changeset.set_attribute(:password, nil)
    end
  end
end
```

#### 읽기 액션

```elixir
actions do
  # 사용자 검색 액션
  read :search do
    # 필터 인자
    argument :query, :string do
      allow_nil? true
    end

    # 필터 적용
    filter expr(
      is_nil(^arg(:query)) or
      first_name ilike ^"%#{arg(:query)}%" or
      last_name ilike ^"%#{arg(:query)}%" or
      email == ^arg(:query)
    )

    # 페이지네이션
    pagination keyset?: true, default_limit: 20

    # 정렬
    sort [:last_name, :first_name]
  end

  # 활성 사용자만 조회
  read :active_users do
    filter expr(status == :active)
  end
end
```

#### 업데이트 액션

```elixir
actions do
  # 프로필 업데이트 액션
  update :update_profile do
    # 허용할 속성
    accept [:first_name, :last_name, :bio, :avatar_url]

    # 유효성 검증
    validate present([:first_name, :last_name])

    # 현재 사용자만 수정 가능
    authorize :update
  end

  # 비밀번호 변경 액션
  update :change_password do
    # 입력 인자
    argument :current_password, :string do
      allow_nil? false
    end

    argument :new_password, :string do
      allow_nil? false
      constraints [min_length: 8]
    end

    argument :new_password_confirmation, :string do
      allow_nil? false
    end

    # 유효성 검증
    validate confirm(:new_password, :new_password_confirmation)

    # 현재 비밀번호 확인
    validate fn changeset ->
      current = Ash.Changeset.get_argument(changeset, :current_password)
      hash = Ash.Changeset.get_attribute(changeset, :password_hash)

      if Bcrypt.verify_pass(current, hash) do
        :ok
      else
        {:error, field: :current_password, message: "현재 비밀번호가 올바르지 않습니다"}
      end
    end

    # 새 비밀번호 해싱
    change fn changeset ->
      new_password = Ash.Changeset.get_argument(changeset, :new_password)
      hashed_password = Bcrypt.hash_pwd_salt(new_password)
      Ash.Changeset.set_attribute(changeset, :password_hash, hashed_password)
    end
  end
end
```

#### 삭제 액션

```elixir
actions do
  # 계정 삭제 액션
  destroy :delete_account do
    # 입력 인자
    argument :confirmation, :string do
      allow_nil? false
      constraints [must_be: "DELETE"]
    end

    # 대안으로 아카이브 사용
    soft? true

    # 실행 전 콜백
    before_transaction fn changeset ->
      # 계정 삭제 전 정리 작업
      user_id = Ash.Changeset.get_attribute(changeset, :id)
      MyApp.UserCleanupService.schedule_cleanup(user_id)
      {:ok, changeset}
    end
  end
end
```

### 4.3 액션 인자 및 유효성 검사

```elixir
# 액션 인자 정의
argument :search_term, :string do
  # 필수 여부
  allow_nil? true
  # 기본값
  default ""
  # 제약 조건
  constraints [min_length: 3]
  # 설명
  description "검색어"
end

# 공통 유효성 검사
validate present([:field1, :field2])
validate confirm(:password, :password_confirmation)
validate is_unique(:email)
validate format(:email, ~r/@/)
validate min_length(:password, 8)
validate max_length(:bio, 500)

# 커스텀 유효성 검사
validate fn changeset ->
  field1 = Ash.Changeset.get_attribute(changeset, :field1)
  field2 = Ash.Changeset.get_attribute(changeset, :field2)

  if some_condition?(field1, field2) do
    :ok
  else
    {:error, field: :field1, message: "커스텀 오류 메시지"}
  end
end
```

### 4.4 액션 변경 함수

```elixir
# 속성 설정
change set_attribute(:field, "value")

# 동적 속성 설정
change set_attribute(:created_at, &DateTime.utc_now/0)

# 인자 기반 속성 설정
change set_attribute(:field, fn changeset ->
  Ash.Changeset.get_argument(changeset, :arg_name)
end)

# 관계 관리
change manage_relationship(:posts, %{title: "새 포스트"})

# 상태 전이
change transition_state(:approve)

# 이중 원장 거래
change double_entry_credit(:account, 100)

# 커스텀 변경 함수
change fn changeset, _ ->
  # 로직 구현
  modified_changeset = do_something(changeset)
  modified_changeset
end
```

## 5. Ash 쿼리 및 데이터 로딩 가이드

### 5.1 기본 쿼리 작성

```elixir
# 모든 레코드 조회
users = MyApp.Accounts.User
|> Ash.Query.filter(status == :active)
|> Ash.Query.sort(inserted_at: :desc)
|> Ash.Query.limit(10)
|> MyApp.Accounts.read!()

# 단일 레코드 조회
user = MyApp.Accounts.User
|> Ash.Query.filter(id == ^user_id)
|> Ash.Query.limit(1)
|> MyApp.Accounts.read_one!()

# 카운트 조회
count = MyApp.Accounts.User
|> Ash.Query.filter(status == :active)
|> Ash.Query.count!()
```

### 5.2 필터링 표현식

```elixir
# 기본 비교
Ash.Query.filter(user_resource, id == ^user_id)
Ash.Query.filter(user_resource, age > 18)
Ash.Query.filter(user_resource, status != :inactive)

# 논리 연산
Ash.Query.filter(user_resource, status == :active and role == :admin)
Ash.Query.filter(user_resource, status == :active or status == :pending)
Ash.Query.filter(user_resource, not is_nil(email))

# 컬렉션 연산
Ash.Query.filter(user_resource, role in [:admin, :moderator])
Ash.Query.filter(user_resource, :admin in roles)

# 문자열 연산
Ash.Query.filter(user_resource, first_name ilike ^"john%")
Ash.Query.filter(user_resource, email == email_address)

# 날짜 연산
Ash.Query.filter(user_resource, inserted_at > ^one_week_ago)
Ash.Query.filter(user_resource, is_nil(deleted_at))

# 관계 필터
Ash.Query.filter(user_resource, exists(posts, title ilike ^"%keyword%"))
Ash.Query.filter(user_resource, count(posts) > 0)
```

### 5.3 관계 로딩

```elixir
# 단일 관계 로드
user = MyApp.Accounts.User
|> Ash.Query.filter(id == ^user_id)
|> Ash.Query.load(:profile)  # has_one 관계
|> MyApp.Accounts.read_one!()

# 다중 관계 로드
user = MyApp.Accounts.User
|> Ash.Query.filter(id == ^user_id)
|> Ash.Query.load([:profile, :posts])
|> MyApp.Accounts.read_one!()

# 중첩 관계 로드
user = MyApp.Accounts.User
|> Ash.Query.filter(id == ^user_id)
|> Ash.Query.load([posts: [:comments, :category]])
|> MyApp.Accounts.read_one!()

# 관계 필터링
user = MyApp.Accounts.User
|> Ash.Query.filter(id == ^user_id)
|> Ash.Query.load(posts: fn query ->
  query
  |> Ash.Query.filter(published == true)
  |> Ash.Query.sort(published_at: :desc)
  |> Ash.Query.limit(5)
end)
|> MyApp.Accounts.read_one!()
```

### 5.4 계산 및 집계 로딩

```elixir
# 계산된 속성 로드
users = MyApp.Accounts.User
|> Ash.Query.load(:full_name)  # 계산된 속성
|> MyApp.Accounts.read!()

# 집계 로드
users = MyApp.Accounts.User
|> Ash.Query.load(:post_count)  # 집계
|> MyApp.Accounts.read!()

# 계산된 속성을 기준으로 정렬
users = MyApp.Accounts.User
|> Ash.Query.load(:full_name)
|> Ash.Query.sort(:full_name)
|> MyApp.Accounts.read!()

# 계산된 속성 필터링 (런타임 필터)
users = MyApp.Accounts.User
|> Ash.Query.load(:post_count)
|> MyApp.Accounts.read!()
|> Enum.filter(fn user -> user.post_count > 10 end)
```

### 5.5 페이지네이션

```elixir
# 오프셋 기반 페이지네이션
{users, pagination} = MyApp.Accounts.User
|> Ash.Query.sort(inserted_at: :desc)
|> Ash.Query.page(offset: 0, limit: 20)
|> MyApp.Accounts.read!()

# 키셋 기반 페이지네이션 (권장)
{users, pagination} = MyApp.Accounts.User
|> Ash.Query.sort(inserted_at: :desc)
|> Ash.Query.paginate(:keyset, limit: 20)
|> MyApp.Accounts.read!()

# 다음 페이지 로드
{next_users, pagination} = MyApp.Accounts.User
|> Ash.Query.sort(inserted_at: :desc)
|> Ash.Query.paginate(:keyset, limit: 20, after: pagination.after_key)
|> MyApp.Accounts.read!()

# 이전 페이지 로드
{prev_users, pagination} = MyApp.Accounts.User
|> Ash.Query.sort(inserted_at: :desc)
|> Ash.Query.paginate(:keyset, limit: 20, before: pagination.before_key)
|> MyApp.Accounts.read!()
```

### 5.6 트랜잭션 및 일괄 처리

```elixir
# 트랜잭션 내에서 여러 작업 수행
Ash.transaction(fn ->
  # 사용자 생성
  {:ok, user} = MyApp.Accounts.User
  |> Ash.Changeset.for_create(:create, %{email: "user@example.com"})
  |> MyApp.Accounts.create!()

  # 프로필 생성
  {:ok, profile} = MyApp.Accounts.Profile
  |> Ash.Changeset.for_create(:create, %{user_id: user.id, bio: "..."})
  |> MyApp.Accounts.create!()

  # 초기 설정 생성
  {:ok, settings} = MyApp.Accounts.UserSettings
  |> Ash.Changeset.for_create(:create, %{user_id: user.id})
  |> MyApp.Accounts.create!()

  {:ok, {user, profile, settings}}
end)

# 데이터 배치 처리
users
|> Enum.chunk_every(100)
|> Enum.each(fn batch ->
  Ash.transaction(fn ->
    Enum.each(batch, fn user ->
      user
      |> Ash.Changeset.for_update(:update, %{status: :verified})
      |> MyApp.Accounts.update!()
    end)
  end)
end)
```

## 6. Domain 및 API 모듈 구성 가이드

### 6.1 Domain 모듈 정의

```elixir
defmodule MyApp.Accounts do
  use Ash.Domain

  resources do
    resource MyApp.Accounts.User
    resource MyApp.Accounts.Profile
    resource MyApp.Accounts.UserSettings
    resource MyApp.Accounts.LoginEvent
  end
end

defmodule MyApp.Messaging do
  use Ash.Domain

  resources do
    resource MyApp.Messaging.Message
    resource MyApp.Messaging.Conversation
    resource MyApp.Messaging.Attachment
  end
end
```

### 6.2 API 액션 호출

```elixir
# 생성 액션
{:ok, user} = MyApp.Accounts.create(User, %{
  email: "user@example.com",
  first_name: "John",
  last_name: "Doe"
})

# 읽기 액션
{:ok, users} = MyApp.Accounts.read(User, filter: [status: :active])

# 단일 레코드 읽기
{:ok, user} = MyApp.Accounts.get(User, id)

# 업데이트 액션
{:ok, user} = MyApp.Accounts.update(User, id, %{status: :active})

# 삭제 액션
{:ok, _} = MyApp.Accounts.destroy(User, id)

# 커스텀 액션 호출
{:ok, user} = MyApp.Accounts.register(User, %{
  email: "user@example.com",
  password: "password123",
  password_confirmation: "password123",
  terms_accepted: true
})
```

### 6.3 API 컨텍스트 설정

```elixir
# 액터(인증된 사용자) 설정
context = %{actor: current_user}

# 인증된 사용자 정보로 액션 호출
{:ok, message} = MyApp.Messaging.create(Message, %{
  body: "Hello",
  recipient_id: recipient_id
}, context: context)

# 추가 컨텍스트 정보 설정
context = %{
  actor: current_user,
  tenant: tenant_id,
  ip_address: client_ip
}

# 컨텍스트와 함께 액션 호출
{:ok, user} = MyApp.Accounts.update(User, user_id, %{
  status: :verified
}, context: context)
```

## 7. 테스트 가이드

### 7.1 기본 리소스 테스트

```elixir
defmodule MyApp.AccountsTest.UserTest do
  use MyApp.DataCase
  alias MyApp.Accounts
  alias MyApp.Accounts.User

  describe "create user" do
    test "creates a user with valid attributes" do
      attrs = %{
        email: "test@example.com",
        first_name: "John",
        last_name: "Doe",
        password: "password123",
        password_confirmation: "password123"
      }

      assert {:ok, user} = Accounts.create(User, attrs)
      assert user.email == "test@example.com"
      assert user.first_name == "John"
      assert user.last_name == "Doe"
    end

    test "fails with invalid attributes" do
      attrs = %{
        email: "invalid-email",
        first_name: "",
        last_name: ""
      }

      assert {:error, changeset} = Accounts.create(User, attrs)
      assert errors_on(changeset).email
      assert errors_on(changeset).first_name
      assert errors_on(changeset).last_name
    end
  end

  describe "register user" do
    test "registers a user with valid attributes" do
      attrs = %{
        email: "test@example.com",
        first_name: "John",
        last_name: "Doe",
        password: "password123",
        password_confirmation: "password123",
        terms_accepted: true
      }

      assert {:ok, user} = Accounts.register(User, attrs)
      assert user.status == :pending
      assert user.role == :user
    end

    test "fails when terms not accepted" do
      attrs = %{
        email: "test@example.com",
        first_name: "John",
        last_name: "Doe",
        password: "password123",
        password_confirmation: "password123",
        terms_accepted: false
      }

      assert {:error, changeset} = Accounts.register(User, attrs)
      assert errors_on(changeset).terms_accepted
    end
  end
end
```

### 7.2 관계 테스트

```elixir
defmodule MyApp.AccountsTest.ProfileTest do
  use MyApp.DataCase
  alias MyApp.Accounts
  alias MyApp.Accounts.{User, Profile}

  setup do
    {:ok, user} = Accounts.create(User, %{
      email: "test@example.com",
      first_name: "John",
      last_name: "Doe"
    })

    %{user: user}
  end

  test "creates a profile for user", %{user: user} do
    attrs = %{
      user_id: user.id,
      bio: "Test bio",
      avatar_url: "https://example.com/avatar.jpg"
    }

    assert {:ok, profile} = Accounts.create(Profile, attrs)
    assert profile.user_id == user.id
    assert profile.bio == "Test bio"

    # 관계 로드 검증
    user_with_profile = user
    |> Ash.Query.load(:profile)
    |> Accounts.read_one!()

    assert user_with_profile.profile.id == profile.id
  end
end
```

### 7.3 액션 테스트

```elixir
defmodule MyApp.AccountsTest.UserActionsTest do
  use MyApp.DataCase
  alias MyApp.Accounts
  alias MyApp.Accounts.User

  setup do
    {:ok, user} = Accounts.create(User, %{
      email: "test@example.com",
      first_name: "John",
      last_name: "Doe",
      status: :active,
      password_hash: Bcrypt.hash_pwd_salt("password123")
    })

    %{user: user}
  end

  describe "change_password action" do
    test "changes password with valid input", %{user: user} do
      params = %{
        current_password: "password123",
        new_password: "newpassword456",
        new_password_confirmation: "newpassword456"
      }

      assert {:ok, updated_user} = Accounts.change_password(User, user.id, params)

      # 비밀번호가 변경되었는지 확인
      assert Bcrypt.verify_pass("newpassword456", updated_user.password_hash)
    end

    test "fails with incorrect current password", %{user: user} do
      params = %{
        current_password: "wrongpassword",
        new_password: "newpassword456",
        new_password_confirmation: "newpassword456"
      }

      assert {:error, changeset} = Accounts.change_password(User, user.id, params)
      assert errors_on(changeset).current_password
    end

    test "fails with password confirmation mismatch", %{user: user} do
      params = %{
        current_password: "password123",
        new_password: "newpassword456",
        new_password_confirmation: "different"
      }

      assert {:error, changeset} = Accounts.change_password(User, user.id, params)
      assert errors_on(changeset).new_password_confirmation
    end
  end
end
```

### 7.4 쿼리 테스트

```elixir
defmodule MyApp.AccountsTest.UserQueriesTest do
  use MyApp.DataCase
  alias MyApp.Accounts
  alias MyApp.Accounts.User

  setup do
    # 테스트 데이터 생성
    {:ok, _} = Accounts.create(User, %{
      email: "admin@example.com",
      first_name: "Admin",
      last_name: "User",
      status: :active,
      role: :admin
    })

    {:ok, _} = Accounts.create(User, %{
      email: "inactive@example.com",
      first_name: "Inactive",
      last_name: "User",
      status: :inactive,
      role: :user
    })

    for i <- 1..5 do
      {:ok, _} = Accounts.create(User, %{
        email: "user#{i}@example.com",
        first_name: "User",
        last_name: "#{i}",
        status: :active,
        role: :user
      })
    end

    :ok
  end

  test "filters active users" do
    query = User
    |> Ash.Query.filter(status == :active)
    |> Ash.Query.sort(email: :asc)

    assert {:ok, users} = Accounts.read(query)
    assert length(users) == 6
    assert Enum.all?(users, &(&1.status == :active))
  end

  test "searches users by name" do
    query = User
    |> Ash.Query.filter(first_name == "Admin" or first_name == "Inactive")
    |> Ash.Query.sort(email: :asc)

    assert {:ok, users} = Accounts.read(query)
    assert length(users) == 2
    assert Enum.map(users, & &1.first_name) == ["Admin", "Inactive"]
  end

  test "paginates results" do
    query = User
    |> Ash.Query.filter(role == :user)
    |> Ash.Query.sort(email: :asc)
    |> Ash.Query.page(limit: 2, offset: 0)

    assert {:ok, {users, pagination}} = Accounts.read(query)
    assert length(users) == 2
    assert pagination.count == 6
    assert pagination.limit == 2
    assert pagination.offset == 0
  end
end
```

## 8. 성능 최적화 팁

### 8.1 데이터 로딩 최적화

1. **필요한 데이터만 로드**: 필요한 속성과 관계만 명시적으로 로드합니다.

   ```elixir
   # 특정 필드만 선택
   User
   |> Ash.Query.select([:id, :email, :first_name, :last_name])
   |> Ash.Query.load(:profile)
   ```

2. **N+1 문제 방지**: 관계를 미리 로드하여 N+1 쿼리 문제를 방지합니다.

   ```elixir
   # 모든 관계를 미리 로드
   posts = Post
   |> Ash.Query.load([:author, comments: [:author]])
   |> MyApp.Blog.read!()
   ```

3. **배치 로딩**: 대량 데이터는 배치로 처리합니다.

   ```elixir
   Stream.resource(
     fn -> 0 end,
     fn offset ->
       query = User
       |> Ash.Query.sort(id: :asc)
       |> Ash.Query.page(limit: 100, offset: offset)

       case MyApp.Accounts.read(query) do
         {:ok, {[], _}} -> {:halt, nil}
         {:ok, {users, _}} -> {[users], offset + 100}
         _ -> {:halt, nil}
       end
     end,
     fn _ -> :ok end
   )
   |> Stream.flat_map(& &1)
   |> Stream.each(fn user -> process_user(user) end)
   |> Stream.run()
   ```

### 8.2 쿼리 최적화

1. **인덱스 활용**: 자주 필터링하는 필드에 인덱스를 생성합니다.

   ```elixir
   # PostgreSQL 인덱스 설정
   postgres do
     index [:email], unique: true
     index [:status, :role]
     index [:last_name, :first_name]
   end
   ```

2. **복합 쿼리 최적화**: 복잡한 쿼리는 데이터베이스 수준에서 최적화합니다.

   ```elixir
   # 커스텀 쿼리 사용
   read :complex_search do
     prepare build(load: false)

     argument :query, :string

     manual fn _query, %{query: query}, _context ->
       sql = """
       SELECT * FROM users
       WHERE to_tsvector('english', first_name || ' ' || last_name || ' ' || email) @@ plainto_tsquery('english', $1)
       ORDER BY last_name, first_name
       LIMIT 20
       """

       # SQL 실행 (예시)
       {:ok, results} = MyApp.Repo.query(sql, [query])

       # 결과를 Ash 리소스로 변환
       # ...
     end
   end
   ```

3. **부분 인덱스**: 특정 조건에만 인덱스를 적용하여 성능을 최적화합니다.

   ```elixir
   # 부분 인덱스 예시
   postgres do
     index [:status, :last_active_at], where: "status = 'active'"
   end
   ```

### 8.3 캐싱 전략

1. **쿼리 결과 캐싱**: 자주 접근하는 데이터를 캐시합니다.

   ```elixir
   def get_active_users do
     cache_key = "active_users"

     case MyApp.Cache.get(cache_key) do
       {:ok, users} when users != nil ->
         users
       _ ->
         users = User
         |> Ash.Query.filter(status == :active)
         |> MyApp.Accounts.read!()

         MyApp.Cache.put(cache_key, users, ttl: 300) # 5분 캐싱
         users
     end
   end
   ```

2. **계산 결과 캐싱**: 비용이 많이 드는 계산 결과를 캐시합니다.

   ```elixir
   calculations do
     calculate :complex_score, :float, {MyApp.Calculations.ComplexScore, ttl: 3600}
   end
   ```

## 9. 배포 및 운영 고려사항

### 9.1 마이그레이션 관리

1. **안전한 마이그레이션**: 하위 호환성을 유지하는 마이그레이션 설계

   ```elixir
   # 안전한 열 추가
   def change do
     alter table(:users) do
       add :middle_name, :string, null: true
     end
   end
   ```

2. **마이그레이션 생성**: ash_postgres 마이그레이션 스크립트 생성

   ```bash
   mix ash_postgres.generate_migrations
   ```

3. **마이그레이션 적용**: 마이그레이션 실행

   ```bash
   mix ecto.migrate
   ```

### 9.2 배포 전략

1. **릴리스 빌드**: 릴리스 패키지 생성

   ```bash
   MIX_ENV=prod mix release
   ```

2. **환경 구성**: 환경별 설정 관리

   ```elixir
   # config/runtime.exs
   config :my_app, MyApp.Repo,
     url: System.fetch_env!("DATABASE_URL"),
     pool_size: String.to_integer(System.get_env("POOL_SIZE") || "10")
   ```

3. **릴리스 마이그레이션**: 배포 시 자동 마이그레이션

   ```elixir
   # lib/my_app/release.ex
   defmodule MyApp.Release do
     def migrate do
       Application.load(:my_app)

       for repo <- Application.fetch_env!(:my_app, :ecto_repos) do
         {:ok, _, _} = Ecto.Migrator.with_repo(
           repo,
           &Ecto.Migrator.run(&1, :up, all: true)
         )
       end
     end
   end
   ```

## 10. 문제 해결 및 디버깅

### 10.1 일반적인 문제

1. **관계 로드 실패**: 관계가 로드되지 않을 때

   ```elixir
   # 문제: user.posts가 nil
   user = MyApp.Accounts.get!(User, id)

   # 해결: 명시적으로 관계 로드
   user = User
   |> Ash.Query.filter(id == ^id)
   |> Ash.Query.load(:posts)
   |> MyApp.Accounts.read_one!()
   ```

2. **계산된 속성 접근 실패**: 계산된 속성이 nil일 때

   ```elixir
   # 문제: user.full_name이 nil
   user = MyApp.Accounts.get!(User, id)

   # 해결: 명시적으로 계산된 속성 로드
   user = User
   |> Ash.Query.filter(id == ^id)
   |> Ash.Query.load(:full_name)
   |> MyApp.Accounts.read_one!()
   ```

3. **필터 인자 오류**: 필터에서 인자를 사용할 때

   ```elixir
   # 문제: 인자 바인딩 오류
   query = User
   |> Ash.Query.filter(email == user_email)

   # 해결: pin 연산자(^) 사용
   query = User
   |> Ash.Query.filter(email == ^user_email)
   ```

### 10.2 디버깅 기술

1. **체인지셋 검사**: 체인지셋 내용 확인

   ```elixir
   changeset = User
   |> Ash.Changeset.for_create(:create, attrs)

   IO.inspect(changeset, label: "Changeset")
   IO.inspect(Ash.Changeset.get_attributes(changeset), label: "Attributes")
   IO.inspect(Ash.Changeset.get_errors(changeset), label: "Errors")
   ```

2. **쿼리 인스펙션**: 생성된 SQL 쿼리 확인 (PostgreSQL)

   ```elixir
   # config/dev.exs
   config :ash_postgres, :repo_log_level, :debug
   ```

3. **에러 처리**: 상세 에러 정보 확인

   ```elixir
   case MyApp.Accounts.create(User, attrs) do
     {:ok, user} ->
       # 성공 처리
     {:error, error} ->
       IO.inspect(error, label: "Error")
       IO.inspect(errors_on(error), label: "Errors On")
       # 에러 처리
   end
   ```

## 11. 참고 자료

- [Ash Framework 공식 문서](https://hexdocs.pm/ash/get-started.html)
- [Ash Extensions 문서](https://ash-hq.org/docs/extensions)
- [Ash Postgres 문서](https://hexdocs.pm/ash_postgres/AshPostgres.html)
- [Ash Phoenix 문서](https://hexdocs.pm/ash_phoenix/AshPhoenix.html)
- [Elixir Forum - Ash 카테고리](https://elixirforum.com/c/elixir-framework-forum/ash-framework/107)

---

// File: automata-signal/2-designs/DESIGN-001-architecture-overview

# [DESIGN-001] 아키텍처 개요

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [DESIGN-002] 시스템 아키텍처
- [DESIGN-003] 데이터 모델
- [DESIGN-004] 배포 아키텍처
- [SEQ-001] 초기화 시퀀스
- [SEQ-002] 메시지 처리 시퀀스

## 요약

본 문서는 Automata-Signal 시스템의 전체 아키텍처 개요를 제공합니다. 시스템의 주요 구성 요소, 상호작용, 그리고 설계 원칙을 설명합니다.

## 대상 독자

- 개발팀
- 시스템 엔지니어
- 프로젝트 관리자
- 기술 이해관계자

## 1. 시스템 개요

Automata-Signal은 다양한 메시징 채널을 통합 관리하는 확장 가능한 메시징 플랫폼입니다. 초기에는 푸시 알림에 중점을 두고, 이후 이메일, SMS, 카카오 알림톡, 인앱 메시지 등 다양한 채널로 확장됩니다.

### 1.1 주요 목표

- **채널 통합**: 다양한 메시징 채널을 단일 인터페이스로 통합
- **고성능**: 초당 10만 건(10초당 100만 건)의 메시지 처리 능력
- **확장성**: 사용자, 채널 및 메시지 볼륨 증가에 유연한 대응
- **안정성**: fly.io 기반 글로벌 분산 배포로 99.95% 이상의 가용성
- **보안**: 민감한 사용자 데이터 및 인증 토큰 암호화
- **유지보수성**: Umbrella 구조와 어댑터 패턴을 통한 모듈성 및 확장성

### 1.2 핵심 기능

- 멀티채널 메시징 지원 (푸시, 이메일, SMS, 카카오 알림톡, 인앱 메시지)
- 메시지 상태 추적 (발송→도달→오픈)
- 대량 메시지 배치 처리 및 스케줄링
- 사용자 및 채널별 구독 관리
- 메시지 템플릿 관리와 개인화
- 메시지 캠페인 관리 및 타겟팅
- 통합 SDK 제공
- 멀티채널 통합 분석 및 보고서 생성

## 2. 아키텍처 다이어그램

아래는 Automata-Signal의 전체 시스템 아키텍처를 보여주는 다이어그램입니다:

```mermaid
flowchart TB
    subgraph Client ["클라이언트"]
        C1[클라이언트 애플리케이션<br>Flutter]
        SDK[Automata SDK<br>구독 등록/사용자 식별]
    end

    subgraph Backend ["Automata Umbrella"]
        subgraph Signal ["automata_signal"]
            API[API 게이트웨이<br>Phoenix]
            Elixir[분산 메시지 처리 클러스터<br>Elixir/Ash]
            TemplateEngine[템플릿 렌더링 엔진]
            CampaignManager[캠페인 관리자]

            subgraph Adapters ["채널 어댑터"]
                PushClient[푸시 클라이언트<br>Pigeon]
                EmailClient[이메일 클라이언트<br>지원 예정]
                SMSClient[SMS 클라이언트<br>지원 예정]
                KakaoClient[카카오톡 클라이언트<br>지원 예정]
                InAppClient[인앱 메시지 클라이언트<br>지원 예정]
            end
        end
        subgraph Other ["기타 앱 모듈"]
            Analytics[automata_analytics]
            Admin[automata_admin]
        end
        DB[(PostgreSQL<br>작업 큐/상태 저장)]
    end

    subgraph External ["외부 시스템"]
        APNS[Apple Push<br>Notification Service]
        FCM[Firebase Cloud<br>Messaging]
        SMTP[SMTP 서버/AWS SES<br>지원 예정]
        SMSGateway[SMS 게이트웨이<br>지원 예정]
        KakaoAPI[카카오 알림톡 API<br>지원 예정]

        UserDevice[사용자 기기<br>iOS/Android]
        UserEmail[사용자 이메일]
        UserPhone[사용자 휴대폰]
        UserKakao[사용자 카카오톡]
        InAppSDK[인앱 메시지 SDK<br>지원 예정]
    end

    C1 <--"SDK 초기화/로그인"--> SDK
    SDK <--"API 요청"--> API
    C1 <--"API 요청"--> API
    API --> Elixir
    Elixir <--"작업 큐/상태 저장"--> DB

    Elixir --"푸시 알림 요청"--> PushClient
    Elixir --"이메일 요청"--> EmailClient
    Elixir --"SMS 요청"--> SMSClient
    Elixir --"알림톡 요청"--> KakaoClient
    Elixir --"인앱 메시지 요청"--> InAppClient

    PushClient --"iOS 푸시 알림"--> APNS
    PushClient --"Android 푸시 알림"--> FCM
    EmailClient -.->|지원 예정| SMTP
    SMSClient -.->|지원 예정| SMSGateway
    KakaoClient -.->|지원 예정| KakaoAPI
    InAppClient -.->|지원 예정| InAppSDK

    APNS --"iOS 알림 전달"--> UserDevice
    FCM --"Android 알림 전달"--> UserDevice
    SMTP -.->|지원 예정| UserEmail
    SMSGateway -.->|지원 예정| UserPhone
    KakaoAPI -.->|지원 예정| UserKakao
    InAppSDK -.->|지원 예정| C1

    UserDevice --"상태 피드백(수신/열람)"--> C1
    C1 --"상태 업데이트"--> API
    API --"상태 기록"--> DB

    CampaignManager --> TemplateEngine
    CampaignManager --> Elixir
    Elixir --> Analytics
    Analytics --> DB
    Admin --> DB
```

## 3. 주요 컴포넌트

### 3.1 클라이언트 컴포넌트

- **클라이언트 애플리케이션**: Flutter 기반의 모바일 앱
- **Automata SDK**: 구독 등록, 사용자 식별, 메시지 상태 추적 기능을 제공하는 클라이언트 라이브러리

### 3.2 백엔드 컴포넌트

- **API 게이트웨이**: Phoenix Framework 기반 RESTful API
- **분산 메시지 처리 클러스터**: Elixir/OTP, libcluster, GenServer 기반 고성능 메시지 처리 시스템
- **템플릿 렌더링 엔진**: 메시지 템플릿 관리 및 변수 치환 처리
- **캠페인 관리자**: 대규모 메시지 캠페인 생성, 스케줄링, 타겟팅 처리
- **채널 어댑터**: 각 메시징 채널과의 통합을 담당하는 어댑터 모듈
- **분석 모듈**: 메시지 상태 및 사용자 참여 데이터 분석
- **관리자 모듈**: 시스템 관리 및 모니터링 인터페이스

### 3.3 데이터 저장소

- **PostgreSQL 데이터베이스**: 사용자, 구독, 메시지, 템플릿 등의 데이터 저장
- **Oban 작업 큐**: 메시지 처리 작업 관리 및 스케줄링

### 3.4 외부 시스템

- **APNS/FCM**: 푸시 알림 전송을 위한 Apple/Google 서비스
- **SMTP/SES**: 이메일 전송 서비스 (지원 예정)
- **SMS 게이트웨이**: SMS 전송 서비스 (지원 예정)
- **카카오 알림톡 API**: 카카오 메시지 전송 (지원 예정)

## 4. 주요 데이터 흐름

### 4.1 메시지 전송 흐름

1. 클라이언트가 API를 통해 메시지 전송 요청
2. API 게이트웨이가 요청을 처리하고 메시지 처리 클러스터로 전달
3. 메시지 데이터가 데이터베이스에 저장되고 작업 큐에 추가
4. 작업자가 메시지를 처리하고 적절한 채널 어댑터로 전달
5. 채널 어댑터가 외부 서비스(APNS, FCM 등)를 통해 메시지 전송
6. 전송 결과가 데이터베이스에 기록되고 분석 시스템에 전달

### 4.2 구독 관리 흐름

1. 사용자가 SDK를 통해 채널 구독 요청
2. SDK가 API를 통해 서버에 구독 정보 전송
3. 서버가 구독 정보를 처리하고 데이터베이스에 저장
4. 사용자가 특정 채널의 구독을 취소하면 구독 상태 업데이트

### 4.3 메시지 상태 추적 흐름

1. 메시지가 외부 서비스를 통해 사용자에게 전달
2. 사용자 기기가 메시지 수신 확인 신호를 SDK로 전송
3. SDK가 API를 통해 서버로 상태 업데이트 전송
4. 서버가 메시지 상태를 업데이트하고 데이터베이스에 기록
5. 사용자가 메시지와 상호작용하면 추가 상태 업데이트 발생

## 5. 기술 스택 개요

### 5.1 백엔드 기술

- **Elixir/OTP**: 고성능 동시성 처리 및 분산 시스템 구축
- **Phoenix Framework**: RESTful API 개발
- **Ash Framework**: 풍부한 도메인 모델링 및 확장 기능
- **PostgreSQL**: 데이터 저장 및 작업 큐 관리
- **Oban**: 비동기 작업 처리 및 스케줄링
- **Pigeon**: iOS/Android 푸시 알림 통합

### 5.2 클라이언트 기술

- **Flutter**: 크로스 플랫폼 모바일 앱 개발
- **firebase_messaging**: Firebase Cloud Messaging 통합
- **flutter_local_notifications**: 로컬 알림 관리

### 5.3 인프라 기술

- **fly.io**: 글로벌 분산 배포 및 엣지 컴퓨팅
- **libcluster**: Elixir 노드 자동 발견 및 클러스터링

## 6. 확장성 및 성능

### 6.1 수평적 확장

- 각 리전(도쿄, 프랑크푸르트, 시드니 등)에 여러 Elixir 노드 배포
- libcluster를 통한 노드 간 자동 연결 및 작업 분배
- 근접성 기반 라우팅으로 사용자에게 가장 가까운 노드 활용

### 6.2 성능 최적화

- 메시지 배치 처리로 데이터베이스 접근 최소화
- 채널별 적응형 비율 제한 및 재시도 전략
- 템플릿 렌더링 결과 캐싱

### 6.3 가용성 보장

- 다중 리전 배포로 지역 장애 대응
- 노드 장애 시 자동 복구 및 작업 재분배
- 일관된 상태 관리를 위한 PostgreSQL 복제

## 7. 보안 고려사항

- 모든 민감한 정보(토큰, 개인정보 등)는 ash_cloak으로 암호화
- 앱별 API 키 인증 시스템
- 멀티테넌시 데이터 격리
- HTTPS/TLS를 통한 모든 통신 암호화

## 8. 구현 로드맵 요약

- **Phase 1**: 핵심 인프라 및 푸시 알림 채널 구현
- **Phase 2**: 템플릿 시스템 및 캠페인 관리 구현
- **Phase 3**: SDK 개발 및 통합
- **Phase 4**: 성능 최적화 및 분산 배포
- **Phase 5**: 추가 채널 확장 (이메일, SMS, 카카오 알림톡, 인앱 메시지)

---

// File: automata-signal/2-designs/DESIGN-002-system-architecture

# [DESIGN-002] 시스템 아키텍처

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [DESIGN-001] 아키텍처 개요
- [DESIGN-003] 데이터 모델
- [DESIGN-004] 배포 구조
- [COMP-002] 어댑터 시스템
- [SEQ-002] 메시지 처리 시퀀스

## 요약

본 문서는 Automata-Signal 시스템의, 컴포넌트 수준의 상세 아키텍처를 설명합니다. 각 주요 컴포넌트의 책임, 상호작용 방식, 통신 프로토콜 및 데이터 흐름을 자세히 다룹니다.

## 대상 독자

- 백엔드 개발자
- 시스템 아키텍트
- 시스템 운영자
- 핵심 기술팀

## 1. 시스템 아키텍처 다이어그램

다음 다이어그램은 Automata-Signal 시스템의 컴포넌트 수준 아키텍처를 보여줍니다:

```
+------------------------------------------------------------------------------------------------------------+
|                                           AUTOMATA-SIGNAL                                                  |
+------------------------------------------------------------------------------------------------------------+
|                                                                                                            |
|  +-----------------+     +-----------------+     +-----------------+     +-----------------+               |
|  |                 |     |                 |     |                 |     |                 |               |
|  | API 게이트웨이  |<--->|  Elixir 서버   |<--->|  작업 처리기    |<--->|  채널 어댑터   |----+         |
|  | (Phoenix)       |     | (Ash Framework) |     |  (ash_oban)     |     |                 |    |         |
|  +-----------------+     +-----------------+     +-----------------+     +-----------------+    |         |
|          ^                     ^     |                    ^                                    |         |
|          |                     |     |                    |                                    |         |
|          v                     |     v                    |                                    v         |
|  +-----------------+     +-----------------+     +-----------------+     +-----------------+             |
|  |                 |     |                 |     |                 |     |                 |             |
|  | Flutter SDK     |     |  데이터베이스  |<--->|  템플릿 엔진    |     | 외부 서비스     |             |
|  |                 |     | (PostgreSQL)    |     |                 |     | (APNS/FCM 등)   |             |
|  +-----------------+     +-----------------+     +-----------------+     +-----------------+             |
|                                                        ^                                                 |
|                                                        |                                                 |
|                                                        v                                                 |
|                                           +-----------------+                                            |
|                                           |                 |                                            |
|                                           | 캠페인 관리자   |                                            |
|                                           |                 |                                            |
|                                           +-----------------+                                            |
|                                                                                                          |
+----------------------------------------------------------------------------------------------------------+
```

## 2. 핵심 컴포넌트 상세 설명

### 2.1 API 게이트웨이

API 게이트웨이는 시스템의 진입점으로, 클라이언트 요청을 수신하고 처리합니다.

**기술 스택**: Phoenix Framework, Ash Phoenix, Ash JSON API

**주요 책임**:

- RESTful API 엔드포인트 제공
- 요청 인증 및 권한 관리
- 요청 유효성 검증
- 요청 라우팅 및 조정
- 응답 포맷팅

**주요 인터페이스**:

1. **REST API**: 클라이언트와의 주요 통신 수단
2. **WebSocket**: 실시간 업데이트 및 이벤트 (향후 구현)

**API 버전 관리**:

- API 경로에 버전 접두사 포함 (예: `/api/v1/messages`)
- 이전 버전은 최소 6개월간 지원

**보안 메커니즘**:

- API 키 기반 인증
- HTTPS/TLS 암호화
- 요청 비율 제한
- CORS 정책

### 2.2 Elixir 서버

비즈니스 로직의 핵심이며, 리소스 관리와 서비스 조정을 담당합니다.

**기술 스택**: Elixir, Ash Framework, libcluster

**주요 책임**:

- 비즈니스 로직 처리
- 리소스 및 관계 관리
- 트랜잭션 조정
- 상태 관리
- 분산 처리 조정

**주요 모듈**:

1. **Resources**: 도메인 모델 및 데이터 구조 정의

   ```elixir
   defmodule AutomataSignal.Resources.Message do
     use Ash.Resource,
       data_layer: Ash.DataLayer.Postgres,
       extensions: [AshStateMachine.Resource]

     # 메시지 구조 정의
     attributes do
       uuid_primary_key :id
       attribute :title, :string
       attribute :body, :string
       attribute :data, :map, default: %{}
       # ... 기타 속성
     end

     # 상태 머신 정의
     state_machine do
       field :status
       # ... 상태 전이 규칙
     end

     # ... 관계 및 액션 정의
   end
   ```

2. **Services**: 비즈니스 로직 및 동작 구현

   ```elixir
   defmodule AutomataSignal.Services.MessageService do
     def send_message(message) do
       # 메시지 검증 및 처리
       # 작업 큐에 작업 추가
     end

     def update_message_status(message, status, details) do
       # 메시지 상태 업데이트
     end

     # ... 기타 서비스 기능
   end
   ```

3. **API Modules**: API 요청 처리 및 응답 생성

   ```elixir
   defmodule AutomataSignalWeb.MessageController do
     use AutomataSignalWeb, :controller

     def create(conn, params) do
       # 메시지 생성 로직
       # 응답 반환
     end

     # ... 기타 API 엔드포인트
   end
   ```

**분산 처리 메커니즘**:

- libcluster를 사용한 노드 자동 발견 및 연결
- GenServer 기반 분산 프로세스 관리
- Erlang 분산 프로토콜을 통한 노드 간 통신

### 2.3 작업 처리기

비동기 작업 처리 및 스케줄링을 담당합니다.

**기술 스택**: ash_oban, Oban, PostgreSQL

**주요 책임**:

- 메시지 전송 작업 처리
- 작업 스케줄링 및 우선순위 관리
- 재시도 전략 구현
- 비동기 작업 실행

**주요 워커 유형**:

1. **MessageWorker**: 개별 메시지 전송 처리

   ```elixir
   defmodule AutomataSignal.Workers.MessageWorker do
     use Oban.Worker, queue: :messages

     @impl Oban.Worker
     def perform(%Oban.Job{args: %{"id" => message_id}}) do
       message = AutomataSignal.Messages.get_message!(message_id)

       # 적절한 어댑터 선택
       adapter = get_adapter_for_channel(message.subscription.type)

       # 어댑터를 통해 메시지 전송
       case adapter.send_message(message) do
         {:ok, response} ->
           # 성공 처리
           :ok

         {:error, reason} ->
           # 오류 처리
           handle_send_error(message, reason)
       end
     end

     # ... 헬퍼 함수
   end
   ```

2. **CampaignWorker**: 캠페인 관련 작업 처리

   ```elixir
   defmodule AutomataSignal.Workers.CampaignWorker do
     use Oban.Worker, queue: :campaigns

     @impl Oban.Worker
     def perform(%Oban.Job{args: %{"id" => campaign_id, "action" => "process"}}) do
       campaign = AutomataSignal.Campaigns.get_campaign!(campaign_id)

       # 캠페인 처리 로직
       process_campaign(campaign)
     end

     # ... 캠페인 처리 함수
   end
   ```

3. **RetryWorker**: 실패한 작업 재시도

   ```elixir
   defmodule AutomataSignal.Workers.RetryWorker do
     use Oban.Worker, queue: :retry

     @impl Oban.Worker
     def perform(%Oban.Job{args: %{"id" => message_id}, attempt: attempt}) do
       # 지수 백오프 및 재시도 로직
     end
   end
   ```

**큐 설정**:

- `messages`: 일반 메시지 전송 (우선순위: 보통)
- `campaigns`: 캠페인 처리 (우선순위: 낮음)
- `retry`: 실패한 메시지 재시도 (우선순위: 낮음)
- `critical`: 중요 메시지 (우선순위: 높음)

**작업 수명 주기**:

1. 작업 생성 및 큐에 추가
2. 작업자가 작업 가져오기
3. 작업 실행
4. 성공 또는 실패 처리
5. 실패 시 재시도 전략 적용

### 2.4 채널 어댑터

외부 메시징 서비스와의 통합을 담당합니다.

**기술 스택**: Pigeon, GenServer

**주요 책임**:

- 외부 메시징 서비스와의 통신
- 메시지 형식 변환
- 서비스별 인증 및 구성 관리
- 응답 처리 및 오류 매핑

**어댑터 인터페이스**:

```elixir
defmodule AutomataSignal.Adapters.ChannelAdapter do
  @callback send_message(message :: AutomataSignal.Resources.Message.t()) ::
    {:ok, map()} | {:error, map()}

  @callback validate_message(message :: AutomataSignal.Resources.Message.t()) ::
    :ok | {:error, reason :: atom(), details :: map()}

  @callback get_status(message_id :: String.t()) ::
    {:ok, status :: atom()} | {:error, reason :: atom()}

  @callback map_error(error :: any()) ::
    {:permanent, reason :: atom(), details :: map()} |
    {:temporary, reason :: atom(), details :: map()}
end
```

**주요 어댑터 구현**:

1. **PushAdapter**: iOS/Android 푸시 알림 처리

   ```elixir
   defmodule AutomataSignal.Adapters.PushAdapter do
     @behaviour AutomataSignal.Adapters.ChannelAdapter

     @impl true
     def send_message(%{subscription: subscription} = message) do
       case subscription.type do
         :iOSPush -> send_ios_message(message)
         :AndroidPush -> send_android_message(message)
         _ -> {:error, %{reason: :invalid_subscription_type}}
       end
     end

     # ... 구현 세부사항
   end
   ```

2. **EmailAdapter**: 이메일 메시지 처리 (지원 예정)
3. **SMSAdapter**: SMS 메시지 처리 (지원 예정)
4. **KakaoAdapter**: 카카오 알림톡 처리 (지원 예정)
5. **InAppAdapter**: 인앱 메시지 처리 (지원 예정)

**연결 관리**:

- 연결 풀링
- 자동 재연결
- 비율 제한 준수

**어댑터 팩토리**:

```elixir
defmodule AutomataSignal.Adapters.AdapterFactory do
  def get_adapter_for_channel_type(channel_type) do
    case channel_type do
      :iOSPush -> AutomataSignal.Adapters.PushAdapter
      :AndroidPush -> AutomataSignal.Adapters.PushAdapter
      :Email -> AutomataSignal.Adapters.EmailAdapter
      :SMS -> AutomataSignal.Adapters.SMSAdapter
      :KakaoTalk -> AutomataSignal.Adapters.KakaoAdapter
      :InAppMessage -> AutomataSignal.Adapters.InAppAdapter
      _ -> raise "Unsupported channel type: #{inspect(channel_type)}"
    end
  end
end
```

### 2.5 템플릿 엔진

메시지 템플릿 관리 및 렌더링을 담당합니다.

**기술 스택**: 커스텀 템플릿 엔진, EEx

**주요 책임**:

- 템플릿 저장 및 관리
- 변수 치환 및 렌더링
- 템플릿 버전 관리
- 다국어 지원

**템플릿 형식**:

```elixir
# 템플릿 예시
%{
  "title_template" => "안녕하세요 {{user_name}}님",
  "body_template" => "{{event_name}} 이벤트가 {{start_date}}에 시작됩니다",
  "data_template" => %{
    "action" => "open_screen",
    "screen" => "event_details",
    "event_id" => "{{event_id}}"
  }
}

# 변수 맵
%{
  "user_name" => "홍길동",
  "event_name" => "여름 세일",
  "start_date" => "4월 10일",
  "event_id" => "evt-12345"
}
```

**템플릿 렌더링 로직**:

```elixir
defmodule AutomataSignal.TemplateEngine do
  def render_template(template, variables) when is_binary(template) do
    Regex.replace(~r/\{\{([^}]+)\}\}/, template, fn _, var_name ->
      Map.get(variables, var_name, "")
    end)
  end

  def render_message_content(template, variables) do
    %{
      title: render_template(template.title_template, variables),
      body: render_template(template.body_template, variables),
      data: render_data_template(template.data_template, variables)
    }
  end

  # ... 데이터 템플릿 렌더링 로직
end
```

**템플릿 캐싱**:

- 자주 사용되는 템플릿 메모리 캐싱
- 캐시 무효화 전략
- 캐시 크기 제한

### 2.6 캠페인 관리자

대량 메시지 캠페인 생성 및 관리를 담당합니다.

**기술 스택**: Elixir, Ash Framework, ash_oban

**주요 책임**:

- 캠페인 생성 및 관리
- 대상 사용자 필터링
- 캠페인 스케줄링
- 캠페인 실행 및 모니터링
- 성과 측정

**캠페인 처리 프로세스**:

1. 캠페인 생성 및 구성
2. 타겟팅 쿼리 정의
3. 스케줄링 (즉시 또는 미래 시점)
4. 대상 사용자 쿼리 실행
5. 배치 메시지 생성
6. 작업 큐에 배치 추가
7. 진행 상황 모니터링

**타겟팅 기능**:

```elixir
defmodule AutomataSignal.Services.CampaignService do
  def target_users(campaign) do
    criteria = campaign.targeting_criteria

    base_query = AutomataSignal.Resources.Subscription

    query = base_query
    |> filter_by_application(criteria["application_id"])
    |> filter_by_tags(criteria["tags"])
    |> filter_by_activity(criteria["last_active_after"])
    |> filter_by_countries(criteria["countries"])

    AutomataSignal.Repo.all(query)
  end

  # ... 필터링 함수
end
```

### 2.7 데이터베이스

모든 시스템 데이터의 영구 저장소이자 작업 큐의 기반입니다.

**기술 스택**: PostgreSQL, Ash Postgres

**저장 데이터**:

- 구독 정보
- 사용자 정보
- 메시지 및 상태
- 템플릿
- 캠페인
- 작업 큐
- 감사 로그

**주요 테이블**:

1. **applications**: 앱 정보
2. **users**: 사용자 정보
3. **subscriptions**: 구독 정보
4. **messages**: 메시지 정보
5. **message_events**: 메시지 이벤트
6. **subscription_events**: 구독 이벤트
7. **message_templates**: 메시지 템플릿
8. **message_campaigns**: 메시지 캠페인
9. **oban_jobs**: 작업 큐
10. **message_quotas**: 앱별 할당량

**성능 최적화**:

- 적절한 인덱싱
- 파티셔닝 (메시지, 이벤트 테이블)
- 연결 풀링
- 정기적인 유지보수

### 2.8 Flutter SDK

클라이언트 측 통합을 위한 SDK입니다.

**기술 스택**: Flutter, Dart

**주요 책임**:

- 디바이스 등록 및 토큰 관리
- 사용자 식별 및 인증
- 구독 관리
- 메시지 수신 및 처리
- 이벤트 추적

**주요 컴포넌트**:

1. **AutomataSignal**: 주 SDK 클래스
2. **SubscriptionManager**: 구독 관리
3. **UserManager**: 사용자 식별
4. **MessageManager**: 메시지 처리
5. **InAppMessageManager**: 인앱 메시지 관리 (지원 예정)

**사용 예시**:

```dart
// SDK 초기화
await AutomataSignal().initialize('YOUR_APP_ID');

// 사용자 식별
await AutomataSignal().login('user123');

// 이메일 구독 등록
String? emailSubscriptionId = await AutomataSignal().registerEmail('user@example.com');

// 푸시 알림 비활성화
await AutomataSignal().disableChannel(SubscriptionType.iOSPush);

// 태그 추가
await AutomataSignal().addTags({'premium': 'true', 'user_level': 'gold'});
```

## 3. 통신 프로토콜 및 인터페이스

### 3.1 API 인터페이스

**기본 URL**: `https://api.automata-signal.com/api/v1`

**인증 방식**:

- API 키 (HTTP 헤더: `X-API-Key`)
- 요청 제한: 초당 100개 요청

**주요 엔드포인트**:

1. **구독 관리**:

   - `POST /subscriptions`: 구독 생성
   - `GET /subscriptions/:id`: 구독 조회
   - `PUT /subscriptions/:id`: 구독 업데이트
   - `DELETE /subscriptions/:id`: 구독 삭제

2. **사용자 관리**:

   - `POST /users/identify`: 사용자 식별
   - `POST /users/logout`: 사용자 로그아웃
   - `GET /users/:id/subscriptions`: 사용자 구독 조회

3. **메시지 관리**:

   - `POST /messages`: 메시지 전송
   - `GET /messages/:id`: 메시지 조회
   - `PUT /messages/:id/status`: 메시지 상태 업데이트

4. **템플릿 관리**:

   - `POST /templates`: 템플릿 생성
   - `GET /templates/:id`: 템플릿 조회
   - `PUT /templates/:id`: 템플릿 업데이트
   - `DELETE /templates/:id`: 템플릿 삭제

5. **캠페인 관리**:
   - `POST /campaigns`: 캠페인 생성
   - `GET /campaigns/:id`: 캠페인 조회
   - `PUT /campaigns/:id`: 캠페인 업데이트
   - `POST /campaigns/:id/execute`: 캠페인 실행

### 3.2 Elixir 노드 간 통신

**프로토콜**: Erlang 분산 프로토콜

**메커니즘**:

- 분산 GenServer 호출
- 노드 간 RPC
- 분산 PubSub

**주요 메시지 유형**:

1. 작업 분배 메시지
2. 상태 업데이트 메시지
3. 캠페인 진행 상황 메시지
4. 할당량 업데이트 메시지

### 3.3 외부 서비스 통합

1. **APNS(Apple Push Notification Service)**:

   - 프로토콜: HTTP/2
   - 인증: 인증서 또는 JWT
   - 라이브러리: Pigeon
   - 모드: 개발/프로덕션

2. **FCM(Firebase Cloud Messaging)**:

   - 프로토콜: HTTP
   - 인증: 서버 키
   - 라이브러리: Pigeon

3. **SMTP/SES(이메일)** - 지원 예정:

   - 프로토콜: SMTP
   - 인증: SMTP 인증
   - 라이브러리: Swoosh

4. **SMS 게이트웨이** - 지원 예정:

   - 프로토콜: HTTP
   - 인증: API 키

5. **카카오 비즈니스 API** - 지원 예정:
   - 프로토콜: HTTP
   - 인증: 액세스 토큰

## 4. 데이터 흐름

### 4.1 메시지 전송 흐름

다음은 메시지 전송의 전체 데이터 흐름입니다:

1. **요청 수신**:

   - 클라이언트가 API 게이트웨이에 메시지 전송 요청
   - API 게이트웨이가 요청 검증

2. **메시지 생성**:

   - Elixir 서버가 요청 처리
   - 메시지 레코드 생성 (상태: `pending`)
   - 데이터베이스에 메시지 저장

3. **작업 큐 추가**:

   - 메시지 ID로 작업 생성
   - 작업을 적절한 큐에 추가

4. **작업 처리**:

   - 작업자가 작업 가져오기
   - 메시지 데이터 로드
   - 적절한 채널 어댑터 선택

5. **어댑터 전송**:

   - 어댑터가 메시지 형식 변환
   - 외부 서비스로 전송

6. **응답 처리**:

   - 외부 서비스 응답 수신
   - 메시지 상태 업데이트 (상태: `successful` 또는 `failed`)
   - 필요시 재시도 스케줄링

7. **클라이언트 피드백**:
   - 클라이언트가 메시지 수신 확인 (상태: `received`)
   - 클라이언트가 사용자 상호작용 보고 (상태: `converted`)

### 4.2 캠페인 처리 흐름

대량 메시지 캠페인의 데이터 흐름:

1. **캠페인 생성**:

   - 캠페인 정보 및 타겟팅 설정
   - 캠페인 레코드 저장

2. **캠페인 실행**:

   - 스케줄된 시간에 캠페인 작업 시작
   - 대상 사용자 쿼리 실행

3. **배치 처리**:

   - 대상 사용자를 배치로 분할 (500-1000명 단위)
   - 각 배치에 대한 작업 생성

4. **메시지 생성**:

   - 배치 내 각 사용자별 메시지 생성
   - 템플릿 엔진으로 콘텐츠 렌더링
   - 메시지 레코드 저장

5. **메시지 큐 추가**:

   - 생성된 메시지를 작업 큐에 추가
   - 처리 우선순위 설정

6. **진행 상황 추적**:
   - 캠페인 진행 상황 업데이트
   - 처리된 메시지 수 집계
   - 오류 집계

### 4.3 구독 관리 흐름

구독 등록 및 관리 흐름:

1. **SDK 초기화**:

   - 앱 시작 시 SDK 초기화
   - 디바이스 정보 수집

2. **푸시 토큰 등록**:

   - APNS/FCM으로부터 토큰 획득
   - 서버에 토큰 등록
   - 구독 레코드 생성

3. **사용자 식별**:

   - 앱에서 사용자 로그인
   - SDK가 사용자 식별자 전송
   - 서버가 구독-사용자 연결

4. **추가 채널 등록**:

   - 사용자가 이메일, SMS 등 추가 채널 제공
   - SDK가 채널 정보 전송
   - 서버가 새 구독 생성 또는 기존 구독 업데이트

5. **구독 상태 변경**:
   - 사용자가 채널 비활성화
   - SDK가 상태 변경 요청
   - 서버가 구독 상태 업데이트
   - 이벤트 기록

## 5. 확장성 및 성능 고려사항

### 5.1 수평적 확장

Automata-Signal은 분산 아키텍처를 통해 수평적 확장을 지원합니다:

1. **Elixir 노드 확장**:

   - 지역별로 노드 추가 가능
   - libcluster를 통한 자동 노드 발견 및 연결
   - 작업 분산을 통한 부하 분산

2. **데이터베이스 확장**:

   - 읽기 복제본 사용
   - 테이블 파티셔닝
   - 필요시 샤딩 적용

3. **작업 큐 확장**:
   - 큐별 작업자 수 조정
   - 프라이어리티 큐 활용
   - 작업자 노드 분리 가능

### 5.2 성능 최적화

주요 성능 최적화 전략:

1. **배치 처리**:

   - 데이터베이스 작업 배치화
   - 대량 메시지 배치 처리
   - 배치 크기 최적화 (500-1000개)

2. **캐싱 전략**:

   - 템플릿 캐싱
   - 구독 데이터 캐싱
   - 애플리케이션 설정 캐싱

3. **비동기 처리**:

   - 모든 메시지 처리 비동기화
   - 장기 실행 작업의 백그라운드 처리
   - 전송 상태 비동기 업데이트

4. **데이터베이스 최적화**:
   - 인덱스 최적화
   - 연결 풀링
   - 트랜잭션 관리
   - 효율적인 쿼리 설계

### 5.3 부하 테스트 결과

초기 부하 테스트 결과 및 목표:

1. **단일 노드 성능**:

   - 초당 최대 메시지 처리량: 5,000-10,000건
   - 평균 메시지 처리 시간: 20ms
   - 최대 연결 수: 10,000

2. **클러스터 성능 (4노드)**:

   - 초당 최대 메시지 처리량: 40,000건
   - 버스트 처리량 (10초): 400,000건
   - 평균 메시지 처리 시간: 25ms

3. **목표 성능 (12노드)**:
   - 초당 최대 메시지 처리량: 100,000건
   - 버스트 처리량 (10초): 1,000,000건
   - 평균 메시지 처리 시간: `<30ms`

## 6. 장애 허용성 및 내구성

### 6.1 장애 시나리오 및 대응 전략

1. **노드 장애**:

   - libcluster를 통한 장애 감지
   - 작업 재분배
   - 자동 재시작

2. **데이터베이스 장애**:

   - 복제본으로 자동 장애 조치
   - 연결 풀 재구성
   - 일시적 오류 자동 재시도

3. **외부 서비스 장애**:

   - 서비스별 상태 모니터링
   - 지수 백오프 재시도
   - 장애 서비스 우회

4. **네트워크 장애**:
   - 연결 재시도
   - 타임아웃 관리
   - 메시지 큐 지속성

### 6.2 데이터 내구성

1. **메시지 내구성**:

   - 메시지 전송 전 데이터베이스 저장
   - 작업 큐에서 메시지 영속성 보장
   - 실패 시 상태 및 오류 정보 기록

2. **백업 전략**:

   - 일일 전체 백업
   - 시간별 증분 백업
   - 지리적으로 분산된 백업 저장

3. **복구 전략**:
   - 메시지 재처리 기능
   - 작업 큐 복구
   - 지점 복구 지원

### 6.3 분산 시스템 설계

1. **노드 간 조정**:

   - Phoenix PubSub 기반 분산 이벤트
   - 일관된 해싱을 통한 작업 라우팅
   - 캠페인 처리 조정

2. **상태 공유**:

   - 분산 ETS 테이블
   - 중앙 데이터베이스 상태 저장소
   - 분산 카운터 및 집계

3. **글로벌 분산**:
   - 지역별 클러스터 구성
   - 지역 간 통신 최적화
   - 지역 장애 격리

## 7. 보안 아키텍처

### 7.1 인증 및 권한 부여

1. **API 인증**:

   - API 키 기반 인증
   - 키 순환 및 관리
   - 권한 범위 제한

2. **내부 인증**:

   - 노드 간 쿠키 기반 인증
   - 서비스 계정 인증
   - 데이터베이스 접근 제어

3. **사용자 인증**:
   - 애플리케이션 관리자 인증
   - 역할 기반 접근 제어
   - 세션 관리

### 7.2 데이터 보안

1. **저장 데이터 보안**:

   - ash_cloak을 통한 민감 데이터 암호화
   - 토큰 및 개인 정보 암호화
   - 암호화 키 관리

2. **전송 데이터 보안**:

   - TLS/SSL 통신
   - API 페이로드 암호화
   - 안전한 키 교환

3. **보안 정책**:
   - 최소 권한 원칙
   - 정기적인 보안 감사
   - 취약점 관리

### 7.3 규제 준수

1. **GDPR 준수**:

   - 개인 정보 최소화
   - 명시적 동의 관리
   - 삭제 요청 처리

2. **데이터 보존 정책**:

   - 목적별 보존 기간 설정
   - 자동 데이터 만료
   - 보존 정책 시행 자동화

3. **감사 추적**:
   - 주요 작업 로깅
   - 권한 변경 추적
   - 보안 이벤트 모니터링

## 8. 모니터링 및 운영

### 8.1 모니터링 아키텍처

1. **시스템 모니터링**:

   - CPU, 메모리, 디스크, 네트워크 모니터링
   - 노드 상태 모니터링
   - 데이터베이스 성능 모니터링

2. **애플리케이션 모니터링**:

   - 요청 처리량 및 응답 시간
   - 작업 큐 길이 및 처리 시간
   - 오류율 및 유형

3. **비즈니스 지표**:
   - 메시지 전송률
   - 전환율 (수신→열람)
   - 채널별 성과 비교

### 8.2 로깅 전략

1. **로그 수준**:

   - debug: 개발용 상세 정보
   - info: 일반 작업 정보
   - warn: 잠재적 문제
   - error: 처리되지 않은 오류

2. **로그 형식**:

   - JSON 구조화 로그
   - 표준 필드 집합
   - 컨텍스트 데이터 포함

3. **로그 수집 및 분석**:
   - 중앙 로그 저장소
   - 실시간 로그 분석
   - 로그 기반 알림

### 8.3 운영 도구

1. **관리 인터페이스**:

   - 시스템 상태 대시보드
   - 작업 큐 관리
   - 수동 개입 도구

2. **배포 도구**:

   - 무중단 배포
   - 롤백 메커니즘
   - 점진적 롤아웃

3. **문제 해결 도구**:
   - 실시간 로그 조회
   - 트레이스 도구
   - 성능 프로파일링

## 9. 인프라 요구사항

### 9.1 컴퓨팅 요구사항

1. **개발 환경**:

   - 1-2 Elixir 노드
   - 1 PostgreSQL 인스턴스

2. **테스트 환경**:

   - 2-4 Elixir 노드
   - 2 PostgreSQL 인스턴스 (기본/복제본)

3. **프로덕션 환경**:
   - 12+ Elixir 노드 (3개 리전 × 4+ 노드)
   - PostgreSQL 클러스터 (각 리전에 복제본)

### 9.2 네트워크 요구사항

1. **대역폭**:

   - 노드 간: 최소 1Gbps
   - 외부: 최소 500Mbps

2. **지연 시간**:

   - 노드 간: `<5ms` (리전 내)
   - 리전 간: `<100ms`
   - 데이터베이스: `<10ms`

3. **네트워크 보안**:
   - 노드 간 암호화 통신
   - 방화벽 구성
   - DDoS 보호

### 9.3 저장소 요구사항

1. **데이터베이스 크기**:

   - 초기: 50GB
   - 연간 증가: 약 500GB

2. **백업 저장소**:

   - 일일 백업: 최소 2TB
   - 보존 기간: 90일

3. **로그 저장소**:
   - 일일 로그 볼륨: 약 10GB
   - 보존 기간: 30일

## 10. 개발 및 배포 프로세스

### 10.1 개발 프로세스

1. **코드 관리**:

   - Git 저장소
   - 브랜치 전략 (Git Flow)
   - 코드 리뷰 프로세스

2. **테스트 방법론**:

   - 단위 테스트 (ExUnit)
   - 통합 테스트
   - 성능 테스트
   - 부하 테스트

3. **문서화**:
   - 코드 문서화 (ExDoc)
   - API 문서화
   - 아키텍처 문서화

### 10.2 배포 프로세스

1. **배포 파이프라인**:

   - CI/CD 도구: GitHub Actions
   - 빌드 및 테스트 자동화
   - 자동 배포

2. **배포 전략**:

   - 무중단 배포
   - 점진적 롤아웃
   - 블루-그린 배포

3. **환경 관리**:
   - 설정 관리
   - 환경별 변수
   - 비밀 관리

## 11. 진화 전략

### 11.1 새로운 채널 추가

새로운 메시징 채널 추가를 위한 아키텍처 확장 방법:

1. **어댑터 구현**:

   - 새 채널 어댑터 구현
   - ChannelAdapter 인터페이스 준수
   - 채널별 오류 처리 구현

2. **리소스 확장**:

   - Subscription 유형 확장
   - 채널별 상태 코드 추가
   - 채널별 메타데이터 정의

3. **플로우 통합**:
   - 메시지 처리 흐름에 통합
   - 상태 추적 확장
   - 분석 지표 추가

### 11.2 확장성 로드맵

향후 규모 확장을 위한 아키텍처 전략:

1. **Phase 1**: 단일 리전 최적화

   - 성능 튜닝
   - 모니터링 개선
   - 자동 확장

2. **Phase 2**: 다중 리전 확장

   - 글로벌 배포
   - 리전 간 조정
   - 지역 장애 격리

3. **Phase 3**: 초대규모 확장
   - 데이터베이스 샤딩
   - 고급 캐싱 전략
   - 메시지 라우팅 최적화

### 11.3 기술 부채 관리

지속적인 아키텍처 개선을 위한 전략:

1. **정기적인 리팩토링**:

   - 계획된 리팩토링 주기
   - 기술 부채 측정
   - 점진적 개선

2. **아키텍처 리뷰**:

   - 분기별 아키텍처 검토
   - 병목 지점 식별
   - 개선 우선순위 설정

3. **기술 혁신**:
   - 새로운 기술 평가
   - 개념 증명 개발
   - 점진적 기술 도입

---

// File: automata-signal/2-designs/DESIGN-003-data-model

# [DESIGN-003] 데이터 모델

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [DESIGN-001] 아키텍처 개요
- [DESIGN-002] 시스템 아키텍처
- [REF-002] 상태 코드
- [COMP-002] 어댑터 시스템

## 요약

본 문서는 Automata-Signal 시스템의 데이터 모델을 상세히 설명합니다. Ash Framework를 사용하여 구현된 핵심 리소스, 그들의 속성, 관계 및 비즈니스 규칙을 포함합니다.

## 대상 독자

- 백엔드 개발자
- 데이터베이스 관리자
- 시스템 아키텍트
- API 개발자

## 1. 개념적 데이터 모델

### 1.1 개체 관계 다이어그램

Automata-Signal 시스템의 핵심 데이터 모델을 개체-관계 다이어그램으로 표현합니다:

```mermaid
erDiagram
    APPLICATION ||--o{ USER : "has"
    APPLICATION ||--o{ SUBSCRIPTION : "has"
    APPLICATION ||--o{ MESSAGE : "sends"
    APPLICATION ||--o{ SUBSCRIPTION_EVENT : "has"
    APPLICATION ||--o{ MESSAGE_QUOTA : "has"
    APPLICATION ||--o{ MESSAGE_TEMPLATE : "has"
    APPLICATION ||--o{ MESSAGE_CAMPAIGN : "has"
    USER ||--o{ SUBSCRIPTION : "has"
    USER ||--o{ MESSAGE : "receives"
    SUBSCRIPTION ||--o{ MESSAGE : "receives"
    MESSAGE ||--o{ MESSAGE_EVENT : "generates"
    USER ||--o{ SUBSCRIPTION_EVENT : "has"
    SUBSCRIPTION ||--o{ SUBSCRIPTION_EVENT : "has"
    MESSAGE_TEMPLATE ||--o{ MESSAGE_CAMPAIGN : "used_by"
    MESSAGE_CAMPAIGN ||--o{ MESSAGE : "generates"
```

### 1.2 상세 ERD

시스템의 주요 엔티티와 모든 필드를 포함한 상세 ERD입니다:

```mermaid
erDiagram
    APPLICATION {
        uuid id PK
        string name
        string api_key
        jsonb settings
        datetime created_at
        datetime updated_at
        boolean is_active
    }

    USER {
        uuid id PK
        string external_id
        uuid application_id FK
        datetime created_at
        datetime last_active_at
        boolean is_archived
        datetime archived_at
    }
    %% Note: (external_id, application_id) must be unique

    SUBSCRIPTION {
        uuid id PK
        string token
        enum type
        uuid user_id FK
        uuid application_id FK
        string device_model
        string device_os
        string device_language
        string app_version
        string sdk_version
        string country_code
        integer test_type
        jsonb tags
        integer subscription_status
        datetime subscribed_at
        datetime unsubscribed_at
        datetime last_active_at
        int total_messages_received
        int total_messages_converted
        boolean is_archived
        datetime archived_at
    }

    MESSAGE {
        uuid id PK
        string title
        string body
        jsonb data
        uuid user_id FK
        uuid subscription_id FK
        uuid application_id FK
        uuid campaign_id FK
        enum status
        enum channel_type
        datetime created_at
        datetime updated_at
        datetime sent_at
        datetime received_at
        datetime converted_at
        datetime failed_at
        string error_reason
        jsonb error_details
        jsonb version_history
    }

    MESSAGE_EVENT {
        uuid id PK
        uuid message_id FK
        enum event_type
        datetime occurred_at
        jsonb metadata
        jsonb version_history
    }

    SUBSCRIPTION_EVENT {
        uuid id PK
        uuid user_id FK
        uuid subscription_id FK
        uuid application_id FK
        enum event_type
        string channel
        string source
        string reason
        datetime occurred_at
    }

    MESSAGE_TEMPLATE {
        uuid id PK
        uuid application_id FK
        string name
        string title_template
        string body_template
        jsonb data_template
        string description
        datetime created_at
        datetime updated_at
        boolean is_active
        int version
    }

    MESSAGE_CAMPAIGN {
        uuid id PK
        uuid application_id FK
        uuid template_id FK
        string name
        string title
        string body
        jsonb data
        enum campaign_type
        datetime scheduled_at
        datetime created_at
        datetime updated_at
        datetime sent_at
        string created_by
        jsonb targeting_criteria
        int total_recipients
        int successful_count
        int failed_count
        enum status
    }

    MESSAGE_QUOTA {
        uuid id PK
        uuid application_id FK
        int daily_quota
        int monthly_quota
        int daily_used
        int monthly_used
        datetime reset_date
        decimal unit_price
        decimal credit_balance
        string billing_currency
    }

    OBAN_JOBS {
        bigserial id PK
        string state
        string queue
        string worker
        jsonb args
        jsonb[] errors
        int attempt
        int max_attempts
        datetime inserted_at
        datetime scheduled_at
        datetime completed_at
        datetime attempted_at
        datetime cancelled_at
        datetime discarded_at
        int priority
        string[] tags
        jsonb meta
    }

    APPLICATION ||--o{ USER : "has"
    APPLICATION ||--o{ SUBSCRIPTION : "has"
    APPLICATION ||--o{ MESSAGE : "sends"
    APPLICATION ||--o{ SUBSCRIPTION_EVENT : "has"
    APPLICATION ||--o{ MESSAGE_QUOTA : "has"
    APPLICATION ||--o{ MESSAGE_TEMPLATE : "has"
    APPLICATION ||--o{ MESSAGE_CAMPAIGN : "has"
    USER ||--o{ SUBSCRIPTION : "has"
    USER ||--o{ MESSAGE : "receives"
    SUBSCRIPTION ||--o{ MESSAGE : "receives"
    MESSAGE ||--o{ MESSAGE_EVENT : "generates"
    USER ||--o{ SUBSCRIPTION_EVENT : "has"
    SUBSCRIPTION ||--o{ SUBSCRIPTION_EVENT : "has"
    MESSAGE_TEMPLATE ||--o{ MESSAGE_CAMPAIGN : "used_by"
    MESSAGE_CAMPAIGN ||--o{ MESSAGE : "generates"
```

## 2. 핵심 리소스 정의

Automata-Signal 시스템은 다음과 같은 핵심 리소스로 구성됩니다.

### 2.1 Application

메시징 서비스를 사용하는, 시스템에 등록된 애플리케이션을 나타냅니다.

```elixir
defmodule AutomataSignal.Resources.Application do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres

  attributes do
    uuid_primary_key :id

    attribute :name, :string do
      constraints [
        required: true,
        min_length: 1,
        max_length: 100
      ]
    end

    attribute :api_key, :string do
      constraints [required: true]
      sensitive? true
    end

    attribute :settings, :map, default: %{}

    timestamps()

    attribute :is_active, :boolean, default: true
  end

  relationships do
    has_many :users, AutomataSignal.Resources.User
    has_many :subscriptions, AutomataSignal.Resources.Subscription
    has_many :messages, AutomataSignal.Resources.Message
    has_many :templates, AutomataSignal.Resources.MessageTemplate
    has_many :campaigns, AutomataSignal.Resources.MessageCampaign
    has_one :quota, AutomataSignal.Resources.MessageQuota
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  # ... 추가 액션 및 정책 ...
end
```

**핵심 속성**:

- `id`: 애플리케이션의 고유 식별자 (UUID)
- `name`: 애플리케이션 이름
- `api_key`: API 호출 인증에 사용되는 키
- `settings`: 애플리케이션별 설정 (JSON/Map)
- `is_active`: 애플리케이션 활성화 상태

### 2.2 User

애플리케이션의 사용자(최종 사용자)를 나타냅니다.

```elixir
defmodule AutomataSignal.Resources.User do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [AshArchival.Resource]

  attributes do
    uuid_primary_key :id

    attribute :external_id, :string do
      constraints [required: true]
    end

    attribute :application_id, :uuid do
      constraints [required: true]
    end

    attribute :created_at, :utc_datetime
    attribute :last_active_at, :utc_datetime
  end

  relationships do
    belongs_to :application, AutomataSignal.Resources.Application
    has_many :subscriptions, AutomataSignal.Resources.Subscription
    has_many :messages, AutomataSignal.Resources.Message
  end

  # 아카이빙(논리적 삭제) 설정
  archival do
    archive_attribute :is_archived
    archive_timestamp_attribute :archived_at
  end

  # 복합 유니크 제약조건
  postgres do
    table "users"
    repo AutomataSignal.Repo

    unique_index [:external_id, :application_id]
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end

  # ... 추가 액션 및 정책 ...
end
```

**핵심 속성**:

- `id`: 내부 사용자 ID (UUID)
- `external_id`: 애플리케이션에서 사용하는 외부 사용자 ID
- `application_id`: 사용자가 속한 애플리케이션
- `created_at`: 사용자 생성 시간
- `last_active_at`: 마지막 활동 시간
- `is_archived`: 아카이빙(논리적 삭제) 상태

**중요 제약조건**:

- `external_id`와 `application_id`의 조합은 유일해야 함 (한 애플리케이션 내에서 사용자 식별자는 고유해야 함)

### 2.3 Subscription

사용자의 메시징 채널 구독 정보를 나타냅니다.

```elixir
defmodule AutomataSignal.Resources.Subscription do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [
      AshArchival.Resource,
      AshCloak.Resource
    ]

  attributes do
    uuid_primary_key :id

    attribute :token, :string, sensitive?: true do
      constraints [required: true]
    end

    attribute :type, :atom do
      constraints [
        required: true,
        one_of: [:iOSPush, :AndroidPush, :Email, :SMS, :KakaoTalk, :InAppMessage]
      ]
    end

    attribute :user_id, :uuid
    attribute :application_id, :uuid, allow_nil?: false

    # 디바이스 메타데이터 (푸시 알림 구독인 경우)
    attribute :device_model, :string
    attribute :device_os, :string
    attribute :device_language, :string
    attribute :app_version, :string
    attribute :sdk_version, :string
    attribute :country_code, :string
    attribute :test_type, :integer, default: 0

    # 구독 상태 관련 필드
    attribute :subscription_status, :integer, default: 0
    attribute :subscribed_at, :utc_datetime
    attribute :unsubscribed_at, :utc_datetime

    # 태그 (세그먼테이션 용도)
    attribute :tags, :map, default: %{}

    # 통계 지표
    attribute :last_active_at, :utc_datetime
    attribute :total_messages_received, :integer, default: 0
    attribute :total_messages_converted, :integer, default: 0
  end

  # 민감 데이터 암호화
  encrypted_attributes do
    attribute :token
  end

  relationships do
    belongs_to :user, AutomataSignal.Resources.User
    belongs_to :application, AutomataSignal.Resources.Application
    has_many :messages, AutomataSignal.Resources.Message
    has_many :subscription_events, AutomataSignal.Resources.SubscriptionEvent
  end

  # 아카이빙(논리적 삭제) 설정
  archival do
    archive_attribute :is_archived
    archive_timestamp_attribute :archived_at
  end

  # 계산된 속성
  calculations do
    calculate :is_push_channel, :boolean, expr: expr(type in [:iOSPush, :AndroidPush])
    calculate :is_messaging_channel, :boolean, expr: expr(type in [:Email, :SMS, :KakaoTalk])
    calculate :is_in_app_channel, :boolean, expr: expr(type == :InAppMessage)

    calculate :is_subscribed, :boolean, expr: expr(subscription_status > 0)
    calculate :is_unsubscribed, :boolean, expr: expr(subscription_status == -2 or subscription_status == -31)
    calculate :has_error, :boolean, expr: expr(subscription_status < -2 and subscription_status != -31 and subscription_status != -99)
    calculate :error_code_range, :string, expr: expr(
      cond do
        subscription_status >= -24 and subscription_status <= -3 -> "push_error"
        subscription_status >= -49 and subscription_status <= -40 -> "email_error"
        subscription_status >= -59 and subscription_status <= -50 -> "sms_error"
        subscription_status >= -69 and subscription_status <= -60 -> "kakao_error"
        subscription_status >= -79 and subscription_status <= -70 -> "in_app_error"
        true -> "other"
      end
    )
  end

  actions do
    defaults [:create, :read, :update, :destroy]

    create :register do
      accept [:token, :type, :user_id, :application_id, :device_model, :device_os, :device_language, :app_version, :sdk_version, :country_code, :test_type]
      change set_attribute(:subscription_status, 1)
      change set_attribute(:subscribed_at, &DateTime.utc_now/0)
    end

    update :unsubscribe do
      accept []
      change set_attribute(:subscription_status, -2)
      change set_attribute(:unsubscribed_at, &DateTime.utc_now/0)
    end

    update :add_tags do
      accept [:tags]
      argument :new_tags, :map do
        allow_nil? false
      end

      change fn changeset, _ ->
        current_tags = Ash.Changeset.get_attribute(changeset, :tags) || %{}
        new_tags = Ash.Changeset.get_argument(changeset, :new_tags)

        Ash.Changeset.set_attribute(changeset, :tags, Map.merge(current_tags, new_tags))
      end
    end
  end
end
```

**핵심 속성**:

- `id`: 구독의 고유 식별자 (UUID)
- `token`: 채널 토큰 (푸시 토큰, 이메일 주소, 전화번호 등)
- `type`: 구독 채널 유형 (iOSPush, AndroidPush, Email, SMS, KakaoTalk, InAppMessage)
- `user_id`: 연결된 사용자 ID (익명 사용자의 경우 null 가능)
- `application_id`: 연결된 애플리케이션 ID
- 디바이스 정보 (device_model, device_os 등)
- `subscription_status`: 구독 상태 코드
- `tags`: 세그먼테이션을 위한 키-값 태그

**중요 상태 코드**:

- 양수 값(1 이상): 구독 활성화 상태
- 0, -99: 초기 상태 (구독된 적 없음)
- -2: 사용자에 의한 구독 취소
- -31: API를 통해 비활성화됨
- -3 ~ -24: 푸시 알림 관련 오류
- -40 ~ -49: 이메일 관련 오류
- -50 ~ -59: SMS 관련 오류
- -60 ~ -69: 카카오톡 관련 오류
- -70 ~ -79: 인앱 메시지 관련 오류

### 2.4 Message

사용자에게 전송된 개별 메시지를 나타냅니다.

```elixir
defmodule AutomataSignal.Resources.Message do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [AshStateMachine.Resource]

  attributes do
    uuid_primary_key :id

    # 메시지 내용
    attribute :title, :string
    attribute :body, :string
    attribute :data, :map, default: %{}

    # 관계 식별자
    attribute :user_id, :uuid
    attribute :subscription_id, :uuid
    attribute :application_id, :uuid
    attribute :campaign_id, :uuid, allow_nil?: true

    # 상태 추적
    attribute :status, :atom do
      constraints [
        one_of: [:pending, :successful, :failed, :errored, :received, :converted]
      ]
      default :pending
    end

    attribute :channel_type, :atom do
      constraints [
        one_of: [:push, :email, :sms, :kakao_talk, :in_app]
      ]
    end

    # 타임스탬프
    timestamps()
    attribute :sent_at, :utc_datetime
    attribute :received_at, :utc_datetime
    attribute :converted_at, :utc_datetime
    attribute :failed_at, :utc_datetime

    # 오류 정보
    attribute :error_reason, :string
    attribute :error_details, :map, default: %{}

    # 이력 추적
    attribute :version_history, :map, default: %{}
  end

  # 상태 머신 정의
  state_machine do
    field :status

    initial_states [:pending]

    transitions do
      transition :send, from: [:pending], to: :successful
      transition :fail, from: [:pending, :successful], to: :failed
      transition :error, from: [:pending], to: :errored
      transition :retry, from: [:errored], to: :pending
      transition :receive, from: [:successful], to: :received
      transition :convert, from: [:received], to: :converted
    end

    on_transition :send do
      set_attribute :sent_at, &DateTime.utc_now/0
    end

    on_transition :fail do
      set_attribute :failed_at, &DateTime.utc_now/0
    end

    on_transition :receive do
      set_attribute :received_at, &DateTime.utc_now/0
    end

    on_transition :convert do
      set_attribute :converted_at, &DateTime.utc_now/0
    end
  end

  relationships do
    belongs_to :user, AutomataSignal.Resources.User
    belongs_to :subscription, AutomataSignal.Resources.Subscription
    belongs_to :application, AutomataSignal.Resources.Application
    belongs_to :campaign, AutomataSignal.Resources.MessageCampaign, allow_nil?: true
    has_many :events, AutomataSignal.Resources.MessageEvent
  end

  actions do
    defaults [:create, :read, :update]

    create :send_message do
      accept [:title, :body, :data, :user_id, :subscription_id, :application_id, :campaign_id, :channel_type]

      argument :use_template, :boolean, default: false
      argument :template_id, :uuid
      argument :template_variables, :map, default: %{}

      change fn changeset, _ ->
        if Ash.Changeset.get_argument(changeset, :use_template) do
          template_id = Ash.Changeset.get_argument(changeset, :template_id)
          variables = Ash.Changeset.get_argument(changeset, :template_variables)

          # 템플릿 렌더링 로직
          # ...
        else
          changeset
        end
      end
    end

    update :mark_as_sent do
      accept [:error_reason, :error_details]

      change transition_state(:send)
    end

    update :mark_as_failed do
      accept [:error_reason, :error_details]

      change transition_state(:fail)
    end

    update :mark_as_received do
      accept []

      change transition_state(:receive)
      change increment_subscription_counter(:total_messages_received)
    end

    update :mark_as_converted do
      accept []

      change transition_state(:convert)
      change increment_subscription_counter(:total_messages_converted)
    end
  end

  defp increment_subscription_counter(changeset, field) do
    # 구독의 카운터 필드를 증가시키는 로직
    # ...
  end
end
```

**핵심 속성**:

- `id`: 메시지의 고유 식별자 (UUID)
- `title`, `body`: 메시지 제목과 본문
- `data`: 추가 데이터 (JSON/Map)
- `user_id`, `subscription_id`, `application_id`: 관계 식별자
- `campaign_id`: 캠페인에 의해 생성된 경우 캠페인 ID
- `status`: 메시지 상태 (pending, successful, failed, errored, received, converted)
- `channel_type`: 채널 유형 (push, email, sms, kakao_talk, in_app)
- 시간 추적: `sent_at`, `received_at`, `converted_at`, `failed_at`
- `error_reason`, `error_details`: 오류 정보

**메시지 상태**:

- `pending`: 메시지가 생성되고 전송을 기다리는 상태
- `successful`: 외부 서비스에 성공적으로 전송됨
- `failed`: 메시지 전송이 실패함
- `errored`: 일시적인 오류로 재시도 가능한 상태
- `received`: 사용자 기기에 도달하여 수신됨
- `converted`: 사용자가 메시지를 열람하거나 상호작용함

### 2.5 MessageEvent

메시지 상태 변경 이벤트를 추적하는 리소스입니다.

```elixir
defmodule AutomataSignal.Resources.MessageEvent do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [AshPaperTrail.Resource]

  attributes do
    uuid_primary_key :id

    attribute :message_id, :uuid, allow_nil?: false

    attribute :event_type, :atom do
      constraints [
        one_of: [:created, :sent, :received, :converted, :failed, :errored, :retried]
      ]
    end

    attribute :occurred_at, :utc_datetime
    attribute :metadata, :map, default: %{}
  end

  relationships do
    belongs_to :message, AutomataSignal.Resources.Message
  end

  # 변경 이력 추적 설정
  paper_trail do
    track_attribute :event_type
    track_attribute :metadata
  end

  actions do
    defaults [:create, :read]
  end
end
```

**핵심 속성**:

- `id`: 이벤트 고유 식별자 (UUID)
- `message_id`: 연결된 메시지 ID
- `event_type`: 이벤트 유형
- `occurred_at`: 이벤트 발생 시간
- `metadata`: 이벤트 관련 추가 정보

### 2.6 SubscriptionEvent

구독 상태 변경 이벤트를 추적하는 리소스입니다.

```elixir
defmodule AutomataSignal.Resources.SubscriptionEvent do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres

  attributes do
    uuid_primary_key :id

    attribute :user_id, :uuid
    attribute :subscription_id, :uuid, allow_nil?: false
    attribute :application_id, :uuid, allow_nil?: false

    attribute :event_type, :atom do
      constraints [
        one_of: [:created, :subscribed, :unsubscribed, :error, :token_updated, :user_linked, :user_unlinked]
      ]
    end

    attribute :channel, :string
    attribute :source, :string
    attribute :reason, :string
    attribute :occurred_at, :utc_datetime
  end

  relationships do
    belongs_to :user, AutomataSignal.Resources.User
    belongs_to :subscription, AutomataSignal.Resources.Subscription
    belongs_to :application, AutomataSignal.Resources.Application
  end

  actions do
    defaults [:create, :read]
  end
end
```

**핵심 속성**:

- `id`: 이벤트 고유 식별자 (UUID)
- `user_id`, `subscription_id`, `application_id`: 관계 식별자
- `event_type`: 이벤트 유형
- `channel`: 채널 정보
- `source`: 이벤트 소스
- `reason`: 이벤트 발생 이유
- `occurred_at`: 이벤트 발생 시간

### 2.7 MessageTemplate

재사용 가능한 메시지 템플릿을 나타냅니다.

```elixir
defmodule AutomataSignal.Resources.MessageTemplate do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres

  attributes do
    uuid_primary_key :id

    attribute :application_id, :uuid, allow_nil?: false

    attribute :name, :string do
      constraints [required: true]
    end

    attribute :title_template, :string
    attribute :body_template, :string
    attribute :data_template, :map, default: %{}

    attribute :description, :string

    timestamps()

    attribute :is_active, :boolean, default: true
    attribute :version, :integer, default: 1
  end

  relationships do
    belongs_to :application, AutomataSignal.Resources.Application
    has_many :campaigns, AutomataSignal.Resources.MessageCampaign
  end

  actions do
    defaults [:create, :read, :update, :destroy]
  end
end
```

**핵심 속성**:

- `id`: 템플릿 고유 식별자 (UUID)
- `application_id`: 연결된 애플리케이션 ID
- `name`: 템플릿 이름
- `title_template`, `body_template`: 제목 및 본문 템플릿 문자열
- `data_template`: 추가 데이터 템플릿 (JSON/Map)
- `version`: 템플릿 버전

### 2.8 MessageCampaign

대량 메시지 발송 캠페인을 나타냅니다.

```elixir
defmodule AutomataSignal.Resources.MessageCampaign do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres

  attributes do
    uuid_primary_key :id

    attribute :application_id, :uuid, allow_nil?: false
    attribute :template_id, :uuid

    attribute :name, :string do
      constraints [required: true]
    end

    attribute :title, :string
    attribute :body, :string
    attribute :data, :map, default: %{}

    attribute :campaign_type, :atom do
      constraints [
        one_of: [:immediate, :scheduled, :triggered]
      ]
      default :immediate
    end

    attribute :scheduled_at, :utc_datetime

    timestamps()

    attribute :sent_at, :utc_datetime
    attribute :created_by, :string

    attribute :targeting_criteria, :map, default: %{}

    attribute :total_recipients, :integer, default: 0
    attribute :successful_count, :integer, default: 0
    attribute :failed_count, :integer, default: 0

    attribute :status, :atom do
      constraints [
        one_of: [:draft, :scheduled, :in_progress, :completed, :cancelled, :failed]
      ]
      default :draft
    end
  end

  relationships do
    belongs_to :application, AutomataSignal.Resources.Application
    belongs_to :template, AutomataSignal.Resources.MessageTemplate
    has_many :messages, AutomataSignal.Resources.Message
  end

  actions do
    defaults [:create, :read, :update]

    update :schedule do
      accept [:scheduled_at]

      change fn changeset, _ ->
        Ash.Changeset.set_attribute(changeset, :status, :scheduled)
      end
    end

    update :execute do
      accept []

      change fn changeset, _ ->
        Ash.Changeset.set_attribute(changeset, :status, :in_progress)
      end
    end

    update :complete do
      accept [:successful_count, :failed_count]

      change fn changeset, _ ->
        Ash.Changeset.set_attribute(changeset, :status, :completed)
        Ash.Changeset.set_attribute(changeset, :sent_at, DateTime.utc_now())
      end
    end

    update :cancel do
      accept []

      change fn changeset, _ ->
        Ash.Changeset.set_attribute(changeset, :status, :cancelled)
      end
    end
  end
end
```

**핵심 속성**:

- `id`: 캠페인 고유 식별자 (UUID)
- `application_id`: 연결된 애플리케이션 ID
- `template_id`: 사용할 템플릿 ID
- `name`: 캠페인 이름
- `campaign_type`: 캠페인 유형 (immediate, scheduled, triggered)
- `scheduled_at`: 예약 전송 시간
- `targeting_criteria`: 대상 사용자 필터링 조건 (JSON/Map)
- `status`: 캠페인 상태
- `successful_count`, `failed_count`: 성공/실패 메시지 수

### 2.9 MessageQuota

애플리케이션별 메시지 할당량 및 사용량을 추적합니다.

```elixir
defmodule AutomataSignal.Resources.MessageQuota do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [
      AshMoney.Resource,
      AshDoubleEntry.Resource
    ]

  attributes do
    uuid_primary_key :id

    attribute :application_id, :uuid, allow_nil?: false

    attribute :daily_quota, :integer
    attribute :monthly_quota, :integer

    attribute :daily_used, :integer, default: 0
    attribute :monthly_used, :integer, default: 0

    attribute :reset_date, :utc_datetime

    # 과금 관련 필드
    attribute :unit_price, :money
    attribute :credit_balance, :money, default: 0
    attribute :billing_currency, :string, default: "KRW"
  end

  relationships do
    belongs_to :application, AutomataSignal.Resources.Application
  end

  # 이중 원장 설정
  double_entry do
    account :daily_usage do
      change_attribute :daily_used
      credit_type :increase
      debit_type :decrease
    end

    account :monthly_usage do
      change_attribute :monthly_used
      credit_type :increase
      debit_type :decrease
    end

    account :credit_balance do
      change_attribute :credit_balance
      credit_type :increase
      debit_type :decrease
    end
  end

  actions do
    defaults [:read, :update]

    update :add_usage do
      argument :count, :integer do
        allow_nil? false
      end

      change fn changeset, _ ->
        count = Ash.Changeset.get_argument(changeset, :count)

        changeset
        |> Ash.Changeset.double_entry_credit(:daily_usage, count)
        |> Ash.Changeset.double_entry_credit(:monthly_usage, count)
      end
    end

    update :reset_daily do
      change fn changeset, _ ->
        Ash.Changeset.set_attribute(changeset, :daily_used, 0)
      end
    end

    update :reset_monthly do
      change fn changeset, _ ->
        Ash.Changeset.set_attribute(changeset, :monthly_used, 0)
      end
    end

    update :add_credits do
      argument :amount, :decimal do
        allow_nil? false
      end

      change fn changeset, _ ->
        amount = Ash.Changeset.get_argument(changeset, :amount)

        Ash.Changeset.double_entry_credit(changeset, :credit_balance, amount)
      end
    end

    update :use_credits do
      argument :amount, :decimal do
        allow_nil? false
      end

      change fn changeset, _ ->
        amount = Ash.Changeset.get_argument(changeset, :amount)

        Ash.Changeset.double_entry_debit(changeset, :credit_balance, amount)
      end
    end
  end
end
```

**핵심 속성**:

- `id`: 할당량 고유 식별자 (UUID)
- `application_id`: 연결된 애플리케이션 ID
- `daily_quota`, `monthly_quota`: 일일/월간 할당량
- `daily_used`, `monthly_used`: 사용량
- `reset_date`: 다음 리셋 일자
- `unit_price`: 메시지당 단가
- `credit_balance`: 남은 크레딧 잔액

## 3. 데이터베이스 스키마

### 3.1 테이블 구조

PostgreSQL 데이터베이스에 다음과 같은 테이블 구조가 생성됩니다:

```sql
-- 애플리케이션 테이블
CREATE TABLE applications (
  id UUID PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  api_key VARCHAR(255) NOT NULL,
  settings JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE,
  updated_at TIMESTAMP WITH TIME ZONE,
  is_active BOOLEAN DEFAULT TRUE
);

-- 사용자 테이블
CREATE TABLE users (
  id UUID PRIMARY KEY,
  external_id VARCHAR(255) NOT NULL,
  application_id UUID NOT NULL REFERENCES applications(id),
  created_at TIMESTAMP WITH TIME ZONE,
  last_active_at TIMESTAMP WITH TIME ZONE,
  is_archived BOOLEAN DEFAULT FALSE,
  archived_at TIMESTAMP WITH TIME ZONE,
  UNIQUE(external_id, application_id)
);

-- 구독 테이블
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY,
  token TEXT NOT NULL,
  type VARCHAR(20) NOT NULL,
  user_id UUID REFERENCES users(id),
  application_id UUID NOT NULL REFERENCES applications(id),
  device_model VARCHAR(255),
  device_os VARCHAR(255),
  device_language VARCHAR(10),
  app_version VARCHAR(20),
  sdk_version VARCHAR(20),
  country_code VARCHAR(10),
  test_type INTEGER DEFAULT 0,
  subscription_status INTEGER DEFAULT 0,
  subscribed_at TIMESTAMP WITH TIME ZONE,
  unsubscribed_at TIMESTAMP WITH TIME ZONE,
  tags JSONB DEFAULT '{}',
  last_active_at TIMESTAMP WITH TIME ZONE,
  total_messages_received INTEGER DEFAULT 0,
  total_messages_converted INTEGER DEFAULT 0,
  is_archived BOOLEAN DEFAULT FALSE,
  archived_at TIMESTAMP WITH TIME ZONE
);

-- 메시지 테이블
CREATE TABLE messages (
  id UUID PRIMARY KEY,
  title TEXT,
  body TEXT,
  data JSONB DEFAULT '{}',
  user_id UUID REFERENCES users(id),
  subscription_id UUID REFERENCES subscriptions(id),
  application_id UUID NOT NULL REFERENCES applications(id),
  campaign_id UUID REFERENCES message_campaigns(id),
  status VARCHAR(20) NOT NULL DEFAULT 'pending',
  channel_type VARCHAR(20) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE,
  updated_at TIMESTAMP WITH TIME ZONE,
  sent_at TIMESTAMP WITH TIME ZONE,
  received_at TIMESTAMP WITH TIME ZONE,
  converted_at TIMESTAMP WITH TIME ZONE,
  failed_at TIMESTAMP WITH TIME ZONE,
  error_reason VARCHAR(255),
  error_details JSONB DEFAULT '{}',
  version_history JSONB DEFAULT '{}'
);

-- 메시지 이벤트 테이블
CREATE TABLE message_events (
  id UUID PRIMARY KEY,
  message_id UUID NOT NULL REFERENCES messages(id),
  event_type VARCHAR(20) NOT NULL,
  occurred_at TIMESTAMP WITH TIME ZONE NOT NULL,
  metadata JSONB DEFAULT '{}'
);

-- 구독 이벤트 테이블
CREATE TABLE subscription_events (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  subscription_id UUID NOT NULL REFERENCES subscriptions(id),
  application_id UUID NOT NULL REFERENCES applications(id),
  event_type VARCHAR(20) NOT NULL,
  channel VARCHAR(20),
  source VARCHAR(50),
  reason VARCHAR(255),
  occurred_at TIMESTAMP WITH TIME ZONE NOT NULL
);

-- 메시지 템플릿 테이블
CREATE TABLE message_templates (
  id UUID PRIMARY KEY,
  application_id UUID NOT NULL REFERENCES applications(id),
  name VARCHAR(100) NOT NULL,
  title_template TEXT,
  body_template TEXT,
  data_template JSONB DEFAULT '{}',
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE,
  updated_at TIMESTAMP WITH TIME ZONE,
  is_active BOOLEAN DEFAULT TRUE,
  version INTEGER DEFAULT 1
);

-- 메시지 캠페인 테이블
CREATE TABLE message_campaigns (
  id UUID PRIMARY KEY,
  application_id UUID NOT NULL REFERENCES applications(id),
  template_id UUID REFERENCES message_templates(id),
  name VARCHAR(100) NOT NULL,
  title TEXT,
  body TEXT,
  data JSONB DEFAULT '{}',
  campaign_type VARCHAR(20) DEFAULT 'immediate',
  scheduled_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE,
  updated_at TIMESTAMP WITH TIME ZONE,
  sent_at TIMESTAMP WITH TIME ZONE,
  created_by VARCHAR(100),
  targeting_criteria JSONB DEFAULT '{}',
  total_recipients INTEGER DEFAULT 0,
  successful_count INTEGER DEFAULT 0,
  failed_count INTEGER DEFAULT 0,
  status VARCHAR(20) DEFAULT 'draft'
);

-- 메시지 할당량 테이블
CREATE TABLE message_quotas (
  id UUID PRIMARY KEY,
  application_id UUID NOT NULL REFERENCES applications(id) UNIQUE,
  daily_quota INTEGER,
  monthly_quota INTEGER,
  daily_used INTEGER DEFAULT 0,
  monthly_used INTEGER DEFAULT 0,
  reset_date TIMESTAMP WITH TIME ZONE,
  unit_price DECIMAL(10, 2),
  credit_balance DECIMAL(10, 2) DEFAULT 0,
  billing_currency VARCHAR(3) DEFAULT 'KRW'
);

-- Oban 작업 큐 테이블
CREATE TABLE oban_jobs (
  id BIGSERIAL PRIMARY KEY,
  state TEXT NOT NULL DEFAULT 'available',
  queue TEXT NOT NULL DEFAULT 'default',
  worker TEXT NOT NULL,
  args JSONB NOT NULL DEFAULT '{}',
  errors JSONB[] DEFAULT '{}',
  attempt INTEGER NOT NULL DEFAULT 0,
  max_attempts INTEGER NOT NULL DEFAULT 20,
  inserted_at TIMESTAMP WITH TIME ZONE NOT NULL,
  scheduled_at TIMESTAMP WITH TIME ZONE NOT NULL,
  completed_at TIMESTAMP WITH TIME ZONE,
  attempted_at TIMESTAMP WITH TIME ZONE,
  cancelled_at TIMESTAMP WITH TIME ZONE,
  discarded_at TIMESTAMP WITH TIME ZONE,
  priority INTEGER NOT NULL DEFAULT 0,
  tags VARCHAR(255)[] DEFAULT '{}',
  meta JSONB DEFAULT '{}'
);
```

### 3.2 인덱스 전략

성능 최적화를 위한 인덱스 설정:

```sql
-- 사용자 테이블 인덱스
CREATE INDEX users_application_id_idx ON users(application_id);
CREATE INDEX users_external_id_idx ON users(external_id);
CREATE INDEX users_last_active_at_idx ON users(last_active_at);

-- 구독 테이블 인덱스
CREATE INDEX subscriptions_user_id_idx ON subscriptions(user_id);
CREATE INDEX subscriptions_application_id_idx ON subscriptions(application_id);
CREATE INDEX subscriptions_token_idx ON subscriptions(token);
CREATE INDEX subscriptions_type_idx ON subscriptions(type);
CREATE INDEX subscriptions_status_idx ON subscriptions(subscription_status);
CREATE INDEX subscriptions_tags_gin_idx ON subscriptions USING GIN (tags);

-- 메시지 테이블 인덱스
CREATE INDEX messages_user_id_idx ON messages(user_id);
CREATE INDEX messages_subscription_id_idx ON messages(subscription_id);
CREATE INDEX messages_application_id_idx ON messages(application_id);
CREATE INDEX messages_campaign_id_idx ON messages(campaign_id);
CREATE INDEX messages_status_idx ON messages(status);
CREATE INDEX messages_channel_type_idx ON messages(channel_type);
CREATE INDEX messages_created_at_idx ON messages(created_at);

-- 이벤트 테이블 인덱스
CREATE INDEX message_events_message_id_idx ON message_events(message_id);
CREATE INDEX message_events_event_type_idx ON message_events(event_type);
CREATE INDEX message_events_occurred_at_idx ON message_events(occurred_at);

CREATE INDEX subscription_events_subscription_id_idx ON subscription_events(subscription_id);
CREATE INDEX subscription_events_application_id_idx ON subscription_events(application_id);
CREATE INDEX subscription_events_event_type_idx ON subscription_events(event_type);
CREATE INDEX subscription_events_occurred_at_idx ON subscription_events(occurred_at);

-- 캠페인 테이블 인덱스
CREATE INDEX campaigns_application_id_idx ON message_campaigns(application_id);
CREATE INDEX campaigns_template_id_idx ON message_campaigns(template_id);
CREATE INDEX campaigns_status_idx ON message_campaigns(status);
CREATE INDEX campaigns_scheduled_at_idx ON message_campaigns(scheduled_at);

-- Oban 작업 큐 인덱스
CREATE INDEX oban_jobs_state_idx ON oban_jobs(state);
CREATE INDEX oban_jobs_queue_state_idx ON oban_jobs(queue, state);
CREATE INDEX oban_jobs_scheduled_at_idx ON oban_jobs(scheduled_at);
CREATE INDEX oban_jobs_tags_idx ON oban_jobs USING GIN (tags);
```

### 3.3 파티셔닝 전략

메시지 및 이벤트 테이블은 대량의 데이터를 처리하기 위해 파티셔닝을 적용합니다:

```sql
-- 메시지 테이블 파티셔닝 (월별)
CREATE TABLE messages_y2025m04 PARTITION OF messages
  FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');

CREATE TABLE messages_y2025m05 PARTITION OF messages
  FOR VALUES FROM ('2025-05-01') TO ('2025-06-01');

-- 메시지 이벤트 테이블 파티셔닝 (월별)
CREATE TABLE message_events_y2025m04 PARTITION OF message_events
  FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');

CREATE TABLE message_events_y2025m05 PARTITION OF message_events
  FOR VALUES FROM ('2025-05-01') TO ('2025-06-01');

-- 구독 이벤트 테이블 파티셔닝 (월별)
CREATE TABLE subscription_events_y2025m04 PARTITION OF subscription_events
  FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');

CREATE TABLE subscription_events_y2025m05 PARTITION OF subscription_events
  FOR VALUES FROM ('2025-05-01') TO ('2025-06-01');
```

## 4. 데이터 관계 및 제약조건

### 4.1 주요 관계

- **Application-User**: 일대다 관계. 하나의 애플리케이션은 여러 사용자를 가질 수 있음.
- **User-Subscription**: 일대다 관계. 하나의 사용자는 여러 구독을 가질 수 있음.
- **Application-Subscription**: 일대다 관계. 하나의 애플리케이션은 여러 구독을 가질 수 있음.
- **Subscription-Message**: 일대다 관계. 하나의 구독은 여러 메시지를 수신할 수 있음.
- **User-Message**: 일대다 관계. 하나의 사용자는 여러 메시지를 수신할 수 있음.
- **Message-MessageEvent**: 일대다 관계. 하나의 메시지는 여러 이벤트를 생성할 수 있음.
- **Template-Campaign**: 일대다 관계. 하나의 템플릿은 여러 캠페인에서 사용될 수 있음.
- **Campaign-Message**: 일대다 관계. 하나의 캠페인은 여러 메시지를 생성할 수 있음.
- **Application-MessageQuota**: 일대일 관계. 하나의 애플리케이션은 하나의 할당량 설정을 가짐.

### 4.2 중요 제약조건

- **User.external_id + User.application_id**: 복합 유니크 제약조건. 애플리케이션 내에서 사용자 식별자는 고유해야 함.
- **Application-MessageQuota**: 일대일 제약조건. 애플리케이션당 하나의 할당량 설정만 허용.
- **Foreign Key 제약조건**: 모든 관계는 외래 키 제약조건으로 보호됨.
- **NOT NULL 제약조건**: 핵심 필드는 NULL 값을 허용하지 않음 (application_id, token, type 등).
- **Enum 제약조건**: 상태, 유형 등의 필드는 미리 정의된 값만 허용.

## 5. 데이터 마이그레이션 및 진화

### 5.1 스키마 변경 전략

1. **점진적 마이그레이션**: 하위 호환성을 유지하면서 점진적인 스키마 변경
2. **롤백 계획**: 모든 마이그레이션에 롤백 계획 포함
3. **무중단 마이그레이션**: 서비스 중단 없이 스키마 변경 수행

### 5.2 마이그레이션 가이드라인

새로운 필드 추가:

```elixir
# 마이그레이션 예시
defmodule AutomataSignal.Repo.Migrations.AddDeviceLanguageToSubscription do
  use Ecto.Migration

  def change do
    alter table(:subscriptions) do
      add :device_language, :string, size: 10
    end
  end
end
```

필드 유형 변경:

```elixir
# 마이그레이션 예시
defmodule AutomataSignal.Repo.Migrations.ChangeStatusToEnum do
  use Ecto.Migration

  def up do
    # 임시 컬럼 추가
    alter table(:messages) do
      add :status_new, :message_status
    end

    # 데이터 복사
    execute """
    UPDATE messages
    SET status_new = status::message_status
    """

    # 기존 컬럼 삭제 및 이름 변경
    alter table(:messages) do
      remove :status
      rename :status_new, to: :status
    end
  end

  def down do
    # 롤백 로직
    # ...
  end
end
```

테이블 파티셔닝:

```elixir
defmodule AutomataSignal.Repo.Migrations.PartitionMessagesTable do
  use Ecto.Migration

  def up do
    # 임시 테이블 생성
    execute """
    CREATE TABLE messages_new (
      id UUID NOT NULL,
      -- 다른 필드들...
      created_at TIMESTAMP WITH TIME ZONE NOT NULL
    ) PARTITION BY RANGE (created_at);
    """

    # 기존 데이터 복사
    execute "INSERT INTO messages_new SELECT * FROM messages"

    # 파티션 생성
    execute """
    CREATE TABLE messages_y2025m04 PARTITION OF messages_new
      FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');
    """

    # 테이블 교체
    execute "DROP TABLE messages"
    execute "ALTER TABLE messages_new RENAME TO messages"
  end

  def down do
    # 롤백 로직
    # ...
  end
end
```

### 5.3 버전 관리

1. **스키마 버전 추적**: 데이터베이스 스키마 버전 명시적 추적
2. **마이그레이션 릴리스 계획**: 마이그레이션과 코드 릴리스 조정
3. **이전 버전 호환성**: 필요한 경우 이전 버전 스키마와의 호환성 유지

## 6. 성능 최적화

### 6.1 조회 최적화

1. **인덱스 전략**: 자주 조회되는 필드에 인덱스 적용
2. **복합 인덱스**: 함께 조회되는 필드에 복합 인덱스 적용
3. **부분 인덱스**: 특정 조건에 대한 부분 인덱스 활용

```sql
-- 활성 구독만을 위한 부분 인덱스
CREATE INDEX active_subscriptions_idx ON subscriptions(application_id, type)
WHERE subscription_status > 0;

-- 태그 기반 검색을 위한 GIN 인덱스
CREATE INDEX subscriptions_tags_gin_idx ON subscriptions USING GIN (tags);

-- 메시지 상태 및 생성 시간 복합 인덱스
CREATE INDEX messages_status_created_idx ON messages(status, created_at);
```

### 6.2 입력/수정 최적화

1. **배치 삽입**: 대량 데이터 삽입 시 배치 처리
2. **부분 업데이트**: 필요한 필드만 업데이트
3. **낙관적 잠금**: 동시 업데이트 처리를 위한 낙관적 잠금 활용

### 6.3 실행 계획 분석

중요 쿼리의 실행 계획 분석 및 최적화:

```sql
EXPLAIN ANALYZE
SELECT * FROM messages
WHERE application_id = '123e4567-e89b-12d3-a456-426614174000'
AND status = 'pending'
ORDER BY created_at DESC
LIMIT 100;
```

### 6.4 대량 쿼리 전략

대량 데이터 처리를 위한 전략:

1. **커서 기반 페이징**: offset 대신 커서 기반 페이징 사용
2. **스트리밍 처리**: 대량 데이터를 스트림으로 처리
3. **비동기 배치 처리**: 대량 작업을 비동기 배치로 처리

```elixir
# 커서 기반 페이징 예시
def list_messages_after(application_id, cursor, limit) do
  query = from m in Message,
    where: m.application_id == ^application_id,
    where: m.id > ^cursor,
    order_by: [asc: m.id],
    limit: ^limit

  Repo.all(query)
end

# 스트리밍 처리 예시
def stream_all_messages(application_id) do
  Message
  |> where([m], m.application_id == ^application_id)
  |> order_by([m], m.id)
  |> Repo.stream()
end
```

## 7. 보안 고려사항

### 7.1 민감 데이터 처리

민감한 데이터는 ash_cloak을 사용하여 암호화됩니다:

```elixir
defmodule AutomataSignal.Resources.Subscription do
  use Ash.Resource,
    # ...
    extensions: [AshCloak.Resource]

  # ...

  encrypted_attributes do
    attribute :token
  end

  # ...
end
```

암호화 설정:

```elixir
config :ash_cloak, repo: AutomataSignal.Repo

config :ash_cloak, AutomataSignal.AES,
  keys: [
    %{tag: "1", key: :base64.decode("..."), default: true}
  ]
```

### 7.2 접근 제어

데이터 접근 제어:

```elixir
defmodule AutomataSignal.Resources.Application do
  # ...

  actions do
    # ...

    # API 키 인증 정책
    defaults [:create, :read, :update, :destroy], policy: [AutomataSignal.Policies.RequireApiKey]
  end
end
```

인증 정책 구현:

```elixir
defmodule AutomataSignal.Policies.RequireApiKey do
  use Ash.Policy.SimpleCheck

  def check(actor, _resource, _action) do
    case actor do
      %{api_key: key} when is_binary(key) ->
        # API 키 검증 로직
        # ...
        true
      _ ->
        false
    end
  end
end
```

### 7.3 감사 추적

ash_paper_trail을 사용한 변경 이력 추적:

```elixir
defmodule AutomataSignal.Resources.MessageEvent do
  use Ash.Resource,
    # ...
    extensions: [AshPaperTrail.Resource]

  # ...

  paper_trail do
    track_attribute :event_type
    track_attribute :metadata

    track_relationship_updates? true

    monitor_actor? true
    track_actor? true
  end

  # ...
end
```

## 8. 데이터 마이그레이션 스크립트

### 8.1 기본 스키마 생성

```elixir
defmodule AutomataSignal.Repo.Migrations.CreateBaseSchema do
  use Ecto.Migration

  def change do
    # 애플리케이션 테이블
    create table(:applications, primary_key: false) do
      add :id, :uuid, primary_key: true
      add :name, :string, size: 100, null: false
      add :api_key, :string, size: 255, null: false
      add :settings, :jsonb, default: "{}"

      timestamps()

      add :is_active, :boolean, default: true
    end

    create index(:applications, [:name])
    create unique_index(:applications, [:api_key])

    # 사용자 테이블
    create table(:users, primary_key: false) do
      add :id, :uuid, primary_key: true
      add :external_id, :string, size: 255, null: false
      add :application_id, references(:applications, type: :uuid), null: false

      add :created_at, :utc_datetime
      add :last_active_at, :utc_datetime

      add :is_archived, :boolean, default: false
      add :archived_at, :utc_datetime
    end

    create index(:users, [:application_id])
    create index(:users, [:external_id])
    create unique_index(:users, [:external_id, :application_id])

    # 구독 테이블
    create table(:subscriptions, primary_key: false) do
      add :id, :uuid, primary_key: true
      add :token, :text, null: false
      add :type, :string, size: 20, null: false
      add :user_id, references(:users, type: :uuid)
      add :application_id, references(:applications, type: :uuid), null: false

      # 디바이스 정보
      add :device_model, :string, size: 255
      add :device_os, :string, size: 255
      add :device_language, :string, size: 10
      add :app_version, :string, size: 20
      add :sdk_version, :string, size: 20
      add :country_code, :string, size: 10
      add :test_type, :integer, default: 0

      # 구독 상태
      add :subscription_status, :integer, default: 0
      add :subscribed_at, :utc_datetime
      add :unsubscribed_at, :utc_datetime

      # 태그
      add :tags, :jsonb, default: "{}"

      # 통계
      add :last_active_at, :utc_datetime
      add :total_messages_received, :integer, default: 0
      add :total_messages_converted, :integer, default: 0

      add :is_archived, :boolean, default: false
      add :archived_at, :utc_datetime
    end

    # ... 나머지 테이블 생성 ...

    # 인덱스 생성
    create index(:subscriptions, [:user_id])
    create index(:subscriptions, [:application_id])
    create index(:subscriptions, [:type])
    create index(:subscriptions, [:subscription_status])
    create index(:subscriptions, :tags, using: :gin)

    # ... 나머지 인덱스 생성 ...
  end
end
```

### 8.2 테이블 파티셔닝 마이그레이션

```elixir
defmodule AutomataSignal.Repo.Migrations.CreateTablePartitions do
  use Ecto.Migration

  def up do
    # 메시지 테이블 파티셔닝
    execute """
    CREATE TABLE messages_partitioned (
      LIKE messages INCLUDING ALL
    ) PARTITION BY RANGE (created_at);
    """

    # 초기 파티션 생성
    execute """
    CREATE TABLE messages_y2025m04 PARTITION OF messages_partitioned
      FOR VALUES FROM ('2025-04-01') TO ('2025-05-01');
    """

    execute """
    CREATE TABLE messages_y2025m05 PARTITION OF messages_partitioned
      FOR VALUES FROM ('2025-05-01') TO ('2025-06-01');
    """

    # 데이터 마이그레이션
    execute "INSERT INTO messages_partitioned SELECT * FROM messages;"

    # 테이블 교체
    execute "DROP TABLE messages CASCADE;"
    execute "ALTER TABLE messages_partitioned RENAME TO messages;"

    # ... 다른 테이블에 대해서도 동일한 과정 반복 ...
  end

  def down do
    # 롤백 로직
    # ...
  end
end
```

## 9. 데이터 모델 사용 예시

### 9.1 구독 등록

```elixir
defmodule AutomataSignal.Services.SubscriptionService do
  alias AutomataSignal.Resources.Subscription

  def register_subscription(params) do
    Subscription.register(params)
    |> case do
      {:ok, subscription} ->
        # 구독 등록 이벤트 생성
        create_subscription_event(subscription, :created)
        {:ok, subscription}

      {:error, error} ->
        {:error, error}
    end
  end

  def create_subscription_event(subscription, event_type, reason \\ nil) do
    # 구독 이벤트 생성 로직
    # ...
  end
end
```

### 9.2 메시지 전송

```elixir
defmodule AutomataSignal.Services.MessageService do
  alias AutomataSignal.Resources.Message
  alias AutomataSignal.Resources.MessageEvent

  def send_message(params) do
    # 사용량 확인
    with {:ok, _} <- check_quota(params.application_id),
         {:ok, message} <- create_message(params) do

      # 작업 큐에 추가
      schedule_message_delivery(message)

      {:ok, message}
    else
      {:error, reason} -> {:error, reason}
    end
  end

  defp create_message(params) do
    # 템플릿 처리
    params = if params[:use_template] do
      process_template(params)
    else
      params
    end

    # 메시지 생성
    Message.send_message(params)
  end

  defp process_template(%{template_id: template_id, template_variables: variables} = params) do
    # 템플릿 렌더링 로직
    # ...
  end

  defp schedule_message_delivery(message) do
    # 작업 큐에 전송 작업 추가
    # ...
  end

  defp check_quota(application_id) do
    # 할당량 확인 로직
    # ...
  end
end
```

### 9.3 캠페인 생성 및 실행

```elixir
defmodule AutomataSignal.Services.CampaignService do
  alias AutomataSignal.Resources.MessageCampaign
  alias AutomataSignal.Resources.Subscription

  def create_campaign(params) do
    MessageCampaign.create(params)
  end

  def execute_campaign(campaign_id) do
    with {:ok, campaign} <- get_campaign(campaign_id),
         {:ok, updated_campaign} <- MessageCampaign.execute(%{id: campaign_id}),
         {:ok, subscriptions} <- find_target_subscriptions(campaign) do

      # 타겟팅된 구독 수 업데이트
      update_campaign_recipients(campaign.id, length(subscriptions))

      # 배치 처리
      process_campaign_messages(campaign, subscriptions)

      {:ok, updated_campaign}
    else
      {:error, reason} -> {:error, reason}
    end
  end

  defp get_campaign(id) do
    # 캠페인 조회
    # ...
  end

  defp find_target_subscriptions(campaign) do
    # 타겟팅 조건에 맞는 구독 찾기
    criteria = campaign.targeting_criteria

    query = Subscription.query()
      |> Ash.Query.filter(application_id == ^campaign.application_id)
      |> Ash.Query.filter(subscription_status > 0)

    # 태그 필터 적용
    query = if criteria["tags"] do
      apply_tag_filters(query, criteria["tags"])
    else
      query
    end

    # 활동 시간 필터 적용
    query = if criteria["last_active_after"] do
      Ash.Query.filter(query, last_active_at > ^criteria["last_active_after"])
    else
      query
    end

    # 국가 필터 적용
    query = if criteria["countries"] do
      Ash.Query.filter(query, country_code in ^criteria["countries"])
    else
      query
    end

    # 쿼리 실행
    {:ok, Ash.read!(query)}
  end

  defp apply_tag_filters(query, tags) do
    Enum.reduce(tags, query, fn {key, value}, acc ->
      Ash.Query.filter(acc, fragment("(tags->?)::text = ?", ^key, ^value))
    end)
  end

  defp update_campaign_recipients(campaign_id, count) do
    # 캠페인 수신자 수 업데이트
    # ...
  end

  defp process_campaign_messages(campaign, subscriptions) do
    # 배치 처리
    subscriptions
    |> Enum.chunk_every(500)
    |> Enum.each(fn batch ->
      # 배치 단위로 메시지 생성 및 작업 추가
      # ...
    end)
  end
end
```

---

// File: automata-signal/2-designs/DESIGN-004-deployment

# [DESIGN-004] 배포 구조

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 요약

본 문서는 Automata-Signal 시스템의 배포 구조를 상세히 설명합니다. 글로벌 분산 배포 전략, 인프라 구성, 확장성, 고가용성, CI/CD 파이프라인 등을 다룹니다.

## 대상 독자

- 신규 개발자
- 개발팀

## 1. 배포 아키텍처 개요

Automata-Signal은 fly.io 플랫폼을 기반으로 글로벌 분산 배포를 구현합니다. 지리적으로 분산된 데이터센터에 애플리케이션을 배포하여 전 세계 사용자에게 낮은 지연 시간과 높은 가용성을 제공합니다.

```mermaid
flowchart TB
    subgraph fly ["fly.io"]
        subgraph nrt ["도쿄 리전 (nrt)"]
            nrt1[Elixir 노드 #1]
            nrt2[Elixir 노드 #2]
            nrt3[Elixir 노드 #3]
            nrt4[Elixir 노드 #4]
        end

        subgraph fra ["프랑크푸르트 리전 (fra)"]
            fra1[Elixir 노드 #1]
            fra2[Elixir 노드 #2]
            fra3[Elixir 노드 #3]
            fra4[Elixir 노드 #4]
        end

        subgraph syd ["시드니 리전 (syd)"]
            syd1[Elixir 노드 #1]
            syd2[Elixir 노드 #2]
            syd3[Elixir 노드 #3]
            syd4[Elixir 노드 #4]
        end

        db_nrt[(PostgreSQL<br>Primary<br>도쿄)]
        db_fra[(PostgreSQL<br>Replica<br>프랑크푸르트)]
        db_syd[(PostgreSQL<br>Replica<br>시드니)]
    end

    subgraph cd ["CI/CD 파이프라인"]
        github[GitHub]
        actions[GitHub Actions]
        registry[컨테이너 레지스트리]
    end

    subgraph external ["외부 서비스"]
        apns[Apple APNS]
        fcm[Firebase FCM]
        email[이메일 서비스<br>지원 예정]
        sms[SMS 게이트웨이<br>지원 예정]
        kakao[카카오 API<br>지원 예정]
    end

    subgraph client ["사용자"]
        asia[아시아 지역<br>사용자]
        europe[유럽 지역<br>사용자]
        oceania[오세아니아<br>지역 사용자]
    end

    %% 노드 간 연결
    nrt1 <--> nrt2
    nrt2 <--> nrt3
    nrt3 <--> nrt4
    nrt4 <--> nrt1

    fra1 <--> fra2
    fra2 <--> fra3
    fra3 <--> fra4
    fra4 <--> fra1

    syd1 <--> syd2
    syd2 <--> syd3
    syd3 <--> syd4
    syd4 <--> syd1

    %% 리전 간 연결 (libcluster)
    nrt1 <--> fra1
    nrt1 <--> syd1
    fra1 <--> syd1

    %% 데이터베이스 복제
    db_nrt --> db_fra
    db_nrt --> db_syd

    %% 데이터베이스 연결
    nrt1 --> db_nrt
    nrt2 --> db_nrt
    nrt3 --> db_nrt
    nrt4 --> db_nrt

    fra1 --> db_fra
    fra2 --> db_fra
    fra3 --> db_fra
    fra4 --> db_fra

    syd1 --> db_syd
    syd2 --> db_syd
    syd3 --> db_syd
    syd4 --> db_syd

    %% CI/CD 흐름
    github --> actions
    actions --> registry
    registry --> nrt1
    registry --> fra1
    registry --> syd1

    %% 외부 서비스 연결
    nrt1 --- apns
    nrt1 --- fcm
    fra1 --- apns
    fra1 --- fcm
    syd1 --- apns
    syd1 --- fcm

    %% 사용자 요청 라우팅
    asia --> nrt1
    europe --> fra1
    oceania --> syd1
```

## 2. fly.io 인프라 구성

### 2.1 리전 및 노드 구성

Automata-Signal은 초기에 다음 3개 리전에 배포됩니다:

| 리전 코드 | 위치               | 노드 수 | 목적                   |
| --------- | ------------------ | ------- | ---------------------- |
| nrt       | 도쿄, 일본         | 4       | 아시아 지역 서비스     |
| fra       | 프랑크푸르트, 독일 | 4       | 유럽 지역 서비스       |
| syd       | 시드니, 호주       | 4       | 오세아니아 지역 서비스 |

각 노드는 다음과 같이 구성됩니다:

- **VM 크기**: 4 vCPU, 8GB RAM
- **스토리지**: 40GB SSD (노드당)
- **운영체제**: Linux (Debian)
- **컨테이너 런타임**: Docker
- **네트워크**: 리전 내 로컬 네트워크, 리전 간 암호화된 통신

### 2.2 데이터베이스 구성

PostgreSQL 데이터베이스는 다음과 같이 구성됩니다:

- **프라이머리 노드**: 도쿄(nrt) 리전
- **읽기 복제본**: 프랑크푸르트(fra) 및 시드니(syd) 리전
- **VM 크기**: 8 vCPU, 16GB RAM
- **스토리지**: 500GB SSD
- **복제 방식**: 스트리밍 복제 (비동기)
- **백업 전략**: 일일 전체 백업, 15분 간격 증분 백업

### 2.3 네트워크 구성

- **공용 엔드포인트**: 리전별 API 엔드포인트 (\*.automata-signal.com)
- **애니캐스트 IP**: 글로벌 단일 엔드포인트로 가장 가까운 리전으로 라우팅
- **프라이빗 네트워크**: fly.io 내부 네트워크로 노드 및 데이터베이스 간 통신
- **IPv6 지원**: 모든 엔드포인트에서 IPv6 지원

### 2.4 DNS 구성

| 도메인                       | 목적                               |
| ---------------------------- | ---------------------------------- |
| api.automata-signal.com      | 글로벌 API 엔드포인트 (애니캐스트) |
| api-asia.automata-signal.com | 아시아 리전 직접 접근 (도쿄)       |
| api-eu.automata-signal.com   | 유럽 리전 직접 접근 (프랑크푸르트) |
| api-oce.automata-signal.com  | 오세아니아 리전 직접 접근 (시드니) |
| admin.automata-signal.com    | 관리자 대시보드 (향후 구현)        |

## 3. fly.io 구성 및 배포

### 3.1 fly.toml 구성

Automata-Signal의 기본 `fly.toml` 설정:

```toml
# fly.toml

app = "automata-signal"
primary_region = "nrt"

[env]
  PHX_HOST = "api.automata-signal.com"
  PORT = "8080"
  RELEASE_COOKIE = "release_cookie_value_here"
  NODE_COOKIE = "node_cookie_value_here"
  FLY_REGION = "nrt"
  FLY_APP_NAME = "automata-signal"
  DATABASE_URL = "ecto://postgres:password@top1.nearest.of.automata-signal-db.internal:5432/automata_signal"
  SECRET_KEY_BASE = "secret_key_base_value_here"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = false
  auto_start_machines = true
  min_machines_running = 3
  processes = ["app"]

  [http_service.concurrency]
    type = "connections"
    hard_limit = 1000
    soft_limit = 800

[[services]]
  protocol = "tcp"
  internal_port = 4369
  processes = ["app"]

  [[services.ports]]
    port = 4369

[metrics]
  port = 9090
  path = "/metrics"

[[vm]]
  cpu_kind = "shared"
  cpus = 4
  memory_mb = 8192

[deploy]
  strategy = "rolling"
  release_command = "eval 'Automata.Release.migrate'"

[mounts]
  source = "automata_storage"
  destination = "/app/uploads"
```

### 3.2 Dockerfile

```dockerfile
FROM hexpm/elixir:1.18.0-erlang-27.0.0-debian-bullseye-20240311 as build

# 빌드 환경 설정
WORKDIR /app
ENV MIX_ENV=prod

# 의존성 파일 복사 및 설치
COPY mix.exs mix.lock ./
COPY config config
COPY apps apps

RUN mix local.hex --force && \
    mix local.rebar --force && \
    mix deps.get --only prod && \
    mix deps.compile

# 릴리스 빌드
RUN mix compile
RUN mix release

# 실행 이미지 준비
FROM debian:bullseye-slim

# 런타임 의존성 설치
RUN apt-get update -y && \
    apt-get install -y libstdc++6 openssl libncurses5 locales ca-certificates && \
    apt-get clean && \
    rm -f /var/lib/apt/lists/*_*

# 로케일 설정
RUN sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen
ENV LANG en_US.UTF-8
ENV LANGUAGE en_US:en
ENV LC_ALL en_US.UTF-8

WORKDIR /app
COPY --from=build /app/_build/prod/rel/automata ./

# 앱 실행
CMD ["/app/bin/automata", "start"]
```

### 3.3 리전별 배포 전략

각 리전은 별도의 fly 앱으로 배포하여 독립적으로 관리합니다:

```bash
# 도쿄 리전 배포
fly deploy --app automata-signal-nrt

# 프랑크푸르트 리전 배포
fly deploy --app automata-signal-fra

# 시드니 리전 배포
fly deploy --app automata-signal-syd
```

### 3.4 스케일링 설정

자동 스케일링을 위한 구성:

```bash
# 최소 노드 수 설정
fly scale count 4 --app automata-signal-nrt
fly scale count 4 --app automata-signal-fra
fly scale count 4 --app automata-signal-syd

# VM 크기 설정
fly scale vm shared-cpu-4x:8gb --app automata-signal-nrt
fly scale vm shared-cpu-4x:8gb --app automata-signal-fra
fly scale vm shared-cpu-4x:8gb --app automata-signal-syd
```

### 3.5 데이터베이스 배포

PostgreSQL 클러스터 생성 및 구성:

```bash
# 프라이머리 데이터베이스 생성 (도쿄)
fly postgres create --name automata-signal-db --region nrt

# 읽기 복제본 추가 (프랑크푸르트)
fly postgres attach --postgres-app automata-signal-db --app automata-signal-fra

# 읽기 복제본 추가 (시드니)
fly postgres attach --postgres-app automata-signal-db --app automata-signal-syd
```

## 4. 분산 Elixir 클러스터 구성

### 4.1 libcluster 설정

Elixir 노드 간의 자동 클러스터링을 위한 libcluster 구성:

```elixir
# config/prod.exs
config :libcluster,
  topologies: [
    fly6pn: [
      strategy: Cluster.Strategy.DNSPoll,
      config: [
        polling_interval: 5_000,
        query: "#{System.get_env("FLY_APP_NAME")}.internal",
        node_basename: System.get_env("FLY_APP_NAME")
      ]
    ],
    global_cluster: [
      strategy: Elixir.Cluster.Strategy.Gossip,
      config: [
        secret: System.get_env("CLUSTER_SECRET"),
        hosts: [
          :"automata-signal-nrt@fly-global-services",
          :"automata-signal-fra@fly-global-services",
          :"automata-signal-syd@fly-global-services"
        ]
      ]
    ]
  ]
```

### 4.2 Erlang 분산 설정

Erlang 분산 프로토콜 설정:

```elixir
# config/runtime.exs
config :automata, :distributed,
  cookie: System.fetch_env!("NODE_COOKIE"),
  name: :"#{System.get_env("FLY_APP_NAME")}@#{System.get_env("FLY_PRIVATE_IP")}"
```

### 4.3 분산 Phoenix PubSub 구성

노드 간 이벤트 공유를 위한 PubSub 구성:

```elixir
# lib/automata/application.ex
def start(_type, _args) do
  children = [
    # ... 다른 자식 프로세스들 ...
    {Phoenix.PubSub, name: Automata.PubSub},
    {Phoenix.PubSub.PG2, name: Automata.GlobalPubSub, adapter_name: Automata.PubSub}
  ]

  # ...
end
```

### 4.4 분산 캐시 구성

전역 상태 및 캐시 관리를 위한 Nebulex 설정:

```elixir
# lib/automata/cache.ex
defmodule Automata.Cache do
  use Nebulex.Cache,
    otp_app: :automata,
    adapter: Nebulex.Adapters.Partitioned

  # ...
end

# config/prod.exs
config :automata, Automata.Cache,
  backend: :shards,
  partitions: 8,
  distributed: [
    name: Automata.DistributedCache,
    only_nodes: [node()]
  ]
```

## 5. 데이터베이스 연결 관리

### 5.1 Ecto 리포지토리 설정

PostgreSQL 연결 설정:

```elixir
# config/prod.exs
config :automata, Automata.Repo,
  adapter: Ash.Postgres.Repo,
  url: System.get_env("DATABASE_URL"),
  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "30"),
  socket_options: [:inet6],
  ssl: true,
  ssl_opts: [
    verify: :verify_peer,
    cacertfile: System.get_env("FLY_DB_CA_CERT", "/etc/ssl/certs/ca-certificates.crt"),
    server_name_indication: System.get_env("FLY_DB_HOST") |> String.to_charlist()
  ]
```

### 5.2 읽기/쓰기 분리

읽기와 쓰기 작업을 분리하여 효율성 향상:

```elixir
# lib/automata/repo.ex
defmodule Automata.Repo do
  use Ecto.Repo,
    otp_app: :automata,
    adapter: Ecto.Adapters.Postgres
end

defmodule Automata.ReadOnlyRepo do
  use Ecto.Repo,
    otp_app: :automata,
    adapter: Ecto.Adapters.Postgres

  def init(_, config) do
    config = Keyword.put(config, :url, System.get_env("DATABASE_READ_REPLICA_URL") || System.get_env("DATABASE_URL"))
    {:ok, config}
  end
end

# 사용 예시
defmodule Automata.QueryService do
  def get_analytics_data(params) do
    # 읽기 전용 쿼리는 읽기 복제본 사용
    Automata.ReadOnlyRepo.all(analytics_query(params))
  end

  def update_record(id, params) do
    # 쓰기 작업은 주 데이터베이스 사용
    Automata.Repo.update(...)
  end
end
```

### 5.3 연결 풀 최적화

데이터베이스 연결 풀 최적화 설정:

```elixir
# config/prod.exs
config :automata, Automata.Repo,
  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "30"),
  queue_target: 5000,
  queue_interval: 5000,
  timeout: 60000

config :automata, Automata.ReadOnlyRepo,
  pool_size: String.to_integer(System.get_env("RO_POOL_SIZE") || "50"),
  queue_target: 2000,
  queue_interval: 2000,
  timeout: 30000
```

### 5.4 데이터베이스 마이그레이션

배포 중 안전한 데이터베이스 마이그레이션 방법:

```elixir
# lib/automata/release.ex
defmodule Automata.Release do
  @app :automata

  def migrate do
    load_app()

    for repo <- repos() do
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :up, all: true))
    end
  end

  def rollback(repo, version) do
    load_app()
    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :down, to: version))
  end

  defp repos do
    Application.fetch_env!(@app, :ecto_repos)
  end

  defp load_app do
    Application.load(@app)
  end
end
```

## 6. CI/CD 파이프라인

### 6.1 CI/CD 파이프라인

Automata-Signal은 GitHub Actions를 활용한 지속적 통합 및 배포(CI/CD) 파이프라인을 구현합니다. 이를 통해 코드 품질 검증부터 다중 환경 자동 배포까지 완전 자동화된 워크플로우를 제공합니다.

파이프라인은 다음 주요 단계로 구성됩니다:

1. **코드 품질 및 테스트 검증**: 모든 코드 변경에 대해 자동으로 코드 품질 검사 및 테스트 실행
2. **환경별 자동 배포**: 특정 브랜치에 대한 변경사항을 해당 환경에 자동 배포
   - 개발(Development): develop 브랜치 변경 시
   - 스테이징(Staging): 수동 트리거 시
   - 프로덕션(Production): main 브랜치 변경 시 (리전별 배포)

프로젝트의 CI/CD 파이프라인 구성에 대한 자세한 내용은 [GUIDE-003] 개발 워크플로우 문서를 참조하세요.

### 6.2 배포 전략

Automata-Signal은 무중단 배포를 위한 롤링 업데이트 전략을 채택하고 있습니다:

1. 각 리전의 노드를 한 번에 하나씩 업데이트
2. 노드 교체 전 상태 점검 및 트래픽 드레이닝
3. 배포 중 지속적인 상태 모니터링
4. 문제 발생 시 자동 롤백 수행

fly.toml의 `[deploy]` 섹션에서 `strategy = "rolling"` 설정을 통해 이를 구현합니다.

### 6.3 환경별 구성

시스템은 다음과 같은 환경 구성을 가집니다:

| 환경     | 애플리케이션 이름               | 목적               | 구성 파일              |
| -------- | ------------------------------- | ------------------ | ---------------------- |
| 개발     | automata-signal-dev             | 개발자 테스트      | fly.dev.toml           |
| 스테이징 | automata-signal-staging         | QA 및 통합 테스트  | fly.staging.toml       |
| 프로덕션 | automata-signal-`{nrt,fra,syd}` | 실제 사용자 서비스 | fly.prod.`{리전}`.toml |

각 환경은 독립된 fly.io 앱으로 배포되며, 환경별로 분리된 구성 파일을 통해 설정을 관리합니다.

### 6.4 비밀 관리

민감한 구성 정보를 안전하게 관리하기 위한 전략:

1. GitHub Secrets를 통한 CI/CD 비밀 관리
2. fly.io 비밀 관리 서비스를 통한 런타임 비밀 관리
3. 환경 변수 기반 구성 로드

```bash
# 런타임 비밀 설정
fly secrets set NODE_COOKIE=<secret_value> --app automata-signal-nrt
fly secrets set APNS_KEY_ID=<secret_value> --app automata-signal-nrt
fly secrets set FCM_SERVER_KEY=<secret_value> --app automata-signal-nrt
```

## 7. 확장 전략

### 7.1 수평적 확장

트래픽 증가에 따른 수평적 확장 전략:

1. **새 노드 추가**: 리전별 노드 수 증가

   ```bash
   fly scale count 8 --app automata-signal-nrt
   ```

2. **새 리전 추가**: 주요 사용자 지역에 새 리전 배포

   ```bash
   # 예: IAD(북미, 버지니아) 리전 추가
   fly regions add iad --app automata-signal-iad
   ```

3. **자동 스케일링**: 트래픽 기반 자동 스케일링 설정
   ```bash
   fly autoscale set min=4 max=8 --app automata-signal-nrt
   ```

### 7.2 데이터베이스 확장

데이터 볼륨 증가에 따른 데이터베이스 확장 전략:

1. **수직적 확장**: 더 큰 VM으로 데이터베이스 업그레이드

   ```bash
   fly postgres update vm-size --vm-size performance-8x --app automata-signal-db
   ```

2. **스토리지 확장**: 데이터베이스 볼륨 확장

   ```bash
   fly volumes extend vol_123abcd --size 1000 --app automata-signal-db
   ```

3. **읽기 전용 복제본 추가**: 읽기 작업 분산을 위한 추가 복제본 배포

   ```bash
   fly postgres create --name automata-signal-db-ro --region nrt
   ```

4. **향후 샤딩 전략**: 대규모 데이터를 위한 샤딩 아키텍처 준비
   - 시간 기반 샤딩
   - 애플리케이션 ID 기반 샤딩
   - 리전 기반 샤딩

### 7.3 캐시 계층

성능 향상을 위한 캐시 전략:

1. **Nebulex 분산 캐시**: 노드 간 공유 캐시
2. **Redis 캐시 계층**: 전역 공유 상태 및 임시 데이터 저장
3. **CDN**: 정적 자산 및 API 응답 캐싱

### 7.4 작업 처리 확장

대규모 작업 처리를 위한 확장 전략:

1. **작업 노드 분리**: 전용 작업 처리 노드 배포
2. **작업 분산**: 작업 유형별 전용 큐 및 워커 설정
3. **우선순위 큐**: 중요 작업 우선 처리

## 8. 고가용성 및 장애 허용성

### 8.1 리전 장애 대응

단일 리전 장애 시 대응 전략:

1. **트래픽 페일오버**: 자동 트래픽 재라우팅
2. **데이터베이스 페일오버**: 복제본을 기본 데이터베이스로 승격
3. **복구 자동화**: 장애 복구 프로세스 자동화

### 8.2 데이터베이스 장애 대응

데이터베이스 장애 시 대응 전략:

1. **읽기 전용 모드**: 기본 DB 장애 시 읽기 전용 모드 운영
2. **자동 복구**: 오류 감지 및 자동 복구 시퀀스
3. **백업 복원**: 최신 백업에서 신속한 복원

### 8.3 노드 장애 대응

단일 노드 장애 시 대응 전략:

1. **상태 점검**: 정기적인 노드 상태 점검
2. **자동 재시작**: 장애 노드 자동 재시작
3. **트래픽 우회**: 장애 노드로의 트래픽 차단

### 8.4 다중 리전 복원력

전역 서비스 가용성을 위한 전략:

1. **리전 격리**: 리전 간 장애 격리
2. **데이터 복제**: 주요 데이터 다중 리전 복제
3. **분산 작업 복구**: 작업 복구 및 재시도 메커니즘

## 9. 모니터링 및 알림

### 9.1 모니터링 아키텍처

시스템 상태 모니터링을 위한 아키텍처:

```mermaid
flowchart LR
    subgraph Apps ["애플리케이션"]
        metrics[Prometheus 측정항목]
        logs[로그 시스템]
        traces[분산 추적]
    end

    subgraph Monitoring ["모니터링 도구"]
        prom[Prometheus]
        loki[Loki]
        tempo[Tempo]
        grafana[Grafana]
    end

    subgraph Alerts ["알림"]
        alertmanager[AlertManager]
        slack[Slack]
        email[이메일]
        pager[PagerDuty]
    end

    metrics --> prom
    logs --> loki
    traces --> tempo

    prom --> grafana
    loki --> grafana
    tempo --> grafana

    prom --> alertmanager
    alertmanager --> slack
    alertmanager --> email
    alertmanager --> pager
```

### 9.2 핵심 지표

모니터링할 핵심 시스템 지표:

1. **시스템 지표**:

   - CPU 사용률
   - 메모리 사용량
   - 디스크 I/O
   - 네트워크 트래픽

2. **애플리케이션 지표**:

   - API 요청 처리량
   - 응답 시간
   - 오류율
   - 동시 연결 수

3. **비즈니스 지표**:
   - 메시지 처리량
   - 전송 성공률
   - 메시지 전환율
   - 채널별 성능

### 9.3 로깅 전략

시스템 로그 관리 전략:

1. **구조화된 로깅**: JSON 형식 로그 생성
2. **중앙 로그 집계**: Loki를 통한 로그 저장 및 쿼리
3. **로그 수준 관리**: 환경별 로그 수준 조정
4. **로그 보존 정책**: 로그 유형별 보존 기간 설정

### 9.4 알림 설정

중요 이벤트 감지 및 알림 전략:

1. **심각도 수준**:

   - 긴급: 즉시 대응 필요한 프로덕션 장애
   - 주요: 성능 저하 또는 부분적 장애
   - 경고: 잠재적 문제 징후
   - 정보: 일반 정보 알림

2. **알림 채널**:

   - Slack: 팀 알림
   - 이메일: 요약 및 일일 보고서
   - PagerDuty: 긴급 상황 온콜 알림

3. **알림 규칙 예시**:
   ```yaml
   # 알림 규칙 예시
   groups:
     - name: automata_signal_alerts
       rules:
         - alert: HighErrorRate
           expr: sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m])) > 0.05
           for: 2m
           labels:
             severity: critical
           annotations:
             summary: 'High error rate detected'
             description: 'Error rate is above 5% for the past 2 minutes'
   ```

## 10. 재해 복구

### 10.1 백업 전략

데이터 손실 방지를 위한 백업 전략:

1. **정기 백업**:

   - 일일 전체 백업
   - 6시간 간격 차등 백업
   - 1시간 간격 증분 백업

2. **백업 저장소**:

   - 리전별 기본 백업
   - 다중 리전 복제 백업
   - 장기 보존을 위한 냉각 저장소

3. **백업 점검**:
   - 정기적인 백업 복원 테스트
   - 백업 무결성 확인

### 10.2 재해 복구 계획

주요 재해 시나리오에 대한 복구 계획:

1. **리전 장애 복구**:

   - 장애 리전 감지
   - 트래픽 재라우팅
   - 새 리전에 인프라 재배포
   - 데이터 복구

2. **데이터베이스 장애 복구**:

   - 복제본 승격
   - 읽기/쓰기 엔드포인트 재구성
   - 새 복제본 생성
   - 장애 노드 복구

3. **애플리케이션 장애 복구**:
   - 장애 노드 식별
   - 노드 교체
   - 클러스터 재구성

### 10.3 복구 시간 목표

서비스 복구 목표:

| 장애 유형         | RTO (복구 시간 목표) | RPO (복구 지점 목표) |
| ----------------- | -------------------- | -------------------- |
| 단일 노드 장애    | 5분                  | 0 (데이터 손실 없음) |
| 단일 리전 장애    | 15분                 | 5분                  |
| 데이터베이스 장애 | 30분                 | 15분                 |
| 다중 리전 장애    | 2시간                | 30분                 |
| 재해 수준 장애    | 4시간                | 1시간                |

### 10.4 재해 복구 테스트

재해 복구 계획 검증을 위한 정기 테스트:

1. **정기 훈련**: 분기별 DR 시뮬레이션
2. **카오스 엔지니어링**: 임의 장애 주입 테스트
3. **리전 페일오버 테스트**: 리전 간 전환 테스트

## 11. 보안 아키텍처

### 11.1 네트워크 보안

네트워크 보안 아키텍처:

1. **TLS/SSL**: 모든 통신에 TLS 1.3 암호화
2. **IP 제한**: 관리 인터페이스 접근 제한
3. **WAF**: 웹 애플리케이션 방화벽 보호
4. **DDoS 방어**: 분산 서비스 거부 공격 방어 메커니즘

### 11.2 애플리케이션 보안

애플리케이션 레벨 보안:

1. **API 인증**: API 키 및 JWT 기반 인증
2. **접근 제어**: 세분화된 권한 관리
3. **입력 검증**: 모든 사용자 입력 검증
4. **의존성 검사**: 정기적인 의존성 취약점 검사

### 11.3 데이터 보안

데이터 보안 방식:

1. **저장 데이터 암호화**: 민감 데이터 암호화 (ash_cloak)
2. **전송 중 암호화**: TLS를 통한 모든 데이터 암호화
3. **접근 로깅**: 민감 데이터 접근 감사 로깅
4. **데이터 최소화**: 필요한 최소한의 데이터만 저장

### 11.4 인증 및 인가

사용자 및 API 인증 메커니즘:

1. **API 키 관리**: 앱별 API 키 관리
2. **토큰 회전**: 정기적 API 키 갱신
3. **세션 관리**: 안전한 관리자 세션 처리
4. **역할 기반 권한**: 세분화된 접근 제어 모델

## 12. 성능 최적화

### 12.1 처리량 최적화

높은 처리량을 위한 최적화:

1. **병렬 처리**: 멀티코어 활용 병렬 작업 처리
2. **비동기 처리**: 작업 큐 기반 비동기 처리
3. **배치 처리**: 대량 작업 배치 처리
4. **연결 풀링**: 효율적인 리소스 활용

### 12.2 지연 시간 최적화

낮은 지연 시간을 위한 최적화:

1. **엣지 배포**: 사용자에 가까운 위치 배포
2. **캐싱 전략**: 다중 계층 캐싱 구현
3. **인덱스 최적화**: 데이터베이스 쿼리 최적화
4. **콜드 경로 분리**: 중요 작업 우선 처리

### 12.3 부하 분산

효율적인 부하 분산 전략:

1. **지역 기반 라우팅**: 사용자에게 가장 가까운 리전으로 라우팅
2. **가중치 기반 분산**: 노드 용량에 따른 트래픽 분산
3. **상태 기반 라우팅**: 노드 상태에 따른 트래픽 조정
4. **캠페인 부하 분산**: 대량 캠페인 다중 노드 분산 처리

## 13. 운영 가이드라인

### 13.1 일반 운영 절차

일상적인 운영 작업:

1. **일일 점검**:

   - 시스템 상태 확인
   - 오류 로그 검토
   - 성능 지표 모니터링

2. **주간 유지보수**:

   - 비정상 노드 교체
   - 성능 최적화
   - 보안 패치 적용

3. **월간 작업**:
   - 용량 계획 검토
   - 확장 요구사항 평가
   - 백업 복원 테스트

### 13.2 인시던트 대응

장애 상황 대응 절차:

1. **감지 및 알림**:

   - 자동 알림 수신
   - 상황 평가
   - 대응팀 소집

2. **초기 대응**:

   - 영향 평가
   - 임시 조치 적용
   - 사용자 커뮤니케이션

3. **해결 및 복구**:

   - 근본 원인 분석
   - 영구적 해결책 적용
   - 서비스 복원 확인

4. **사후 분석**:
   - 인시던트 보고서 작성
   - 개선 사항 식별
   - 재발 방지 대책 수립

### 13.3 변경 관리

시스템 변경 관리 절차:

1. **변경 요청**:

   - 요청 목적 및 범위 정의
   - 영향 평가
   - 롤백 계획 수립

2. **변경 승인**:

   - 기술 검토
   - 리스크 평가
   - 최종 승인

3. **변경 구현**:

   - 점진적 롤아웃
   - 모니터링 강화
   - 테스트 검증

4. **사후 검토**:
   - 변경 결과 평가
   - 문제점 식별
   - 프로세스 개선

### 13.4 용량 계획

리소스 용량 관리:

1. **현재 사용량 분석**:

   - 시스템 리소스 사용률
   - 성장 추세 분석
   - 병목 지점 식별

2. **예측 모델링**:

   - 사용자 증가 예측
   - 메시지 볼륨 예측
   - 스토리지 요구사항 예측

3. **확장 계획**:
   - 단기 확장 계획
   - 중기 확장 계획
   - 장기 인프라 로드맵

---

// File: automata-signal/2-designs/DESIGN-004-operational-architecture

# [DESIGN-004] 운영 아키텍처

| 버전 | 날짜       | 변경 내용                                    |
| ---- | ---------- | -------------------------------------------- |
| 1.1  | 2025-04-14 | 문서 개선 - 배포 구조를 운영 아키텍처로 확장 |
| 1.0  | 2025-04-02 | 최초 문서 작성                               |

## 요약

본 문서는 Automata-Signal 시스템의 운영 아키텍처를 상세히 설명합니다. 글로벌 분산 배포 전략, 인프라 구성, 확장성, 고가용성, 모니터링, 보안, 재해 복구 등 운영 측면의 아키텍처 전체를 다룹니다. 배포 프로세스 및 CI/CD 파이프라인에 대한 구체적인 워크플로우는 [GUIDE-005] 배포 워크플로우 문서를 참조하세요.

## 대상 독자

- 개발팀
- 시스템 엔지니어
- 운영팀
- 인프라 관리자

## 1. 배포 아키텍처 개요

Automata-Signal은 fly.io 플랫폼을 기반으로 글로벌 분산 배포를 구현합니다. 지리적으로 분산된 데이터센터에 애플리케이션을 배포하여 전 세계 사용자에게 낮은 지연 시간과 높은 가용성을 제공합니다.

```mermaid
flowchart TB
    subgraph fly ["fly.io"]
        subgraph nrt ["도쿄 리전 (nrt)"]
            nrt1[Elixir 노드 #1]
            nrt2[Elixir 노드 #2]
            nrt3[Elixir 노드 #3]
            nrt4[Elixir 노드 #4]
        end

        subgraph fra ["프랑크푸르트 리전 (fra)"]
            fra1[Elixir 노드 #1]
            fra2[Elixir 노드 #2]
            fra3[Elixir 노드 #3]
            fra4[Elixir 노드 #4]
        end

        subgraph syd ["시드니 리전 (syd)"]
            syd1[Elixir 노드 #1]
            syd2[Elixir 노드 #2]
            syd3[Elixir 노드 #3]
            syd4[Elixir 노드 #4]
        end

        db_nrt[(PostgreSQL<br>Primary<br>도쿄)]
        db_fra[(PostgreSQL<br>Replica<br>프랑크푸르트)]
        db_syd[(PostgreSQL<br>Replica<br>시드니)]
    end

    subgraph cd ["CI/CD 파이프라인"]
        github[GitHub]
        actions[GitHub Actions]
        registry[컨테이너 레지스트리]
    end

    subgraph external ["외부 서비스"]
        apns[Apple APNS]
        fcm[Firebase FCM]
        email[이메일 서비스<br>지원 예정]
        sms[SMS 게이트웨이<br>지원 예정]
        kakao[카카오 API<br>지원 예정]
    end

    subgraph client ["사용자"]
        asia[아시아 지역<br>사용자]
        europe[유럽 지역<br>사용자]
        oceania[오세아니아<br>지역 사용자]
    end

    subgraph monitoring ["모니터링"]
        prometheus[Prometheus]
        grafana[Grafana]
        loki[Loki]
        alertmanager[AlertManager]
    end

    %% 노드 간 연결
    nrt1 <--> nrt2
    nrt2 <--> nrt3
    nrt3 <--> nrt4
    nrt4 <--> nrt1

    fra1 <--> fra2
    fra2 <--> fra3
    fra3 <--> fra4
    fra4 <--> fra1

    syd1 <--> syd2
    syd2 <--> syd3
    syd3 <--> syd4
    syd4 <--> syd1

    %% 리전 간 연결 (libcluster)
    nrt1 <--> fra1
    nrt1 <--> syd1
    fra1 <--> syd1

    %% 데이터베이스 복제
    db_nrt --> db_fra
    db_nrt --> db_syd

    %% 데이터베이스 연결
    nrt1 --> db_nrt
    nrt2 --> db_nrt
    nrt3 --> db_nrt
    nrt4 --> db_nrt

    fra1 --> db_fra
    fra2 --> db_fra
    fra3 --> db_fra
    fra4 --> db_fra

    syd1 --> db_syd
    syd2 --> db_syd
    syd3 --> db_syd
    syd4 --> db_syd

    %% CI/CD 흐름
    github --> actions
    actions --> registry
    registry --> nrt1
    registry --> fra1
    registry --> syd1

    %% 외부 서비스 연결
    nrt1 --- apns
    nrt1 --- fcm
    fra1 --- apns
    fra1 --- fcm
    syd1 --- apns
    syd1 --- fcm

    %% 사용자 요청 라우팅
    asia --> nrt1
    europe --> fra1
    oceania --> syd1

    %% 모니터링 연결
    nrt1 --> prometheus
    fra1 --> prometheus
    syd1 --> prometheus
    prometheus --> grafana
    prometheus --> alertmanager
    nrt1 --> loki
    fra1 --> loki
    syd1 --> loki
    loki --> grafana
```

## 2. 인프라 구성

### 2.1 리전 및 노드 구성

Automata-Signal은 초기에 다음 3개 리전에 배포됩니다:

| 리전 코드 | 위치               | 노드 수 | 목적                   |
| --------- | ------------------ | ------- | ---------------------- |
| nrt       | 도쿄, 일본         | 4       | 아시아 지역 서비스     |
| fra       | 프랑크푸르트, 독일 | 4       | 유럽 지역 서비스       |
| syd       | 시드니, 호주       | 4       | 오세아니아 지역 서비스 |

각 노드는 다음과 같이 구성됩니다:

- **VM 크기**: 4 vCPU, 8GB RAM
- **스토리지**: 40GB SSD (노드당)
- **운영체제**: Linux (Debian)
- **컨테이너 런타임**: Docker
- **네트워크**: 리전 내 로컬 네트워크, 리전 간 암호화된 통신

### 2.2 데이터베이스 구성

PostgreSQL 데이터베이스는 다음과 같이 구성됩니다:

- **프라이머리 노드**: 도쿄(nrt) 리전
- **읽기 복제본**: 프랑크푸르트(fra) 및 시드니(syd) 리전
- **VM 크기**: 8 vCPU, 16GB RAM
- **스토리지**: 500GB SSD
- **복제 방식**: 스트리밍 복제 (비동기)
- **백업 전략**: 일일 전체 백업, 15분 간격 증분 백업

### 2.3 네트워크 구성

- **공용 엔드포인트**: 리전별 API 엔드포인트 (\*.automata-signal.com)
- **애니캐스트 IP**: 글로벌 단일 엔드포인트로 가장 가까운 리전으로 라우팅
- **프라이빗 네트워크**: fly.io 내부 네트워크로 노드 및 데이터베이스 간 통신
- **IPv6 지원**: 모든 엔드포인트에서 IPv6 지원

### 2.4 DNS 구성

| 도메인                       | 목적                               |
| ---------------------------- | ---------------------------------- |
| api.automata-signal.com      | 글로벌 API 엔드포인트 (애니캐스트) |
| api-asia.automata-signal.com | 아시아 리전 직접 접근 (도쿄)       |
| api-eu.automata-signal.com   | 유럽 리전 직접 접근 (프랑크푸르트) |
| api-oce.automata-signal.com  | 오세아니아 리전 직접 접근 (시드니) |
| admin.automata-signal.com    | 관리자 대시보드 (향후 구현)        |

## 3. 컨테이너 이미지 및 배포 설정

### 3.1 fly.toml 구성

Automata-Signal의 기본 `fly.toml` 설정:

```toml
# fly.toml

app = "automata-signal"
primary_region = "nrt"

[env]
  PHX_HOST = "api.automata-signal.com"
  PORT = "8080"
  RELEASE_COOKIE = "release_cookie_value_here"
  NODE_COOKIE = "node_cookie_value_here"
  FLY_REGION = "nrt"
  FLY_APP_NAME = "automata-signal"
  DATABASE_URL = "ecto://postgres:password@top1.nearest.of.automata-signal-db.internal:5432/automata_signal"
  SECRET_KEY_BASE = "secret_key_base_value_here"

[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = false
  auto_start_machines = true
  min_machines_running = 3
  processes = ["app"]

  [http_service.concurrency]
    type = "connections"
    hard_limit = 1000
    soft_limit = 800

[[services]]
  protocol = "tcp"
  internal_port = 4369
  processes = ["app"]

  [[services.ports]]
    port = 4369

[metrics]
  port = 9090
  path = "/metrics"

[[vm]]
  cpu_kind = "shared"
  cpus = 4
  memory_mb = 8192

[deploy]
  strategy = "rolling"
  release_command = "eval 'Automata.Release.migrate'"

[mounts]
  source = "automata_storage"
  destination = "/app/uploads"
```

### 3.2 Dockerfile

```dockerfile
FROM hexpm/elixir:1.18.0-erlang-27.0.0-debian-bullseye-20240311 as build

# 빌드 환경 설정
WORKDIR /app
ENV MIX_ENV=prod

# 의존성 파일 복사 및 설치
COPY mix.exs mix.lock ./
COPY config config
COPY apps apps

RUN mix local.hex --force && \
    mix local.rebar --force && \
    mix deps.get --only prod && \
    mix deps.compile

# 릴리스 빌드
RUN mix compile
RUN mix release

# 실행 이미지 준비
FROM debian:bullseye-slim

# 런타임 의존성 설치
RUN apt-get update -y && \
    apt-get install -y libstdc++6 openssl libncurses5 locales ca-certificates && \
    apt-get clean && \
    rm -f /var/lib/apt/lists/*_*

# 로케일 설정
RUN sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen && locale-gen
ENV LANG en_US.UTF-8
ENV LANGUAGE en_US:en
ENV LC_ALL en_US.UTF-8

WORKDIR /app
COPY --from=build /app/_build/prod/rel/automata ./

# 앱 실행
CMD ["/app/bin/automata", "start"]
```

### 3.3 스케일링 설정

자동 스케일링을 위한 구성:

```bash
# 최소 노드 수 설정
fly scale count 4 --app automata-signal-nrt
fly scale count 4 --app automata-signal-fra
fly scale count 4 --app automata-signal-syd

# VM 크기 설정
fly scale vm shared-cpu-4x:8gb --app automata-signal-nrt
fly scale vm shared-cpu-4x:8gb --app automata-signal-fra
fly scale vm shared-cpu-4x:8gb --app automata-signal-syd
```

### 3.4 데이터베이스 배포

PostgreSQL 클러스터 생성 및 구성:

```bash
# 프라이머리 데이터베이스 생성 (도쿄)
fly postgres create --name automata-signal-db --region nrt

# 읽기 복제본 추가 (프랑크푸르트)
fly postgres attach --postgres-app automata-signal-db --app automata-signal-fra

# 읽기 복제본 추가 (시드니)
fly postgres attach --postgres-app automata-signal-db --app automata-signal-syd
```

## 4. 분산 클러스터 구성

### 4.1 libcluster 설정

Elixir 노드 간의 자동 클러스터링을 위한 libcluster 구성:

```elixir
# config/prod.exs
config :libcluster,
  topologies: [
    fly6pn: [
      strategy: Cluster.Strategy.DNSPoll,
      config: [
        polling_interval: 5_000,
        query: "#{System.get_env("FLY_APP_NAME")}.internal",
        node_basename: System.get_env("FLY_APP_NAME")
      ]
    ],
    global_cluster: [
      strategy: Elixir.Cluster.Strategy.Gossip,
      config: [
        secret: System.get_env("CLUSTER_SECRET"),
        hosts: [
          :"automata-signal-nrt@fly-global-services",
          :"automata-signal-fra@fly-global-services",
          :"automata-signal-syd@fly-global-services"
        ]
      ]
    ]
  ]
```

### 4.2 Erlang 분산 설정

Erlang 분산 프로토콜 설정:

```elixir
# config/runtime.exs
config :automata, :distributed,
  cookie: System.fetch_env!("NODE_COOKIE"),
  name: :"#{System.get_env("FLY_APP_NAME")}@#{System.get_env("FLY_PRIVATE_IP")}"
```

### 4.3 분산 Phoenix PubSub 구성

노드 간 이벤트 공유를 위한 PubSub 구성:

```elixir
# lib/automata/application.ex
def start(_type, _args) do
  children = [
    # ... 다른 자식 프로세스들 ...
    {Phoenix.PubSub, name: Automata.PubSub},
    {Phoenix.PubSub.PG2, name: Automata.GlobalPubSub, adapter_name: Automata.PubSub}
  ]

  # ...
end
```

### 4.4 분산 캐시 구성

전역 상태 및 캐시 관리를 위한 Nebulex 설정:

```elixir
# lib/automata/cache.ex
defmodule Automata.Cache do
  use Nebulex.Cache,
    otp_app: :automata,
    adapter: Nebulex.Adapters.Partitioned

  # ...
end

# config/prod.exs
config :automata, Automata.Cache,
  backend: :shards,
  partitions: 8,
  distributed: [
    name: Automata.DistributedCache,
    only_nodes: [node()]
  ]
```

## 5. 데이터베이스 연결 관리

### 5.1 Ecto 리포지토리 설정

PostgreSQL 연결 설정:

```elixir
# config/prod.exs
config :automata, Automata.Repo,
  adapter: Ash.Postgres.Repo,
  url: System.get_env("DATABASE_URL"),
  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "30"),
  socket_options: [:inet6],
  ssl: true,
  ssl_opts: [
    verify: :verify_peer,
    cacertfile: System.get_env("FLY_DB_CA_CERT", "/etc/ssl/certs/ca-certificates.crt"),
    server_name_indication: System.get_env("FLY_DB_HOST") |> String.to_charlist()
  ]
```

### 5.2 읽기/쓰기 분리

읽기와 쓰기 작업을 분리하여 효율성 향상:

```elixir
# lib/automata/repo.ex
defmodule Automata.Repo do
  use Ecto.Repo,
    otp_app: :automata,
    adapter: Ecto.Adapters.Postgres
end

defmodule Automata.ReadOnlyRepo do
  use Ecto.Repo,
    otp_app: :automata,
    adapter: Ecto.Adapters.Postgres

  def init(_, config) do
    config = Keyword.put(config, :url, System.get_env("DATABASE_READ_REPLICA_URL") || System.get_env("DATABASE_URL"))
    {:ok, config}
  end
end

# 사용 예시
defmodule Automata.QueryService do
  def get_analytics_data(params) do
    # 읽기 전용 쿼리는 읽기 복제본 사용
    Automata.ReadOnlyRepo.all(analytics_query(params))
  end

  def update_record(id, params) do
    # 쓰기 작업은 주 데이터베이스 사용
    Automata.Repo.update(...)
  end
end
```

### 5.3 연결 풀 최적화

데이터베이스 연결 풀 최적화 설정:

```elixir
# config/prod.exs
config :automata, Automata.Repo,
  pool_size: String.to_integer(System.get_env("POOL_SIZE") || "30"),
  queue_target: 5000,
  queue_interval: 5000,
  timeout: 60000

config :automata, Automata.ReadOnlyRepo,
  pool_size: String.to_integer(System.get_env("RO_POOL_SIZE") || "50"),
  queue_target: 2000,
  queue_interval: 2000,
  timeout: 30000
```

### 5.4 데이터베이스 마이그레이션

배포 중 안전한 데이터베이스 마이그레이션 방법:

```elixir
# lib/automata/release.ex
defmodule Automata.Release do
  @app :automata

  def migrate do
    load_app()

    for repo <- repos() do
      {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :up, all: true))
    end
  end

  def rollback(repo, version) do
    load_app()
    {:ok, _, _} = Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :down, to: version))
  end

  defp repos do
    Application.fetch_env!(@app, :ecto_repos)
  end

  defp load_app do
    Application.load(@app)
  end
end
```

## 6. 모니터링 및 관찰성

### 6.1 모니터링 아키텍처

시스템 상태 모니터링을 위한 아키텍처:

```mermaid
flowchart LR
    subgraph Apps ["애플리케이션"]
        metrics[Prometheus 측정항목]
        logs[로그 시스템]
        traces[분산 추적]
    end

    subgraph Monitoring ["모니터링 도구"]
        prom[Prometheus]
        loki[Loki]
        tempo[Tempo]
        grafana[Grafana]
    end

    subgraph Alerts ["알림"]
        alertmanager[AlertManager]
        slack[Slack]
        email[이메일]
        pager[PagerDuty]
    end

    metrics --> prom
    logs --> loki
    traces --> tempo

    prom --> grafana
    loki --> grafana
    tempo --> grafana

    prom --> alertmanager
    alertmanager --> slack
    alertmanager --> email
    alertmanager --> pager
```

### 6.2 핵심 지표

모니터링할 핵심 시스템 지표:

1. **시스템 지표**:

   - CPU 사용률
   - 메모리 사용량
   - 디스크 I/O
   - 네트워크 트래픽

2. **애플리케이션 지표**:

   - API 요청 처리량
   - 응답 시간
   - 오류율
   - 동시 연결 수

3. **비즈니스 지표**:
   - 메시지 처리량
   - 전송 성공률
   - 메시지 전환율
   - 채널별 성능

### 6.3 로깅 전략

시스템 로그 관리 전략:

1. **구조화된 로깅**: JSON 형식 로그 생성
2. **중앙 로그 집계**: Loki를 통한 로그 저장 및 쿼리
3. **로그 수준 관리**: 환경별 로그 수준 조정
4. **로그 보존 정책**: 로그 유형별 보존 기간 설정

### 6.4 알림 설정

중요 이벤트 감지 및 알림 전략:

1. **심각도 수준**:

   - 긴급: 즉시 대응 필요한 프로덕션 장애
   - 주요: 성능 저하 또는 부분적 장애
   - 경고: 잠재적 문제 징후
   - 정보: 일반 정보 알림

2. **알림 채널**:

   - Slack: 팀 알림
   - 이메일: 요약 및 일일 보고서
   - PagerDuty: 긴급 상황 온콜 알림

3. **알림 규칙 예시**:
   ```yaml
   # 알림 규칙 예시
   groups:
     - name: automata_signal_alerts
       rules:
         - alert: HighErrorRate
           expr: sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m])) > 0.05
           for: 2m
           labels:
             severity: critical
           annotations:
             summary: 'High error rate detected'
             description: 'Error rate is above 5% for the past 2 minutes'
   ```

### 6.5 대시보드

주요 모니터링 대시보드:

1. **시스템 상태 대시보드**: 전체 시스템 건강 상태 및 핵심 지표
2. **API 성능 대시보드**: API 엔드포인트별 성능 및 오류율
3. **채널 성과 대시보드**: 채널별 전송, 수신, 전환율
4. **리전별 대시보드**: 리전별 성능 및 상태 비교
5. **알림 대시보드**: 현재 활성화된 알림 및 경고

## 7. 고가용성 및 장애 허용성

### 7.1 리전 장애 대응

단일 리전 장애 시 대응 전략:

1. **트래픽 페일오버**: 자동 트래픽 재라우팅
2. **데이터베이스 페일오버**: 복제본을 기본 데이터베이스로 승격
3. **복구 자동화**: 장애 복구 프로세스 자동화

### 7.2 데이터베이스 장애 대응

데이터베이스 장애 시 대응 전략:

1. **읽기 전용 모드**: 기본 DB 장애 시 읽기 전용 모드 운영
2. **자동 복구**: 오류 감지 및 자동 복구 시퀀스
3. **백업 복원**: 최신 백업에서 신속한 복원

### 7.3 노드 장애 대응

단일 노드 장애 시 대응 전략:

1. **상태 점검**: 정기적인 노드 상태 점검
2. **자동 재시작**: 장애 노드 자동 재시작
3. **트래픽 우회**: 장애 노드로의 트래픽 차단

### 7.4 다중 리전 복원력

전역 서비스 가용성을 위한 전략:

1. **리전 격리**: 리전 간 장애 격리
2. **데이터 복제**: 주요 데이터 다중 리전 복제
3. **분산 작업 복구**: 작업 복구 및 재시도 메커니즘

## 8. 확장 전략

### 8.1 수평적 확장

트래픽 증가에 따른 수평적 확장 전략:

1. **새 노드 추가**: 리전별 노드 수 증가

   ```bash
   fly scale count 8 --app automata-signal-nrt
   ```

2. **새 리전 추가**: 주요 사용자 지역에 새 리전 배포

   ```bash
   # 예: IAD(북미, 버지니아) 리전 추가
   fly regions add iad --app automata-signal-iad
   ```

3. **자동 스케일링**: 트래픽 기반 자동 스케일링 설정
   ```bash
   fly autoscale set min=4 max=8 --app automata-signal-nrt
   ```

### 8.2 데이터베이스 확장

데이터 볼륨 증가에 따른 데이터베이스 확장 전략:

1. **수직적 확장**: 더 큰 VM으로 데이터베이스 업그레이드

   ```bash
   fly postgres update vm-size --vm-size performance-8x --app automata-signal-db
   ```

2. **스토리지 확장**: 데이터베이스 볼륨 확장

   ```bash
   fly volumes extend vol_123abcd --size 1000 --app automata-signal-db
   ```

3. **읽기 전용 복제본 추가**: 읽기 작업 분산을 위한 추가 복제본 배포

   ```bash
   fly postgres create --name automata-signal-db-ro --region nrt
   ```

4. **향후 샤딩 전략**: 대규모 데이터를 위한 샤딩 아키텍처 준비
   - 시간 기반 샤딩
   - 애플리케이션 ID 기반 샤딩
   - 리전 기반 샤딩

### 8.3 캐시 계층

성능 향상을 위한 캐시 전략:

1. **Nebulex 분산 캐시**: 노드 간 공유 캐시
2. **Redis 캐시 계층**: 전역 공유 상태 및 임시 데이터 저장
3. **CDN**: 정적 자산 및 API 응답 캐싱

### 8.4 작업 처리 확장

대규모 작업 처리를 위한 확장 전략:

1. **작업 노드 분리**: 전용 작업 처리 노드 배포
2. **작업 분산**: 작업 유형별 전용 큐 및 워커 설정
3. **우선순위 큐**: 중요 작업 우선 처리

## 9. 재해 복구

### 9.1 백업 전략

데이터 손실 방지를 위한 백업 전략:

1. **정기 백업**:

   - 일일 전체 백업
   - 6시간 간격 차등 백업
   - 1시간 간격 증분 백업

2. **백업 저장소**:

   - 리전별 기본 백업
   - 다중 리전 복제 백업
   - 장기 보존을 위한 냉각 저장소

3. **백업 점검**:
   - 정기적인 백업 복원 테스트
   - 백업 무결성 확인

### 9.2 재해 복구 계획

주요 재해 시나리오에 대한 복구 계획:

1. **리전 장애 복구**:

   - 장애 리전 감지
   - 트래픽 재라우팅
   - 새 리전에 인프라 재배포
   - 데이터 복구

2. **데이터베이스 장애 복구**:

   - 복제본 승격
   - 읽기/쓰기 엔드포인트 재구성
   - 새 복제본 생성
   - 장애 노드 복구

3. **애플리케이션 장애 복구**:
   - 장애 노드 식별
   - 노드 교체
   - 클러스터 재구성

### 9.3 복구 시간 목표

서비스 복구 목표:

| 장애 유형         | RTO (복구 시간 목표) | RPO (복구 지점 목표) |
| ----------------- | -------------------- | -------------------- |
| 단일 노드 장애    | 5분                  | 0 (데이터 손실 없음) |
| 단일 리전 장애    | 15분                 | 5분                  |
| 데이터베이스 장애 | 30분                 | 15분                 |
| 다중 리전 장애    | 2시간                | 30분                 |
| 재해 수준 장애    | 4시간                | 1시간                |

### 9.4 재해 복구 테스트

재해 복구 계획 검증을 위한 정기 테스트:

1. **정기 훈련**: 분기별 DR 시뮬레이션
2. **카오스 엔지니어링**: 임의 장애 주입 테스트
3. **리전 페일오버 테스트**: 리전 간 전환 테스트

## 10. 보안 아키텍처

### 10.1 네트워크 보안

네트워크 보안 아키텍처:

1. **TLS/SSL**: 모든 통신에 TLS 1.3 암호화
2. **IP 제한**: 관리 인터페이스 접근 제한
3. **WAF**: 웹 애플리케이션 방화벽 보호
4. **DDoS 방어**: 분산 서비스 거부 공격 방어 메커니즘

### 10.2 애플리케이션 보안

애플리케이션 레벨 보안:

1. **API 인증**: API 키 및 JWT 기반 인증
2. **접근 제어**: 세분화된 권한 관리
3. **입력 검증**: 모든 사용자 입력 검증
4. **의존성 검사**: 정기적인 의존성 취약점 검사

### 10.3 데이터 보안

데이터 보안 방식:

1. **저장 데이터 암호화**: 민감 데이터 암호화 (ash_cloak)
2. **전송 중 암호화**: TLS를 통한 모든 데이터 암호화
3. **접근 로깅**: 민감 데이터 접근 감사 로깅
4. **데이터 최소화**: 필요한 최소한의 데이터만 저장

### 10.4 인증 및 인가

사용자 및 API 인증 메커니즘:

1. **API 키 관리**: 앱별 API 키 관리
2. **토큰 회전**: 정기적 API 키 갱신
3. **세션 관리**: 안전한 관리자 세션 처리
4. **역할 기반 권한**: 세분화된 접근 제어 모델

## 11. 성능 최적화

### 11.1 처리량 최적화

높은 처리량을 위한 최적화:

1. **병렬 처리**: 멀티코어 활용 병렬 작업 처리
2. **비동기 처리**: 작업 큐 기반 비동기 처리
3. **배치 처리**: 대량 작업 배치 처리
4. **연결 풀링**: 효율적인 리소스 활용

### 11.2 지연 시간 최적화

낮은 지연 시간을 위한 최적화:

1. **엣지 배포**: 사용자에 가까운 위치 배포
2. **캐싱 전략**: 다중 계층 캐싱 구현
3. **인덱스 최적화**: 데이터베이스 쿼리 최적화
4. **콜드 경로 분리**: 중요 작업 우선 처리

### 11.3 부하 분산

효율적인 부하 분산 전략:

1. **지역 기반 라우팅**: 사용자에게 가장 가까운 리전으로 라우팅
2. **가중치 기반 분산**: 노드 용량에 따른 트래픽 분산
3. **상태 기반 라우팅**: 노드 상태에 따른 트래픽 조정
4. **캠페인 부하 분산**: 대량 캠페인 다중 노드 분산 처리

### 11.4 성능 테스트 결과 및 목표

성능 테스트 결과 및 목표:

1. **단일 노드 성능**:

   - 초당 최대 메시지 처리량: 5,000-10,000건
   - 평균 메시지 처리 시간: 20ms
   - 최대 연결 수: 10,000

2. **클러스터 성능 (4노드)**:

   - 초당 최대 메시지 처리량: 40,000건
   - 버스트 처리량 (10초): 400,000건
   - 평균 메시지 처리 시간: 25ms

3. **목표 성능 (12노드)**:
   - 초당 최대 메시지 처리량: 100,000건
   - 버스트 처리량 (10초): 1,000,000건
   - 평균 메시지 처리 시간: `<30ms`

## 12. 운영 가이드라인

### 12.1 일반 운영 절차

일상적인 운영 작업:

1. **일일 점검**:

   - 시스템 상태 확인
   - 오류 로그 검토
   - 성능 지표 모니터링

2. **주간 유지보수**:

   - 비정상 노드 교체
   - 성능 최적화
   - 보안 패치 적용

3. **월간 작업**:
   - 용량 계획 검토
   - 확장 요구사항 평가
   - 백업 복원 테스트

### 12.2 인시던트 대응

장애 상황 대응 절차:

1. **감지 및 알림**:

   - 자동 알림 수신
   - 상황 평가
   - 대응팀 소집

2. **초기 대응**:

   - 영향 평가
   - 임시 조치 적용
   - 사용자 커뮤니케이션

3. **해결 및 복구**:

   - 근본 원인 분석
   - 영구적 해결책 적용
   - 서비스 복원 확인

4. **사후 분석**:
   - 인시던트 보고서 작성
   - 개선 사항 식별
   - 재발 방지 대책 수립

### 12.3 변경 관리

시스템 변경 관리 절차:

1. **변경 요청**:

   - 요청 목적 및 범위 정의
   - 영향 평가
   - 롤백 계획 수립

2. **변경 승인**:

   - 기술 검토
   - 리스크 평가
   - 최종 승인

3. **변경 구현**:

   - 점진적 롤아웃
   - 모니터링 강화
   - 테스트 검증

4. **사후 검토**:
   - 변경 결과 평가
   - 문제점 식별
   - 프로세스 개선

### 12.4 용량 계획

리소스 용량 관리:

1. **현재 사용량 분석**:

   - 시스템 리소스 사용률
   - 성장 추세 분석
   - 병목 지점 식별

2. **예측 모델링**:

   - 사용자 증가 예측
   - 메시지 볼륨 예측
   - 스토리지 요구사항 예측

3. **확장 계획**:
   - 단기 확장 계획
   - 중기 확장 계획
   - 장기 인프라 로드맵

## 13. 관련 문서

- [GUIDE-005] 배포 워크플로우 - CI/CD 프로세스 및 배포 절차
- [GUIDE-003] 개발 워크플로우 - AI 주도 개발 방법론
- [DESIGN-002] 시스템 아키텍처 - 시스템 컴포넌트 구조
- [DESIGN-003] 데이터 모델 - 데이터베이스 스키마 및 관계

---

// File: automata-signal/2-designs/DESIGN-005-admin-user-scenarios

# [DESIGN-005] 어드민 유저 시나리오

## 요약

Automata-Signal은 다양한 메시징 채널을 통합 관리하는 플랫폼으로, 현재는 푸시 알림만 지원하나 향후 인앱푸시, SMS, 이메일, 카카오알림톡으로 확장 예정입니다. 통합 대시보드, 메시지 작성/발송, 이력 관리, 상세 분석 기능을 제공하며, 채널별 특화된 메시지 작성과 일관된 분석 경험을 제공합니다. 모든 채널은 동일한 워크플로우로 관리되어 확장성과 사용 편의성을 높였습니다.

## 핵심 기능 영역

1. **통합 대시보드** - 첫 화면으로 모든 채널의 주요 지표를 한눈에 확인
2. **메시지 보내기** - 여기서 채널 선택 후 채널별 특화된 메시지 작성
3. **발송이력** - 모든 채널의 발송 이력을 채널별 탭으로 관리
4. **디바이스 통계** - 사용자 환경 분석

### IA (구조 중심)

```mermaid
flowchart TD
    MC[메시지 센터]
    MC --- D[대시보드]
    MC --- MM[메시지 관리]
    MC --- HS[발송 이력]
    MC --- DS[디바이스 통계]
    MC --- ST[시스템 설정]

    D --- D1[종합 지표]
    D --- D2[실시간 현황]
    D --- D3[기간별 분석]

    MM --- MM1[메시지 보내기]
    MM --- MM2[템플릿 관리]
    MM --- MM3[예약 관리]

    MM1 --- C1[푸시 알림]
    MM1 --- C2[인앱푸시]
    MM1 --- C3[SMS]
    MM1 --- C4[이메일]
    MM1 --- C5[카카오알림톡]

    HS --- HS1[채널별 이력]
    HS1 --- HS11[푸시 알림 이력]
    HS1 --- HS12[인앱푸시 이력]
    HS1 --- HS13[SMS 이력]
    HS1 --- HS14[이메일 이력]
    HS1 --- HS15[카카오알림톡 이력]

    HS11 --- HS111[메시지별 이력]
    HS11 --- HS112[사용자별 이력]

    HS111 --- HS1111[일반 발송]
    HS111 --- HS1112[API 발송]

    DS --- DS1[활성 디바이스]
    DS --- DS2[플랫폼 통계]
    DS --- DS3[버전 통계]

    ST --- ST1[계정 관리]
    ST --- ST2[채널 설정]
    ST --- ST3[알림 설정]
```

### 유저 플로우 (사용자 중심)

```mermaid
flowchart LR
    S[시작] --> L[로그인]
    L --> D[대시보드 확인]

    D --> CreateMsg[메시지 작성하기]
    CreateMsg --> SelectChannel[채널 선택]
    SelectChannel --> PushMsg[푸시 알림 선택]
    PushMsg --> InputTitle[제목 입력]
    InputTitle --> InputContent[내용 입력]
    InputContent --> UploadImage[이미지 업로드]
    UploadImage --> SetAction[클릭 동작 설정]
    SetAction --> SetTarget[발송 대상 설정]
    SetTarget --> Preview[미리보기]
    Preview --> TestSend[테스트 발송]
    TestSend --> Confirm[확인 및 수정]
    Confirm --> Send[발송하기]
    Send --> Success[발송 완료]

    D --> CheckHistory[발송 이력 확인하기]
    CheckHistory --> SelectChannel2[채널 선택]
    SelectChannel2 --> PushHistory[푸시 알림 이력]
    PushHistory --> FilterMessage[필터 적용]
    FilterMessage --> ViewList[이력 목록 확인]
    ViewList --> SelectMsg[특정 메시지 선택]
    SelectMsg --> ViewReport[상세 리포트 확인]
    ViewReport --> AnalyzeData[데이터 분석]

    D --> SearchUser[사용자별 이력 조회하기]
    SearchUser --> InputID[식별자 입력]
    InputID --> ViewUserHistory[사용자 이력 확인]
    ViewUserHistory --> FilterUserMsg[필터 적용]
    FilterUserMsg --> ViewUserReport[상세 이력 확인]
```

## 주요 기능 영역별 유저 시나리오

### 1. 통합 대시보드 (메시지 센터 > 대시보드)

| 기능                 | 유저 시나리오                                                                                                                                                                                                                                                                                                             |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 리프레시             | 원하는 시점에 대시보드 데이터를 확인할 수 있도록 리프레시 버튼을 클릭하여 데이터를 갱신할 수 있다.                                                                                                                                                                                                                        |
| 당월 메시지 현황     | 당월 메시지의 전체적인 현황을 간략히 확인하기 위해서 당월 발송완료된 메시지와 당일 앱 접속 수치를 확인할 수 있다. (현재는 푸시 채널만 표시)                                                                                                                                                                               |
| 실시간 앱 활성 수치  | 메시지 발송 시점의 앱 활성 상태를 파악하기 위해서 현재 시점으로부터 20분간의 분당 실시간 앱 접속 수치를 확인할 수 있다.                                                                                                                                                                                                   |
| 최근 발송이력        | 최근 발송한 메시지들의 성과를 분석하기 위해 최근 발송한 5개의 메시지의 성과내역을 확인할 수 있다. (현재는 푸시 채널만 표시)<br />개별 이력의 상세 분석을 위해 상세 리포트 확인 버튼을 클릭하여 리포트 페이지로 접근할 수 있다.                                                                                            |
| 앱 접속 요일 및 시간 | 적절한 메시지 발송 타이밍을 확인하기 위해서, 원하는 시점(월)을 필터링하여 요일 및 시간대별 접속량을 시각적으로 확인할 수 있다.                                                                                                                                                                                            |
| 디바이스 통계        | 기기별 메시지 발송 현황을 확인하기 위해서 전체 활성 디바이스와 Android, IOS 기기의 비율 및 수치를 시각적으로 확인할 수 있다.                                                                                                                                                                                              |
| 월간 지표 추이       | 메시지 발송 후 오픈률 추이를 분석하기 위해, 월별, 일자별 푸시 발송 수와 오픈 수의 변화를 시각적으로 확인할 수 있다.<br />메시지의 사용자 반응률을 분석하기 위해, 월별, 일자별 앱 접속 수 추이를 확인할 수 있다.<br />메시지가 앱 유지율에 미친 영향을 파악하기 위해, 월별, 일자별 앱 설치, 삭제 수 추이를 확인할 수 있다. |

### 2. 메시지 보내기 (메시지 센터 > 메시지 보내기)

| 기능      | 유저 시나리오                                                                                                 |
| --------- | ------------------------------------------------------------------------------------------------------------- |
| 채널 선택 | 메시지를 발송할 채널(푸시, 인앱푸시, SMS, 이메일, 카카오알림톡)을 선택할 수 있다. (현재는 푸시 채널만 활성화) |

#### 2.1 푸시 알림 채널 (현재 활성화)

| 기능                   | 유저 시나리오                                                                                                                                                                                                                                                                                                                     |
| ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 발송 타입 설정         | 수신 동의 여부에 따라 자동으로 발송 대상이 분기되도록 발송 유형(광고/정보)을 선택할 수 있다.                                                                                                                                                                                                                                      |
| 푸시 제목 및 내용 설정 | 엔드유저가 푸시 메시지의 제목을 확인할 수 있도록 제목을 설정할 수 있다.<br />엔드유저가 푸시 메시지의 내용을 확인할 수 있도록 내용을 설정할 수 있다.                                                                                                                                                                              |
| 푸시 이미지 설정       | 푸시 메세지에 이미지가 함께 표시될 수 있도록 메시지에 사용할 이미지를 업로드하거나 외부 이미지 URL을 입력할 수 있다.                                                                                                                                                                                                              |
| 푸시 클릭 시 동작 설정 | 푸시 오픈 후 엔드유저의 행동 경로를 마케팅 목적에 맞게 유도하기 위해, 푸시 오픈 시, 알림 상세 화면 또는 지정한 URL 페이지로 이동하도록 설정할 수 있다.<br />푸시 오픈 후 엔드유저의 행동 경로를 효과적으로 유도하기 위해, 버튼명을 설정할 수 있다.                                                                                |
| 발송 일시              | 원하는 시간에 푸시 메세지를 발송하기 위해, 발송 시간(즉시,예약)을 설정할 수 있다.                                                                                                                                                                                                                                                 |
| 대상 고객 수           | 메시지 도달 범위를 사전에 파악하기 위해, 설정한 조건에 따라 변경되는 발송 대상 고객 수를 확인할 수 있다.                                                                                                                                                                                                                          |
| 발송 대상 & 발송 기기  | 마케팅 타겟에 맞는 대상에게 메세지를 보내기 위해, 전체 고객 또는 특정 고객을 발송 대상으로 설정할 수 있다.<br />특정 대상 고객을 타게팅하기 위해, 엑셀 업로드를 통해 특정 대상 고객군을 설정할 수 있다.<br />기기별로 메시지를 구분해서 보내기 위해, 대상기기를 전체 또는 특정 기기(IOS, Android)로 선택해 푸시를 발송할 수 있다. |
| 테스트 발송            | 실제 발송 전 메시지를 검토하기 위해 메시지를 사전에 테스트 발송할 수 있다.                                                                                                                                                                                                                                                        |
| 발송하기               | 엔드유저에게 실제로 메시지를 발송하기 위해 푸시 메세지를 즉시 또는 예약한 시간에 발송할 수 있다.                                                                                                                                                                                                                                  |
| 미리보기               | 푸시 메시지의 기기별 실제 노출 형태를 사전에 확인하기 위해, IOS 혹은 Android 환경에서의 푸시 메시지를 미리볼 수 있다.                                                                                                                                                                                                             |

### 3. 발송이력 관리 (메시지 센터 > 발송이력)

| 기능      | 유저 시나리오                                                                           |
| --------- | --------------------------------------------------------------------------------------- |
| 채널별 탭 | 각 메시징 채널별 발송 이력을 개별 탭으로 확인할 수 있다. (현재는 푸시 알림 탭만 활성화) |

#### 3.1 푸시 알림 채널 (현재 활성화)

| 기능               | 유저 시나리오                                                        |
| ------------------ | -------------------------------------------------------------------- |
| 메시지별 이력 조회 | 푸시 알림 채널에서 발송된 모든 메시지 이력을 조회할 수 있다.         |
| 사용자별 이력 조회 | 특정 사용자(식별자)에게 발송된 모든 푸시 알림 이력을 조회할 수 있다. |

##### 3.1.1 메시지별 이력 조회 - 일반 발송

| 기능            | 유저 시나리오                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 검색            | 특정 기간동안 발송된 푸시 메시지 성과를 간략히 확인하기 위해서 기간 선택 필터를 활용하여 발송이력을 조회할 수 있다.<br />식별자별 이력을 확인하기 위해서, 식별자를 기준으로 발송이력을 검색할 수 있다.<br />발송 상태를 기준으로 푸시 메시지를 간략히 조회하기 위해, 발송 상태별 Chip filter를 사용하여 각 상태별 이력을 확인할 수 있다.<br />원하는 데이터를 빠르게 조회하기 위해서, 입력한 조건으로 검색하거나 검색조건을 간편하게 초기화할 수 있다. |
| 발송이력 테이블 | 발송이력의 건별 주요지표를 간단히 확인하기 위해 발송대상, 유형, 내용, 일시 등의 요소를 확인할 수 있다.<br />개별 발송건에 대한 상세한 분석을 위해서, '리포트 확인' 버튼을 클릭하여 상세 리포트 페이지로 이동할 수 있다.<br />원하는 시점에 최신 데이터를 확인하기 위해서, 리프레시 버튼을 클릭하여 개별 발송건의 데이터를 갱신할 수 있다.                                                                                                              |

##### 3.1.2 메시지별 이력 조회 - API 발송

| 기능            | 유저 시나리오                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 검색            | 특정 기간동안 발송된 푸시 메시지 성과를 간략히 확인하기 위해서 기간 선택 필터를 활용하여 발송이력을 조회할 수 있다.<br />발송 상태를 기준으로 푸시 메시지를 간략히 조회하기 위해, 발송 상태별 Chip filter를 사용하여 각 상태별 이력을 확인할 수 있다.<br />원하는 데이터를 빠르게 조회하기 위해서, 입력한 조건으로 검색하거나 검색조건을 간편하게 초기화할 수 있다.<br />식별자별 발송된 메세지 이력을 확인하기 위해, 식별자를 기준으로 발송이력을 검색할 수 있다.                         |
| 발송이력 테이블 | 발송이력의 건별 주요지표를 간단히 확인하기 위해 발송대상, 유형, 내용, 일시 등의 요소를 확인할 수 있다.<br />개별 발송건에 대한 상세한 분석을 위해서, '리포트 확인' 버튼을 클릭하여 상세 리포트 페이지로 이동할 수 있다.<br />원하는 시점에 최신 데이터를 확인하기 위해서, 리프레시 버튼을 클릭하여 개별 발송건의 데이터를 갱신할 수 있다.<br />일시적 오류나 네트워크 문제 등으로 발송 실패한 건을 복구하기 위해, 발송 실패 건에 대해 재발송 버튼을 클릭하여 해당 푸시를 재발송할 수 있다. |

##### 3.1.3 사용자별 이력 조회

| 기능           | 유저 시나리오                                                                                                                 |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| 식별자 검색    | 입력한 문자열을 포함하는 식별자를 검색하기 위해, like 검색 방식으로 식별자를 기준으로한 발송이력을 조회할 수 있다.            |
| 발송 이력 확인 | 특정 식별자의 상세한 발송 내역을 확인하기 위해, 발송 이력 확인 버튼을 클릭하여 해당 식별자의 푸시 발송 이력을 확인할 수 있다. |

### 4. 상세 리포트 (메시지 센터 > 발송이력 > 푸시 알림 > 메시지별 이력 조회 > 리포트 확인)

| 기능                               | 유저 시나리오                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 발송 대상                          | 푸시 메시지가 총 몇 명의 대상에게 발송되었는지 확인하기 위해, 설정된 전체 발송 대상 수를 확인할 수 있다.                                                                                                                                                                                                                                                                                                                                                                                                                             |
| 주요 지표 요약                     | 메시지 성과를 빠르게 요약하여 파악하기 위해, 핵심지표인 발송완료, 실패, 오픈 앱 삭제 수치를 확인할 수 있다.                                                                                                                                                                                                                                                                                                                                                                                                                          |
| 푸시 발송 기기                     | 발송 대상 플랫폼별 성과를 빠르게 요약하기 위해서, 핵심지표를 기기별로 구분하여 확인할 수 있다.<br />IOS와 Android 기기 비중을 한눈에 파악하기 위해서 디바이스별 발송 비율 및 수치를 시각적으로 확인할 수 있다.                                                                                                                                                                                                                                                                                                                       |
| 발송 상태                          | 해당 푸시가 정상적으로 발송이 완료되었는지를 한눈에 확인하기 위해 발송상태와 진행률을 시각적으로 확인할 수 있다.<br />발송의 정확한 실행 시간과 상태를 확인하기 위해서, 발송완료 수, 잔여 수, 발송 시작 및 완료 시간을 한눈에 확인할 수 있다.<br />잘못된 푸시발송으로 인해 마케팅 실패 방지를 위하여 발송 일시 중지 버튼을 클릭하여 푸시 발송을 중지시킬 수 있다.                                                                                                                                                                   |
| 메세지 상세                        | 푸시 발송 시 설정한 내용을 확인하기 위해, 푸시 상세보기 버튼을 클릭하여 read only 상태의 설정내역을 확인할 수 있다.<br />실제 발송된 푸시를 쉽게 인지하고 구별하기 위해서 IOS/Android 환경을 전환하며 푸시 메세지를 확인할 수 있다.                                                                                                                                                                                                                                                                                                  |
| 메세지 도달에 따른 앱 실행 수 변동 | 푸시 발송의 효과가 언제부터 어느정도 나타나는지를 확인하기 위해 메시지 도달 이후 사용자 실행 수의 추이를 시간대별로 확인할 수 있다.<br />푸시 발송이 활성 사용자 수 변화에 미친 영향을 분석하기 위해서, 메시지 발송 후 앱 사용자 수 변화의 추이를 확인할 수 있다.<br />푸시 발송에 따른 즉시 반응률과 지연 반응률을 확인하기 위해 푸시 메시지 오픈까지 걸린 시간을 일정 구간별로 확인하고 싶다.<br />해당 푸시를 특정 식별자가 정상적으로 받았고, 푸시에 대하여 반응했는지를 확인하기 위해 해당 푸시를 받은 식별자를 검색할 수 있다. |

### 5. 디바이스 통계 (메시지 센터 > 디바이스 통계)

| 기능                 | 유저 시나리오                                                                                                                                                                        |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 디바이스 트렌드 분석 | 시간 흐름에 따른 디바이스 트렌드를 분석하기 위해서, 선택한 디바이스 탭에 해당하는 데이터를 설정한 기간에 따라 일별 변화량을 시각적으로 확인할 수 있다.                               |
| 플랫폼별 분포        | 디바이스 트랜드의 플랫폼별 분포를 정량적으로 파악하기 위해, 선택한 디바이스 탭에 해당하는 데이터의 기간에 따른 Android, IOS, 합계수치를 일별 증감률 및 상세 데이터를 확인할 수 있다. |
| 장기 추이 파악       | 시즌성, 장기 추이를 파악하기 위해서, 선택한 디바이스 탭에 해당하는 데이터의 선택한 연도의 월별 수치를 시각적으로 확인할 수 있다.                                                     |
| 월별 상세 분석       | 월별 디바이스 수 변경 추이를 상세 분석하기 위해서, 각 월의 디바이스 수와 증감을 확인할 수 있다.                                                                                      |

---

// File: automata-signal/3-components/COMP-002-adapters

# [COMP-002] 어댑터 시스템

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [DESIGN-001] 아키텍처 개요
- [REF-002] 상태 코드
- [SEQ-002] 메시지 처리 시퀀스
- [SEQ-003] 라이프사이클 시퀀스

## 요약

본 문서는 Automata-Signal의 채널 어댑터 시스템에 대한 상세 설계와 구현 방법을 설명합니다. 채널 어댑터는 다양한 메시징 채널(푸시 알림, 이메일, SMS 등)과의 통합을 담당하는 모듈화된 컴포넌트입니다. 확장 가능하고 유지보수가 용이한 설계를 통해 새로운 채널을 쉽게 추가할 수 있습니다.

## 대상 독자

- 백엔드 개발자
- 시스템 아키텍트
- 채널 통합 담당자
- QA 엔지니어

## 1. 어댑터 시스템 개요

채널 어댑터 시스템은 다양한 메시징 채널과의 통합을 일관된 인터페이스로 추상화하는 핵심 컴포넌트입니다. 이를 통해 메시지 처리 코어 시스템은 각 채널의 특성과 구현 세부사항을 알 필요 없이 표준화된 방식으로 메시지를 전송할 수 있습니다.

### 1.1 주요 목표

- **일관된 인터페이스**: 모든 채널에 대해 동일한 메시지 전송 인터페이스 제공
- **확장성**: 새로운 채널을 최소한의 코드 변경으로 추가 가능
- **채널 독립성**: 각 채널의 구현이 다른 채널에 영향을 주지 않음
- **오류 처리 통합**: 다양한 채널별 오류를 표준화된 형식으로 변환
- **성능 최적화**: 각 채널별 최적화된 전송 전략 적용

### 1.2 채널 어댑터 아키텍처 다이어그램

```mermaid
classDiagram
    class ChannelAdapter {
        <<interface>>
        +send_message(message) Result
        +validate_message(message) Result
        +get_status(message_id) Result
        +map_error(error) Error
    }

    class PushAdapter {
        -apns_config
        -fcm_config
        +send_message(message) Result
        +validate_message(message) Result
        +get_status(message_id) Result
        +map_error(error) Error
        -send_ios_message(message) Result
        -send_android_message(message) Result
        -get_apns_config(subscription) Config
        -map_apns_error(error) Error
        -map_fcm_error(error) Error
    }

    class EmailAdapter {
        -smtp_config
        +send_message(message) Result
        +validate_message(message) Result
        +get_status(message_id) Result
        +map_error(error) Error
        -format_email(message) Email
        -track_open(message) Message
        -track_links(message) Message
    }

    class SMSAdapter {
        -sms_gateway_config
        +send_message(message) Result
        +validate_message(message) Result
        +get_status(message_id) Result
        +map_error(error) Error
        -format_sms(message) SMS
        -select_gateway(message) Gateway
    }

    class KakaoAdapter {
        -kakao_api_config
        +send_message(message) Result
        +validate_message(message) Result
        +get_status(message_id) Result
        +map_error(error) Error
        -select_template(message) Template
        -format_template_variables(message) Variables
    }

    class InAppAdapter {
        +send_message(message) Result
        +validate_message(message) Result
        +get_status(message_id) Result
        +map_error(error) Error
        -format_in_app_message(message) InAppMessage
    }

    class AdapterFactory {
        +get_adapter_for_subscription(subscription) ChannelAdapter
        +get_adapter_for_channel_type(channel_type) ChannelAdapter
    }

    ChannelAdapter <|.. PushAdapter
    ChannelAdapter <|.. EmailAdapter
    ChannelAdapter <|.. SMSAdapter
    ChannelAdapter <|.. KakaoAdapter
    ChannelAdapter <|.. InAppAdapter

    AdapterFactory --> ChannelAdapter
```

## 2. 어댑터 인터페이스

모든 채널 어댑터는 다음과 같은 공통 인터페이스를 구현합니다:

```elixir
defmodule AutomataSignal.Adapters.ChannelAdapter do
  @callback send_message(message :: AutomataSignal.Resources.Message.t()) ::
    {:ok, map()} | {:error, map()}

  @callback validate_message(message :: AutomataSignal.Resources.Message.t()) ::
    :ok | {:error, reason :: atom(), details :: map()}

  @callback get_status(message_id :: String.t()) ::
    {:ok, status :: atom()} | {:error, reason :: atom()}

  @callback map_error(error :: any()) ::
    {:permanent, reason :: atom(), details :: map()} |
    {:temporary, reason :: atom(), details :: map()}
end
```

### 2.1 인터페이스 메서드 설명

#### 2.1.1 send_message/1

메시지를 해당 채널을 통해 전송하는 핵심 메서드입니다.

- **입력**: `Message` 구조체 (제목, 본문, 데이터, 구독 정보 등)
- **출력**: 성공 시 `{:ok, response_data}`, 실패 시 `{:error, error_data}`
- **책임**:
  - 메시지를 채널에 맞는 형식으로 변환
  - 외부 서비스 API 호출
  - 응답 처리 및 결과 반환

#### 2.1.2 validate_message/1

메시지가 해당 채널에 적합한지 검증하는 메서드입니다.

- **입력**: `Message` 구조체
- **출력**: 유효 시 `:ok`, 무효 시 `{:error, reason, details}`
- **책임**:
  - 필수 필드 검증
  - 채널별 제한사항 검사 (길이, 형식 등)
  - 유효하지 않은 경우 상세 오류 정보 제공

#### 2.1.3 get_status/1

특정 메시지의 현재 상태를 조회하는 메서드입니다.

- **입력**: 메시지 ID (채널별 고유 식별자)
- **출력**: 성공 시 `{:ok, status}`, 실패 시 `{:error, reason}`
- **책임**:
  - 외부 서비스 API를 통한 상태 조회
  - 표준화된 상태값으로 변환

#### 2.1.4 map_error/1

채널별 오류를 표준화된 형식으로 변환하는 메서드입니다.

- **입력**: 채널 특정 오류 객체/메시지
- **출력**: `{:permanent, reason, details}` 또는 `{:temporary, reason, details}`
- **책임**:
  - 영구적/일시적 오류 분류
  - 오류 코드 및 메시지 표준화
  - 구독 상태 코드 매핑

## 3. 채널 어댑터 구현

### 3.1 푸시 알림 어댑터

푸시 알림 어댑터는 iOS(APNS)와 Android(FCM) 플랫폼 모두를 지원합니다.

```elixir
defmodule AutomataSignal.Adapters.PushAdapter do
  @behaviour AutomataSignal.Adapters.ChannelAdapter
  alias AutomataSignal.Resources.Message
  alias AutomataSignal.Resources.Subscription

  # APNS 설정
  @apns_config %{
    cert: {:file, "path/to/cert.pem"},
    key: {:file, "path/to/key.pem"},
    mode: :prod  # :dev 또는 :prod
  }

  # FCM 설정
  @fcm_config %{
    key: "your_server_key"
  }

  @impl true
  def send_message(%Message{subscription: subscription} = message) do
    # 메시지 검증
    case validate_message(message) do
      :ok ->
        # 구독 유형에 따라 적절한 전송 방법 선택
        case subscription.type do
          :iOSPush -> send_ios_message(message)
          :AndroidPush -> send_android_message(message)
          _ -> {:error, %{reason: :invalid_subscription_type}}
        end

      error ->
        error
    end
  end

  @impl true
  def validate_message(%Message{} = message) do
    cond do
      is_nil(message.title) and is_nil(message.body) ->
        {:error, :missing_content, %{message: "Both title and body cannot be empty"}}

      byte_size(message.title || "") > 150 ->
        {:error, :title_too_long, %{message: "Title exceeds maximum length (150 bytes)"}}

      byte_size(message.body || "") > 4000 ->
        {:error, :body_too_long, %{message: "Body exceeds maximum length (4000 bytes)"}}

      is_nil(message.subscription) or is_nil(message.subscription.token) ->
        {:error, :missing_token, %{message: "Push token is required"}}

      true ->
        :ok
    end
  end

  @impl true
  def get_status(message_id) do
    # 대부분의 푸시 서비스는 상태 조회 API를 제공하지 않으므로
    # 로컬 상태 저장소에서 조회
    {:error, :not_supported}
  end

  @impl true
  def map_error(error) do
    case error do
      # APNS 오류 매핑
      %{reason: "BadDeviceToken"} ->
        {:permanent, :invalid_token, %{
          code: "BadDeviceToken",
          subscription_status: -10
        }}

      %{reason: "DeviceTokenNotForTopic"} ->
        {:permanent, :token_topic_mismatch, %{
          code: "DeviceTokenNotForTopic",
          subscription_status: -14
        }}

      # FCM 오류 매핑
      %{error: "NotRegistered"} ->
        {:permanent, :unregistered, %{
          code: "NotRegistered",
          subscription_status: -10
        }}

      %{error: "InvalidRegistration"} ->
        {:permanent, :invalid_token, %{
          code: "InvalidRegistration",
          subscription_status: -4
        }}

      # 서비스 일시적 오류
      %{status: code} when code >= 500 ->
        {:temporary, :server_error, %{
          code: "ServerError",
          status: code
        }}

      # 기본 오류 처리
      _ ->
        {:permanent, :unknown_error, %{
          original_error: inspect(error)
        }}
    end
  end

  # 내부 헬퍼 메서드

  defp send_ios_message(%Message{} = message) do
    notification = %{
      token: message.subscription.token,
      topic: get_bundle_id(message.application),
      notification: %{
        title: message.title,
        body: message.body
      },
      custom: message.data
    }

    case Pigeon.APNS.push(notification, get_apns_config(message.subscription)) do
      {:ok, data} ->
        {:ok, %{provider_message_id: data.id}}
      {:error, reason} ->
        {:error, reason}
    end
  end

  defp send_android_message(%Message{} = message) do
    notification = %{
      to: message.subscription.token,
      notification: %{
        title: message.title,
        body: message.body
      },
      data: message.data
    }

    case Pigeon.FCM.push(notification) do
      {:ok, data} ->
        {:ok, %{provider_message_id: data.id}}
      {:error, reason} ->
        {:error, reason}
    end
  end

  # 디바이스의 test_type에 따라 APNS 환경 결정
  defp get_apns_config(%Subscription{test_type: 1}), do: %{@apns_config | mode: :dev}
  defp get_apns_config(%Subscription{test_type: 2}), do: %{@apns_config | mode: :dev}
  defp get_apns_config(_), do: @apns_config

  defp get_bundle_id(application) do
    # 앱 설정에서 번들 ID 조회 로직
    application.settings["ios_bundle_id"] || "com.default.app"
  end
end
```

### 3.2 이메일 어댑터 (지원 예정)

이메일 어댑터는 SMTP 또는 AWS SES와 같은 이메일 서비스와 통합됩니다.

```elixir
defmodule AutomataSignal.Adapters.EmailAdapter do
  @behaviour AutomataSignal.Adapters.ChannelAdapter
  alias AutomataSignal.Resources.Message

  @impl true
  def send_message(%Message{subscription: %{type: :Email, token: email}} = message) do
    # 향후 구현 예정
    {:error, %{reason: :not_implemented_yet}}
  end

  @impl true
  def validate_message(%Message{} = message) do
    cond do
      is_nil(message.title) ->
        {:error, :missing_subject, %{message: "Email subject is required"}}

      is_nil(message.body) ->
        {:error, :missing_body, %{message: "Email body is required"}}

      # 이메일 형식 검증
      not valid_email?(message.subscription.token) ->
        {:error, :invalid_email, %{message: "Invalid email format"}}

      true ->
        :ok
    end
  end

  @impl true
  def get_status(_message_id) do
    # 향후 구현 예정
    {:error, :not_implemented_yet}
  end

  @impl true
  def map_error(_error) do
    # 향후 구현 예정
    {:permanent, :not_implemented_yet, %{}}
  end

  # 내부 헬퍼 메서드

  defp valid_email?(email) do
    # 간단한 이메일 형식 검증 로직
    Regex.match?(~r/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/, email)
  end
end
```

### 3.3 SMS 어댑터 (지원 예정)

SMS 어댑터는 다양한 SMS 게이트웨이와 통합됩니다.

```elixir
defmodule AutomataSignal.Adapters.SMSAdapter do
  @behaviour AutomataSignal.Adapters.ChannelAdapter
  alias AutomataSignal.Resources.Message

  @impl true
  def send_message(%Message{subscription: %{type: :SMS, token: phone_number}} = message) do
    # 향후 구현 예정
    {:error, %{reason: :not_implemented_yet}}
  end

  @impl true
  def validate_message(%Message{} = message) do
    cond do
      is_nil(message.body) ->
        {:error, :missing_body, %{message: "SMS body is required"}}

      byte_size(message.body) > 160 ->
        {:error, :body_too_long, %{message: "SMS body exceeds 160 characters"}}

      # 전화번호 형식 검증
      not valid_phone_number?(message.subscription.token) ->
        {:error, :invalid_phone_number, %{message: "Invalid phone number format"}}

      true ->
        :ok
    end
  end

  @impl true
  def get_status(_message_id) do
    # 향후 구현 예정
    {:error, :not_implemented_yet}
  end

  @impl true
  def map_error(_error) do
    # 향후 구현 예정
    {:permanent, :not_implemented_yet, %{}}
  end

  # 내부 헬퍼 메서드

  defp valid_phone_number?(phone) do
    # 간단한 전화번호 형식 검증 로직
    Regex.match?(~r/^\+?[0-9]{10,15}$/, phone)
  end
end
```

### 3.4 카카오 알림톡 어댑터 (지원 예정)

카카오 알림톡 어댑터는 카카오 비즈니스 API와 통합됩니다.

```elixir
defmodule AutomataSignal.Adapters.KakaoAdapter do
  @behaviour AutomataSignal.Adapters.ChannelAdapter
  alias AutomataSignal.Resources.Message

  @impl true
  def send_message(%Message{subscription: %{type: :KakaoTalk, token: phone_number}} = message) do
    # 향후 구현 예정
    {:error, %{reason: :not_implemented_yet}}
  end

  @impl true
  def validate_message(%Message{} = message) do
    cond do
      is_nil(message.data) || is_nil(message.data["template_code"]) ->
        {:error, :missing_template, %{message: "Kakao template code is required"}}

      # 템플릿 변수 검증
      not valid_template_variables?(message.data) ->
        {:error, :invalid_template_variables, %{message: "Invalid template variables"}}

      true ->
        :ok
    end
  end

  @impl true
  def get_status(_message_id) do
    # 향후 구현 예정
    {:error, :not_implemented_yet}
  end

  @impl true
  def map_error(_error) do
    # 향후 구현 예정
    {:permanent, :not_implemented_yet, %{}}
  end

  # 내부 헬퍼 메서드

  defp valid_template_variables?(data) do
    # 템플릿 변수 검증 로직
    # 향후 구현 예정
    true
  end
end
```

### 3.5 인앱 메시지 어댑터 (지원 예정)

인앱 메시지 어댑터는 클라이언트 SDK와 통합됩니다.

```elixir
defmodule AutomataSignal.Adapters.InAppAdapter do
  @behaviour AutomataSignal.Adapters.ChannelAdapter
  alias AutomataSignal.Resources.Message

  @impl true
  def send_message(%Message{subscription: %{type: :InAppMessage}} = message) do
    # 향후 구현 예정
    {:error, %{reason: :not_implemented_yet}}
  end

  @impl true
  def validate_message(%Message{} = message) do
    cond do
      is_nil(message.title) and is_nil(message.body) ->
        {:error, :missing_content, %{message: "Both title and body cannot be empty"}}

      is_nil(message.data) || is_nil(message.data["layout_type"]) ->
        {:error, :missing_layout, %{message: "Layout type is required for in-app messages"}}

      true ->
        :ok
    end
  end

  @impl true
  def get_status(_message_id) do
    # 향후 구현 예정
    {:error, :not_implemented_yet}
  end

  @impl true
  def map_error(_error) do
    # 향후 구현 예정
    {:permanent, :not_implemented_yet, %{}}
  end
end
```

## 4. 어댑터 팩토리

어댑터 팩토리는 메시지나 구독 정보를 기반으로 적절한 채널 어댑터를 선택하는 역할을 합니다.

```elixir
defmodule AutomataSignal.Adapters.AdapterFactory do
  alias AutomataSignal.Resources.Subscription
  alias AutomataSignal.Resources.Message

  alias AutomataSignal.Adapters.PushAdapter
  alias AutomataSignal.Adapters.EmailAdapter
  alias AutomataSignal.Adapters.SMSAdapter
  alias AutomataSignal.Adapters.KakaoAdapter
  alias AutomataSignal.Adapters.InAppAdapter

  @doc """
  구독 정보를 기반으로 적절한 채널 어댑터를 반환합니다.
  """
  def get_adapter_for_subscription(%Subscription{type: type}) do
    get_adapter_for_channel_type(type)
  end

  @doc """
  채널 유형을 기반으로 적절한 채널 어댑터를 반환합니다.
  """
  def get_adapter_for_channel_type(channel_type) do
    case channel_type do
      :iOSPush -> PushAdapter
      :AndroidPush -> PushAdapter
      :Email -> EmailAdapter
      :SMS -> SMSAdapter
      :KakaoTalk -> KakaoAdapter
      :InAppMessage -> InAppAdapter
      _ -> raise "Unsupported channel type: #{inspect(channel_type)}"
    end
  end

  @doc """
  메시지 객체를 기반으로 적절한 채널 어댑터를 반환합니다.
  """
  def get_adapter_for_message(%Message{subscription: subscription}) do
    get_adapter_for_subscription(subscription)
  end
end
```

## 5. 메시지 전송 프로세스

어댑터 시스템을 사용한 메시지 전송 프로세스는 다음과 같습니다:

```elixir
defmodule AutomataSignal.Services.MessageService do
  alias AutomataSignal.Resources.Message
  alias AutomataSignal.Adapters.AdapterFactory

  @doc """
  메시지를 적절한 채널을 통해 전송합니다.
  """
  def send_message(%Message{} = message) do
    # 메시지에 맞는 어댑터 선택
    adapter = AdapterFactory.get_adapter_for_message(message)

    # 메시지 검증
    case adapter.validate_message(message) do
      :ok ->
        # 메시지 전송
        case adapter.send_message(message) do
          {:ok, response} ->
            # 성공 처리
            update_message_status(message, :successful, response)

          {:error, error} ->
            # 오류 처리
            handle_send_error(message, adapter, error)
        end

      {:error, reason, details} ->
        # 검증 오류 처리
        update_message_status(message, :failed, %{
          error_reason: reason,
          error_details: details
        })
    end
  end

  # 메시지 상태 업데이트
  defp update_message_status(message, status, details) do
    # ... 메시지 상태 업데이트 로직 ...
  end

  # 전송 오류 처리
  defp handle_send_error(message, adapter, error) do
    # 오류 매핑
    case adapter.map_error(error) do
      {:permanent, reason, details} ->
        # 영구적 오류 - 재시도 없음
        update_message_status(message, :failed, %{
          error_reason: reason,
          error_details: details
        })

      {:temporary, reason, details} ->
        # 일시적 오류 - 재시도 스케줄링
        update_message_status(message, :errored, %{
          error_reason: reason,
          error_details: details
        })
        schedule_retry(message)
    end
  end

  # 메시지 재시도 스케줄링
  defp schedule_retry(message) do
    # ... 재시도 스케줄링 로직 ...
  end
end
```

## 6. 어댑터 확장 가이드

새로운 메시징 채널을 추가하기 위한 어댑터 구현 가이드입니다.

### 6.1 기본 구현 단계

1. `ChannelAdapter` 비헤이비어를 구현하는 새 모듈 생성
2. 필수 콜백 메서드 구현:
   - `send_message/1`
   - `validate_message/1`
   - `get_status/1`
   - `map_error/1`
3. 채널별 특화 로직 구현 (메시지 변환, API 호출 등)
4. `AdapterFactory`에 새 채널 유형 및 어댑터 추가

### 6.2 새 어댑터 구현 예시

```elixir
defmodule AutomataSignal.Adapters.WebPushAdapter do
  @behaviour AutomataSignal.Adapters.ChannelAdapter
  alias AutomataSignal.Resources.Message

  @impl true
  def send_message(%Message{subscription: %{type: :WebPush, token: subscription_info}} = message) do
    # Web Push API 통합 로직
    # ...
  end

  @impl true
  def validate_message(%Message{} = message) do
    # Web Push 메시지 검증 로직
    # ...
  end

  @impl true
  def get_status(message_id) do
    # 상태 조회 로직
    # ...
  end

  @impl true
  def map_error(error) do
    # Web Push 특화 오류 매핑
    # ...
  end
end
```

### 6.3 AdapterFactory 업데이트

```elixir
# AdapterFactory에 새 채널 유형 추가
def get_adapter_for_channel_type(channel_type) do
  case channel_type do
    # ... 기존 채널 ...
    :WebPush -> WebPushAdapter
    _ -> raise "Unsupported channel type: #{inspect(channel_type)}"
  end
end
```

### 6.4 새 구독 유형 추가

데이터베이스 스키마에 새 구독 유형을 추가해야 합니다:

```elixir
# Subscription 리소스 업데이트
attribute :type, :atom do
  constraints [one_of: [
    :iOSPush, :AndroidPush, :Email, :SMS, :KakaoTalk, :InAppMessage, :WebPush
  ]]
end
```

## 7. 성능 및 확장성 고려사항

### 7.1 연결 풀링

외부 서비스와의 연결을 효율적으로 관리하기 위한 연결 풀링:

```elixir
defmodule AutomataSignal.Adapters.ConnectionPool do
  use GenServer

  # 풀 관리 및 연결 재사용 로직
  # ...
end
```

### 7.2 비율 제한 처리

API 비율 제한을 관리하기 위한 전략:

```elixir
defmodule AutomataSignal.Adapters.RateLimiter do
  use GenServer

  # 채널별 비율 제한 처리 로직
  # ...
end
```

### 7.3 배치 처리

대량 메시지 전송을 위한 배치 처리:

```elixir
defmodule AutomataSignal.Adapters.BatchProcessor do
  # 메시지 그룹화 및 배치 전송 로직
  # ...
end
```

## 8. 모니터링 및 지표

어댑터 시스템의 상태 및 성능을 모니터링하기 위한 지표:

### 8.1 성능 지표

- **전송 시간**: 채널별 평균/최대/최소 전송 시간
- **성공률**: 채널별 성공적인 전송 비율
- **오류 비율**: 채널별 오류 유형 분포
- **재시도 비율**: 임시 오류로 인한 재시도 비율

### 8.2 운영 지표

- **채널별 사용량**: 시간별/일별 채널 사용 통계
- **연결 풀 상태**: 활성/유휴/최대 연결 수
- **비율 제한 상태**: 채널별 비율 제한 히트 횟수
- **외부 서비스 가용성**: 채널별 외부 서비스 상태

### 8.3 로깅 전략

각 어댑터는 다음과 같은 이벤트를 로깅합니다:

- 메시지 전송 시도
- 전송 성공/실패
- 외부 서비스 응답 (요약)
- 오류 및 예외 상황
- 비율 제한 히트
- 연결 풀 상태 변경

```elixir
defmodule AutomataSignal.Adapters.Logger do
  def log_message_send(adapter_type, message_id, result) do
    # 메시지 전송 로깅 로직
    # ...
  end

  def log_error(adapter_type, message_id, error) do
    # 오류 로깅 로직
    # ...
  end

  # ... 기타 로깅 함수 ...
end
```

## 9. 테스트 전략

어댑터 시스템을 위한 테스트 전략:

### 9.1 단위 테스트

각 어댑터의 기능을 격리하여 테스트:

```elixir
defmodule AutomataSignal.Adapters.PushAdapterTest do
  use ExUnit.Case
  alias AutomataSignal.Adapters.PushAdapter
  alias AutomataSignal.Resources.Message
  alias AutomataSignal.Resources.Subscription

  # 메시지 검증 테스트
  test "validate_message/1 returns :ok for valid messages" do
    message = %Message{
      title: "Test Title",
      body: "Test Body",
      subscription: %Subscription{type: :iOSPush, token: "valid_token"}
    }

    assert PushAdapter.validate_message(message) == :ok
  end

  # 오류 매핑 테스트
  test "map_error/1 correctly maps APNS errors" do
    error = %{reason: "BadDeviceToken"}

    assert PushAdapter.map_error(error) == {
      :permanent,
      :invalid_token,
      %{code: "BadDeviceToken", subscription_status: -10}
    }
  end

  # ... 기타 테스트 ...
end
```

### 9.2 통합 테스트

어댑터와 실제 외부 서비스의 통합을 테스트:

```elixir
defmodule AutomataSignal.Adapters.PushAdapterIntegrationTest do
  use ExUnit.Case
  alias AutomataSignal.Adapters.PushAdapter

  # 실제 테스트 토큰을 사용한 전송 테스트
  @tag :integration
  test "send_message/1 successfully sends to test device" do
    # ...
  end

  # ... 기타 통합 테스트 ...
end
```

### 9.3 모의 어댑터

테스트 환경을 위한 모의 어댑터 구현:

```elixir
defmodule AutomataSignal.Adapters.MockAdapter do
  @behaviour AutomataSignal.Adapters.ChannelAdapter

  @impl true
  def send_message(message) do
    # 메시지 ID를 기반으로 성공/실패 시뮬레이션
    # ...
  end

  # ... 기타 콜백 구현 ...
end
```

---

// File: automata-signal/4-sequences/SEQ-001-initialization

# [SEQ-001] 초기화 시퀀스

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [DESIGN-001] 아키텍처 개요
- [REF-001] API 참조
- [REF-002] 상태 코드
- [SEQ-002] 메시지 처리 시퀀스

## 요약

본 문서는 Automata-Signal SDK의 초기화 과정, 사용자 식별(로그인/로그아웃), 그리고 다양한 메시징 채널 구독 관리에 대한 흐름을 설명합니다. SDK와 서버 간의 상호작용을 포함한 전체 프로세스를 상세히 다룹니다.

## 대상 독자

- 모바일 앱 개발자
- SDK 통합 담당자
- 백엔드 개발자
- QA 팀

## 1. SDK 초기화 및 사용자 식별 흐름 다이어그램

```mermaid
sequenceDiagram
    participant App as 앱
    participant SDK as Automata SDK
    participant API as API 게이트웨이
    participant Server as Elixir 서버
    participant DB as 데이터베이스

    App->>SDK: initialize(APP_ID, config)
    SDK->>SDK: 디바이스 정보 수집

    alt 푸시 알림 자동 등록 (config.autoRegisterPush)
        SDK->>SDK: 푸시 토큰 요청
        SDK->>API: 디바이스 등록 요청
        API->>Server: 요청 처리
        Server->>DB: 새 Subscription 레코드 생성 (iOSPush/AndroidPush)
        DB-->>Server: 구독 ID 반환
        Server-->>API: 구독 ID 응답
        API-->>SDK: 구독 ID 저장

        alt 자동 권한 요청 (config.autoPromptPermission)
            SDK->>App: 푸시 알림 권한 요청
            App-->>SDK: 권한 상태 반환
            SDK->>API: 구독 상태 업데이트
            API->>Server: 상태 업데이트
            Server->>DB: Subscription 상태 업데이트
        end
    end

    SDK-->>App: 초기화 완료 콜백

    Note over App,SDK: 사용자 로그인 시

    App->>SDK: login("external_id")
    SDK->>API: 사용자 식별 요청
    API->>Server: 요청 처리

    alt 기존 external_id가 존재
        Server->>DB: external_id로 User 조회
        DB-->>Server: 기존 User 정보
        Server->>DB: 현재 Subscription을 기존 User에 연결
    else 새로운 external_id
        Server->>DB: 새 User 레코드 생성
        DB-->>Server: 새 User ID
        Server->>DB: Subscription-User 연결
    end

    Server-->>API: 성공 응답
    API-->>SDK: 사용자 연결 완료
    SDK-->>App: 로그인 완료 콜백

    Note over App,SDK: 추가 채널 등록 (예: 이메일)

    App->>SDK: registerEmail("user@example.com")
    SDK->>API: 이메일 구독 등록 요청
    API->>Server: 요청 처리
    Server->>DB: 새 Subscription 레코드 생성 (type: Email)
    DB-->>Server: 구독 ID 반환
    Server-->>API: 구독 ID 응답
    API-->>SDK: 구독 ID 저장
    SDK-->>App: 이메일 등록 완료 콜백

    Note over App,SDK: 사용자 로그아웃 시

    App->>SDK: logout()
    SDK->>API: 사용자 연결 해제 요청
    API->>Server: 요청 처리
    Server->>DB: Subscription-User 연결 해제
    DB-->>Server: 성공 확인
    Server-->>API: 성공 응답
    API-->>SDK: 로그아웃 완료
    SDK-->>App: 로그아웃 완료 콜백
```

## 2. SDK 초기화 프로세스

### 2.1 초기화 파라미터

SDK 초기화는 앱 시작 시 최대한 빨리 수행되어야 합니다:

```dart
// Flutter SDK 초기화 예시
void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // SDK 초기화
  await AutomataSignal().initialize(
    'YOUR_APP_ID',
    AutomataSignalConfig(
      autoRegisterPush: true,
      autoPromptPermission: true,
      foregroundNotificationsEnabled: true,
      enableInAppMessages: true, // 인앱 메시지 활성화 (지원 예정)
      defaultLanguage: 'ko',
      trackMessageEvents: true
    )
  );

  runApp(MyApp());
}
```

`AutomataSignalConfig` 옵션:

| 옵션                           | 타입   | 기본값 | 설명                                 |
| ------------------------------ | ------ | ------ | ------------------------------------ |
| autoRegisterPush               | bool   | true   | 자동으로 푸시 알림 토큰 등록         |
| autoPromptPermission           | bool   | true   | 자동으로 푸시 알림 권한 요청         |
| foregroundNotificationsEnabled | bool   | true   | 앱 포그라운드 상태에서도 알림 표시   |
| enableInAppMessages            | bool   | true   | 인앱 메시지 활성화 (지원 예정)       |
| defaultLanguage                | String | null   | 기본 언어 설정                       |
| trackMessageEvents             | bool   | true   | 메시지 수신/열람 등 이벤트 자동 추적 |

### 2.2 내부 초기화 단계

SDK의 내부 초기화 과정은 다음 순서로 진행됩니다:

1. 앱 ID 및 설정 저장
2. 필요한 매니저 클래스 초기화:
   - SubscriptionManager: 구독 관리
   - UserManager: 사용자 식별 관리
   - MessageManager: 메시지 처리 및 추적
   - InAppMessageManager: 인앱 메시지 관리 (지원 예정)
3. 디바이스 정보 수집:
   - 디바이스 모델
   - OS 버전
   - 앱 버전
   - SDK 버전
   - 언어 설정
   - 국가 코드
   - 타임존

```dart
// 내부 초기화 로직 예시
Future<void> _initialize(String appId, AutomataSignalConfig config) async {
  _appId = appId;
  _config = config;

  // 디바이스 정보 수집
  _deviceInfo = await _collectDeviceInfo();

  // 구독 관리자 초기화
  _subscriptionManager = SubscriptionManager(
    appId: appId,
    deviceInfo: _deviceInfo
  );

  // 사용자 관리자 초기화
  _userManager = UserManager(appId: appId);

  // 메시지 관리자 초기화
  _messageManager = MessageManager(
    appId: appId,
    trackEvents: config.trackMessageEvents
  );

  // 저장된 사용자 ID가 있는 경우 자동 복원
  await _restoreUserIfAvailable();

  // 자동 푸시 알림 등록
  if (config.autoRegisterPush) {
    await _registerPushNotifications(
      promptPermission: config.autoPromptPermission
    );
  }
}
```

### 2.3 푸시 알림 등록 프로세스

자동 등록이 활성화된 경우 푸시 알림 등록 과정:

1. 플랫폼별 푸시 서비스 초기화:
   - iOS: APNS(Apple Push Notification Service)
   - Android: FCM(Firebase Cloud Messaging)
2. 디바이스 토큰 요청
3. 토큰을 서버에 등록하여 새로운 구독 생성
4. (옵션) 사용자에게 알림 권한 요청

```dart
// 푸시 알림 등록 로직 예시
Future<void> _registerPushNotifications({bool promptPermission = true}) async {
  // 플랫폼별 초기화
  if (Platform.isIOS) {
    await _initializeAPNS();
  } else if (Platform.isAndroid) {
    await _initializeFCM();
  }

  // 토큰 요청
  String? token = await _getPushToken();
  if (token != null) {
    // 토큰을 서버에 등록
    await _subscriptionManager.registerPushSubscription(token);
  }

  // 권한 요청
  if (promptPermission) {
    bool granted = await _requestNotificationPermission();
    // 권한 상태 서버에 업데이트
    if (token != null) {
      await _subscriptionManager.updateSubscriptionStatus(
        token,
        granted ? 1 : -22  // -22: 수동 구독 취소
      );
    }
  }
}
```

### 2.4 서버 API 요청

SDK 초기화 중 서버로 보내는 API 요청 예시:

**푸시 알림 구독 등록 요청 (POST /api/v1/subscriptions)**

```json
{
  "application_id": "YOUR_APP_ID",
  "type": "iOSPush", // 또는 "AndroidPush"
  "token": "device_push_token_here",
  "device_info": {
    "device_model": "iPhone 13",
    "device_os": "iOS 15.4",
    "device_language": "ko",
    "app_version": "1.0.0",
    "sdk_version": "1.0.0",
    "country_code": "KR",
    "test_type": 0
  }
}
```

**응답:**

```json
{
  "subscription_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "status": "success"
}
```

## 3. 사용자 식별 프로세스

### 3.1 로그인 프로세스

사용자가 앱에 로그인할 때 SDK를 통해 사용자를 식별합니다:

```dart
// 사용자 로그인 예시
Future<void> onUserLogin(String userId) async {
  try {
    await AutomataSignal().login(userId);
    print('User identified successfully');

    // 로그인 후 인앱 메시지 확인 (지원 예정)
    await AutomataSignal().fetchInAppMessages();
  } catch (error) {
    print('Failed to identify user: $error');
  }
}
```

내부적으로 다음 단계가 수행됩니다:

1. 사용자 ID를 검증하고 저장
2. 서버에 사용자 식별 요청 전송
3. 서버가 User 레코드를 찾거나 생성
4. 현재 구독과 사용자를 연결
5. 성공 시 로컬에 사용자 ID 캐싱 (앱 재시작 시 자동 복원용)

```dart
// 내부 사용자 식별 로직 예시
Future<void> identifyUser(String externalId) async {
  if (externalId.isEmpty) {
    throw Exception('User ID cannot be empty');
  }

  try {
    // 서버에 사용자 식별 요청
    final response = await _apiClient.post(
      '/api/v1/users/identify',
      body: {
        'application_id': _appId,
        'external_id': externalId,
        'subscriptions': await _subscriptionManager.getSubscriptionIds()
      }
    );

    if (response['status'] == 'success') {
      // 로컬에 사용자 ID 저장
      _externalId = externalId;
      _automataId = response['user_id'];
      await _storage.setString('user_external_id', externalId);

      _isIdentified = true;
      return;
    }

    throw Exception('Failed to identify user: ${response['error']}');
  } catch (error) {
    _isIdentified = false;
    rethrow;
  }
}
```

### 3.2 서버 측 식별 처리

서버에서는 사용자 식별 요청을 다음과 같이 처리합니다:

1. `application_id`와 `external_id`를 기반으로 기존 사용자 검색
2. 사용자가 없는 경우 새 User 레코드 생성
3. 요청에 포함된 구독 ID를 사용자와 연결
4. 관련 메타데이터 업데이트 (마지막 활성 시간 등)

```elixir
# 서버 측 사용자 식별 처리 로직 예시
def identify_user(params) do
  Ash.transaction(fn ->
    # 사용자 찾기 또는 생성
    user =
      case find_user_by_external_id(params.application_id, params.external_id) do
        nil ->
          # 새 사용자 생성
          User.create_changeset(%{
            external_id: params.external_id,
            application_id: params.application_id,
            last_active_at: DateTime.utc_now()
          })
          |> Ash.create!()

        existing_user ->
          # 기존 사용자 업데이트
          existing_user
          |> User.update_changeset(%{last_active_at: DateTime.utc_now()})
          |> Ash.update!()
      end

    # 구독과 사용자 연결
    link_subscriptions_to_user(user.id, params.subscriptions)

    # 성공 응답 반환
    %{
      status: "success",
      user_id: user.id
    }
  end)
end
```

### 3.3 로그아웃 프로세스

사용자가 앱에서 로그아웃할 때:

```dart
// 사용자 로그아웃 예시
Future<void> onUserLogout() async {
  try {
    await AutomataSignal().logout();
    print('User logged out successfully');
  } catch (error) {
    print('Failed to logout user: $error');
  }
}
```

내부적으로 다음 단계가 수행됩니다:

1. 서버에 로그아웃 요청 전송
2. 현재 구독과 사용자 연결 해제
3. 로컬에 저장된 사용자 ID 삭제
4. 인앱 메시지 캐시 제거 (지원 예정)

```dart
// 내부 로그아웃 로직 예시
Future<void> logoutUser() async {
  if (!_isIdentified) {
    return; // 이미 로그아웃 상태
  }

  try {
    // 서버에 로그아웃 요청
    await _apiClient.post(
      '/api/v1/users/logout',
      body: {
        'application_id': _appId,
        'subscriptions': await _subscriptionManager.getSubscriptionIds()
      }
    );

    // 로컬 사용자 정보 제거
    _externalId = null;
    _automataId = null;
    await _storage.remove('user_external_id');

    // 인앱 메시지 캐시 제거 (지원 예정)
    await _inAppMessageManager?.clearCache();

    _isIdentified = false;
  } catch (error) {
    // 오류는 기록하되, 로컬 로그아웃은 진행
    print('Error during logout: $error');
    _externalId = null;
    _automataId = null;
    await _storage.remove('user_external_id');
    _isIdentified = false;

    rethrow;
  }
}
```

### 3.4 서버 측 로그아웃 처리

서버에서는 로그아웃 요청을 다음과 같이 처리합니다:

1. 요청에 포함된 구독 ID를 사용자와 연결 해제
2. 구독 상태는 유지하되 User ID 참조만 제거
3. 익명 사용자 상태로 되돌림

```elixir
# 서버 측 로그아웃 처리 로직 예시
def logout_user(params) do
  Ash.transaction(fn ->
    # 구독과 사용자 연결 해제
    unlink_subscriptions_from_user(params.subscriptions)

    # 성공 응답 반환
    %{status: "success"}
  end)
end

defp unlink_subscriptions_from_user(subscription_ids) do
  Enum.each(subscription_ids, fn subscription_id ->
    subscription = Subscription.get!(subscription_id)

    subscription
    |> Subscription.update_changeset(%{user_id: nil})
    |> Ash.update!()

    # 구독 상태 변경 이벤트 기록
    SubscriptionEvent.create_changeset(%{
      subscription_id: subscription.id,
      application_id: subscription.application_id,
      event_type: :user_unlinked,
      reason: "user_logout",
      occurred_at: DateTime.utc_now()
    })
    |> Ash.create!()
  end)
end
```

## 4. 채널 구독 관리

SDK는 다양한 메시징 채널의 구독을 관리하는 기능을 제공합니다.

### 4.1 푸시 알림 구독 관리

SDK 초기화 시 자동으로 등록되는 푸시 알림 구독을 관리하는 메서드:

```dart
// 푸시 알림 비활성화
await AutomataSignal().disablePush();

// 푸시 알림 활성화
await AutomataSignal().enablePush();

// 푸시 토큰 수동 업데이트
await AutomataSignal().updatePushToken("new_token_here");
```

내부적으로 구독 상태가 업데이트됩니다:

- 활성화: `subscription_status` 값을 1로 설정
- 비활성화: `subscription_status` 값을 -2로 설정 (사용자에 의한 구독 취소)

### 4.2 이메일 구독 관리 (지원 예정)

이메일 채널 구독 등록 및 관리:

```dart
// 이메일 구독 등록
String? subscriptionId = await AutomataSignal().registerEmail("user@example.com");

// 이메일 구독 비활성화
await AutomataSignal().disableChannel(SubscriptionType.Email);

// 이메일 구독 활성화
await AutomataSignal().enableChannel(SubscriptionType.Email);
```

이메일 구독 등록 API 요청:

```json
POST /api/v1/subscriptions
{
  "application_id": "YOUR_APP_ID",
  "type": "Email",
  "token": "user@example.com",
  "user_id": "optional_user_id_if_logged_in"
}
```

### 4.3 SMS 구독 관리 (지원 예정)

SMS 채널 구독 등록 및 관리:

```dart
// SMS 구독 등록
String? subscriptionId = await AutomataSignal().registerSMS("+821012345678");

// SMS 구독 비활성화
await AutomataSignal().disableChannel(SubscriptionType.SMS);

// SMS 구독 활성화
await AutomataSignal().enableChannel(SubscriptionType.SMS);
```

### 4.4 카카오 알림톡 구독 관리 (지원 예정)

카카오 알림톡 채널 구독 등록 및 관리:

```dart
// 카카오 알림톡 구독 등록
String? subscriptionId = await AutomataSignal().registerKakaoTalk("+821012345678");

// 카카오 알림톡 구독 비활성화
await AutomataSignal().disableChannel(SubscriptionType.KakaoTalk);

// 카카오 알림톡 구독 활성화
await AutomataSignal().enableChannel(SubscriptionType.KakaoTalk);
```

### 4.5 인앱 메시지 구독 관리 (지원 예정)

인앱 메시지 채널 구독 관리:

```dart
// 인앱 메시지 비활성화
await AutomataSignal().disableChannel(SubscriptionType.InAppMessage);

// 인앱 메시지 활성화
await AutomataSignal().enableChannel(SubscriptionType.InAppMessage);
```

## 5. 태그 관리

사용자의 구독에 태그를 추가하여 세그먼트 기반 메시징을 지원합니다:

```dart
// 태그 추가
await AutomataSignal().addTags({
  "premium_user": "true",
  "user_level": "silver",
  "favorite_category": "electronics"
});

// 태그 제거
await AutomataSignal().removeTags(["user_level"]);

// 태그 조회
Map<String, String> tags = await AutomataSignal().getTags();
```

태그 추가 API 요청:

```json
POST /api/v1/subscriptions/tags
{
  "application_id": "YOUR_APP_ID",
  "subscription_ids": ["subscription_id1", "subscription_id2"],
  "tags": {
    "premium_user": "true",
    "user_level": "silver",
    "favorite_category": "electronics"
  }
}
```

## 6. 데이터 지속성

SDK는 다음 데이터를 로컬에 저장합니다:

1. **구독 정보**:

   - 구독 ID
   - 채널 유형
   - 토큰 값
   - 구독 상태

2. **사용자 정보**:

   - 외부 사용자 ID (앱 재시작 시 자동 복원용)
   - Automata 사용자 ID

3. **메시지 추적 데이터**:

   - 처리 중인 메시지 ID
   - 수신 확인 대기 중인 메시지 큐
   - 네트워크 연결 없을 때 캐시된 이벤트

4. **인앱 메시지 데이터** (지원 예정):
   - 캐싱된 인앱 메시지
   - 표시 규칙 및 트리거

데이터 지속성 구현:

```dart
// 구독 정보 저장 예시
Future<void> _saveSubscriptionInfo(SubscriptionInfo subscription) async {
  final subscriptions = await _getStoredSubscriptions();
  subscriptions[subscription.id] = subscription.toJson();
  await _storage.setString('subscriptions', jsonEncode(subscriptions));
}

// 구독 정보 복원 예시
Future<Map<String, SubscriptionInfo>> _getStoredSubscriptions() async {
  final data = await _storage.getString('subscriptions');
  if (data == null || data.isEmpty) {
    return {};
  }

  try {
    final Map<String, dynamic> jsonData = jsonDecode(data);
    return jsonData.map((key, value) =>
      MapEntry(key, SubscriptionInfo.fromJson(value))
    );
  } catch (e) {
    print('Error restoring subscriptions: $e');
    return {};
  }
}
```

## 7. 오류 처리 및 재시도

SDK는 네트워크 오류나 서버 문제 시 다음과 같은 전략을 사용합니다:

1. **지수 백오프 재시도**:

   - 초기 재시도 간격: 1초
   - 최대 재시도 간격: 60초
   - 최대 재시도 횟수: 5회

2. **오프라인 작업 큐**:

   - 네트워크 연결이 없을 때 작업 큐에 저장
   - 연결 복원 시 큐의 작업 처리

3. **오류 분류**:
   - 네트워크 오류: 재시도 가능
   - 인증 오류: 재인증 필요
   - 서버 오류: 상황에 따라 재시도
   - 클라이언트 오류: 재시도 불가

```dart
// 오류 처리 및 재시도 예시
Future<T> _retryableRequest<T>(Future<T> Function() request) async {
  int attempt = 0;
  Duration delay = Duration(seconds: 1);

  while (true) {
    try {
      return await request();
    } catch (e) {
      attempt++;

      if (!_shouldRetry(e) || attempt >= 5) {
        rethrow;
      }

      // 지수 백오프 대기
      await Future.delayed(delay);
      delay = Duration(seconds: min(60, delay.inSeconds * 2));
    }
  }
}

bool _shouldRetry(dynamic error) {
  if (error is NetworkError) {
    return true;
  }

  if (error is ServerError && error.statusCode >= 500) {
    return true;
  }

  return false;
}
```

## 8. 보안 고려사항

SDK 구현 시 다음과 같은 보안 사항을 고려합니다:

1. **인증 토큰 보안**:

   - 토큰은 앱의 안전한 저장소에 암호화하여 저장
   - 메모리에서 필요한 시간만 유지

2. **API 통신 보안**:

   - 모든 API 통신은 HTTPS/TLS 사용
   - 인증 헤더 및 토큰을 통한 API 요청 인증

3. **개인정보 보호**:
   - 필요한 최소한의 개인 정보만 수집 및 전송
   - 민감한 정보는 서버에 직접 저장하지 않음

## 9. 디버깅 및 로깅

SDK는 다음과 같은 디버깅 지원을 제공합니다:

1. **로그 레벨 설정**:

   - VERBOSE: 상세한 디버깅 정보
   - DEBUG: 디버깅 정보
   - INFO: 일반 정보 (기본값)
   - WARNING: 경고
   - ERROR: 오류
   - NONE: 로깅 비활성화

2. **SDK 상태 확인**:
   - 구독 상태 및 ID 조회
   - 사용자 식별 상태 확인
   - 푸시 토큰 정보

```dart
// 로그 레벨 설정 예시
AutomataSignal().setLogLevel(LogLevel.DEBUG);

// SDK 상태 확인 예시
bool isIdentified = await AutomataSignal().isUserIdentified();
List<SubscriptionInfo> subscriptions = await AutomataSignal().getSubscriptions();
String? pushToken = await AutomataSignal().getPushToken();
```

---

// File: automata-signal/4-sequences/SEQ-002-message-processing

# [SEQ-002] 메시지 처리 시퀀스

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [SEQ-003] 라이프사이클 시퀀스
- [SEQ-004] 캠페인 관리 시퀀스
- [COMP-002] 어댑터 시스템
- [DESIGN-002] 시스템 아키텍처

## 요약

본 문서는 Automata-Signal 시스템에서 메시지가 생성되고 처리되는 전체 흐름을 설명합니다. 개별 메시지 발송, 템플릿 기반 메시지, 대량 캠페인 등 다양한 메시지 처리 경로와 각 단계별 상호작용을 포함합니다.

## 대상 독자

- 개발팀
- 시스템 엔지니어
- QA 팀
- 운영팀

## 1. 메시지 처리 흐름 다이어그램

```mermaid
sequenceDiagram
    participant Client as 클라이언트 앱
    participant API as API 게이트웨이
    participant Template as 템플릿 서비스
    participant Campaign as 캠페인 관리자
    participant Elixir as Elixir 서버 클러스터
    participant DB as PostgreSQL
    participant Oban as ash_oban 작업 큐
    participant Adapter as 채널 어댑터
    participant External as 외부 서비스 (APNS/FCM/등)
    participant User as 사용자 디바이스/이메일/SMS
    participant Analytics as 분석 시스템

    alt 개별 메시지 발송
        Client->>API: 메시지 요청
        API->>Elixir: 요청 전달
        Elixir->>DB: 메시지 데이터 저장
        Elixir->>Oban: 작업 큐에 추가
    else 템플릿 기반 개별 메시지
        Client->>API: 템플릿 기반 메시지 요청
        API->>Template: 템플릿 렌더링 요청
        Template->>DB: 템플릿 조회
        DB-->>Template: 템플릿 데이터
        Template->>Template: 변수 치환 및 렌더링
        Template-->>API: 렌더링된 메시지 콘텐츠
        API->>Elixir: 요청 전달
        Elixir->>DB: 메시지 데이터 저장
        Elixir->>Oban: 작업 큐에 추가
    else 캠페인 메시지
        Client->>API: 캠페인 생성 요청
        API->>Campaign: 캠페인 생성
        Campaign->>DB: 캠페인 저장

        alt 템플릿 기반 캠페인
            Campaign->>Template: 템플릿 렌더링 요청
            Template->>DB: 템플릿 조회
            DB-->>Template: 템플릿 데이터
            Template-->>Campaign: 렌더링된 기본 콘텐츠
        end

        Campaign->>DB: 타겟팅 조건으로 사용자/구독 조회
        DB-->>Campaign: 대상 리스트
        Campaign->>Elixir: 대량 메시지 생성 요청
        Elixir->>DB: 메시지 배치 저장
        Elixir->>Oban: 작업 큐에 배치 추가
    end

    Note over Elixir: 비동기 처리

    Oban-->>Elixir: 작업 스케줄링
    Elixir->>Adapter: 메시지 전송 요청

    alt 푸시 알림 채널
        Adapter->>External: APNS/FCM 요청
        External->>User: 푸시 알림 전달
        External-->>Adapter: 응답
    else 이메일 채널 (지원 예정)
        Adapter-->>External: SMTP 요청 (지원 예정)
    else SMS 채널 (지원 예정)
        Adapter-->>External: SMS 게이트웨이 요청 (지원 예정)
    else 카카오 알림톡 (지원 예정)
        Adapter-->>External: 카카오 API 요청 (지원 예정)
    else 인앱 메시지 (지원 예정)
        Adapter-->>Client: 인앱 메시지 데이터 제공 (지원 예정)
    end

    Adapter-->>Elixir: 응답 처리
    Elixir->>DB: 상태 업데이트 (successful)
    Elixir->>Analytics: 메시지 발송 이벤트

    User-->>Client: 메시지 수신 확인
    Client->>API: 상태 업데이트 (received)
    API->>Elixir: 상태 업데이트 요청
    Elixir->>DB: 상태 업데이트 기록
    Elixir->>Analytics: 메시지 수신 이벤트

    User-->>Client: 사용자 메시지 클릭
    Client->>API: 상태 업데이트 (converted)
    API->>Elixir: 상태 업데이트 요청
    Elixir->>DB: 상태 업데이트 기록
    Elixir->>Analytics: 메시지 열람 이벤트
```

## 2. 메시지 생성 경로

Automata-Signal 시스템에서 메시지는 세 가지 주요 경로를 통해 생성됩니다:

### 2.1 개별 메시지 발송

이 경로는 가장 단순한 메시지 생성 방식으로, 특정 사용자/구독에 직접 메시지를 전송합니다:

1. 클라이언트 앱이 API 엔드포인트를 통해 메시지 전송 요청
2. API 게이트웨이가 요청을 검증하고 Elixir 서버에 전달
3. Elixir 서버가 메시지 데이터를 저장하고 작업 큐에 추가
4. 비동기 작업자가 메시지 전송 처리

**API 요청 예시:**

```json
POST /api/v1/messages
{
  "subscription_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "title": "알림 제목",
  "body": "알림 내용 메시지",
  "data": {
    "action": "open_screen",
    "screen": "order_details",
    "order_id": "ORD-12345"
  }
}
```

### 2.2 템플릿 기반 개별 메시지

템플릿을 사용하여 일관된 형식의 개인화된 메시지를 생성합니다:

1. 클라이언트가 템플릿 ID와 변수를 포함한 메시지 요청
2. API 게이트웨이가 템플릿 서비스에 렌더링 요청
3. 템플릿 서비스가 데이터베이스에서 템플릿을 조회
4. 제공된 변수로 템플릿 렌더링 (변수 치환)
5. 렌더링된 콘텐츠로 메시지 생성 및 처리

**API 요청 예시:**

```json
POST /api/v1/messages/template
{
  "subscription_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "template_id": "order_confirmation",
  "variables": {
    "customer_name": "홍길동",
    "order_id": "ORD-12345",
    "order_amount": "35,000원",
    "estimated_delivery": "4월 5일"
  }
}
```

### 2.3 캠페인 메시지

대량의 타겟팅된 사용자에게 메시지를 전송하는 캠페인 방식:

1. 클라이언트가 캠페인 생성 요청 (대상 조건, 콘텐츠 포함)
2. API가 캠페인 관리자에 요청 전달
3. 캠페인 관리자가 캠페인 정보 저장
4. 템플릿 기반 캠페인인 경우 템플릿 렌더링
5. 타겟팅 조건에 맞는 사용자/구독 조회
6. 대상자별 개별 메시지 생성 및 배치로 작업 큐에 추가

**API 요청 예시:**

```json
POST /api/v1/campaigns
{
  "name": "4월 프로모션 캠페인",
  "template_id": "monthly_promotion",
  "targeting_criteria": {
    "tags": ["active_user", "has_purchased"],
    "last_active_after": "2025-03-01T00:00:00Z",
    "countries": ["KR"]
  },
  "variables": {
    "promotion_name": "봄맞이 할인 행사",
    "discount_percent": "20%",
    "promotion_end_date": "4월 15일"
  },
  "scheduled_at": "2025-04-03T09:00:00Z"
}
```

## 3. 메시지 처리 단계

메시지가 생성된 후 처리되는 주요 단계를 설명합니다:

### 3.1 메시지 저장 및 큐 등록

1. Elixir 서버는 메시지 데이터를 데이터베이스에 저장 (상태: `pending`)
2. 메시지 처리 작업이 Oban 작업 큐에 등록됨
3. 메시지 생성 이벤트가 기록됨

**메시지 저장 로직 예시:**

```elixir
def create_message(attrs) do
  Message.create_changeset(attrs)
  |> Ash.create!()
  |> schedule_delivery()
end

def schedule_delivery(message) do
  %{id: message.id}
  |> MessageWorker.new()
  |> Oban.insert!()

  message
end
```

### 3.2 비동기 메시지 처리

1. Oban 워커가 작업 큐에서 메시지 처리 작업을 가져옴
2. 메시지 데이터를 로드하고 적절한 채널 어댑터를 선택
3. 채널 어댑터에 메시지 전송 요청

**작업자 로직 예시:**

```elixir
defmodule AutomataSignal.Workers.MessageWorker do
  use Oban.Worker, queue: :messages

  @impl Oban.Worker
  def perform(%Oban.Job{args: %{"id" => message_id}}) do
    message = AutomataSignal.Messages.get_message!(message_id)

    # 구독 타입에 따라 적절한 어댑터 선택
    adapter = get_adapter_for_channel(message.subscription.type)

    # 어댑터를 통해 메시지 전송
    case adapter.send_message(message) do
      {:ok, response} ->
        # 성공 처리
        AutomataSignal.Messages.mark_as_sent(message, response)
        :ok

      {:error, reason} ->
        # 오류 처리 (일시적/영구적 오류 구분)
        handle_send_error(message, reason)
    end
  end

  defp get_adapter_for_channel(:iOSPush), do: AutomataSignal.Adapters.PushAdapter
  defp get_adapter_for_channel(:AndroidPush), do: AutomataSignal.Adapters.PushAdapter
  # ... 다른 채널 어댑터 ...
end
```

### 3.3 외부 서비스 통합

채널 어댑터는 해당 메시징 채널의 외부 서비스와 통합됩니다:

1. 채널별 메시지 형식으로 변환
2. 외부 서비스 API 호출 (APNS, FCM 등)
3. 응답 처리 및 결과 반환

**푸시 어댑터 예시:**

```elixir
defmodule AutomataSignal.Adapters.PushAdapter do
  alias AutomataSignal.Adapters.Base

  def send_message(%{subscription: subscription} = message) do
    case subscription.type do
      :iOSPush -> send_ios_message(message)
      :AndroidPush -> send_android_message(message)
      _ -> {:error, :invalid_subscription_type}
    end
  end

  defp send_ios_message(message) do
    # APNS 통합 로직
    notification = %{
      token: message.subscription.token,
      topic: get_bundle_id(message.application),
      notification: %{
        title: message.title,
        body: message.body
      },
      custom: message.data
    }

    case Pigeon.APNS.push(notification, get_apns_config(message.subscription)) do
      {:ok, data} ->
        {:ok, %{provider_message_id: data.id}}
      {:error, reason} ->
        mapped_error = map_apns_error(reason)
        {:error, mapped_error}
    end
  end

  defp send_android_message(message) do
    # FCM 통합 로직
    notification = %{
      to: message.subscription.token,
      notification: %{
        title: message.title,
        body: message.body
      },
      data: message.data
    }

    case Pigeon.FCM.push(notification) do
      {:ok, data} ->
        {:ok, %{provider_message_id: data.id}}
      {:error, reason} ->
        mapped_error = map_fcm_error(reason)
        {:error, mapped_error}
    end
  end

  # ... 기타 헬퍼 함수 ...
end
```

### 3.4 응답 처리 및 상태 업데이트

외부 서비스 응답에 따라 메시지 상태가 업데이트됩니다:

1. 성공적인 전송: 상태를 `successful`로 변경, `sent_at` 타임스탬프 기록
2. 영구적 오류: 상태를 `failed`로 변경, 오류 정보 기록
3. 일시적 오류: 상태를 `errored`로 변경, 재시도 스케줄링

**상태 업데이트 로직 예시:**

```elixir
def mark_as_sent(message, response) do
  # 상태 전이 트리거
  message
  |> Message.send_changeset(response)
  |> Ash.update!()
  |> create_message_event(:sent, response)
end

def mark_as_failed(message, reason) do
  message
  |> Message.fail_changeset(reason)
  |> Ash.update!()
  |> create_message_event(:failed, %{reason: reason})
end

defp create_message_event(message, event_type, metadata) do
  MessageEvent.create_changeset(%{
    message_id: message.id,
    event_type: event_type,
    occurred_at: DateTime.utc_now(),
    metadata: metadata
  })
  |> Ash.create!()

  message
end
```

### 3.5 메시지 수신 확인

사용자 기기가 메시지를 수신하면 SDK를 통해 수신 확인이 서버로 전송됩니다:

1. 사용자 기기의 SDK가 메시지 수신 감지
2. SDK가 API 서버로 수신 확인 전송
3. 서버가 메시지 상태를 `received`로 업데이트
4. 수신 이벤트 기록 및 분석 데이터 수집

**SDK 메시지 수신 처리 예시 (Flutter):**

```dart
void _handlePushReceived(Map<String, dynamic> message) {
  final String messageId = message['automata_message_id'];
  if (messageId != null) {
    // 서버에 수신 확인 전송
    _apiClient.confirmMessageReceived(messageId).then((_) {
      print('Message receipt confirmation sent');
    }).catchError((error) {
      print('Failed to confirm message receipt: $error');
    });
  }
}
```

### 3.6 사용자 상호작용 추적

사용자가 메시지와 상호작용하면 해당 정보가 서버로 전송됩니다:

1. 사용자가 메시지를 클릭/열람
2. SDK가 상호작용 이벤트를 감지하고 API 서버로 전송
3. 서버가 메시지 상태를 `converted`로 업데이트
4. 전환 이벤트 기록 및 분석 데이터 수집

**SDK 메시지 클릭 처리 예시 (Flutter):**

```dart
void _handlePushClicked(Map<String, dynamic> message) {
  final String messageId = message['automata_message_id'];
  if (messageId != null) {
    // 서버에 클릭 이벤트 전송
    _apiClient.trackMessageConverted(messageId).then((_) {
      print('Message conversion tracked');
    }).catchError((error) {
      print('Failed to track message conversion: $error');
    });

    // 메시지 액션 처리
    _handleMessageAction(message['data']);
  }
}
```

## 4. 배치 처리 최적화

대량 메시지 처리를 위해 다음과 같은 최적화가 적용됩니다:

### 4.1 메시지 배치 생성

캠페인에서 대량 메시지 생성 시 배치 처리를 사용합니다:

```elixir
def create_campaign_messages(campaign, subscriptions) do
  # 구독 목록을 적절한 크기의 배치로 분할
  subscriptions
  |> Enum.chunk_every(500)
  |> Enum.each(fn batch ->
    # 배치 트랜잭션으로 메시지 레코드 생성
    Ash.transaction(fn ->
      Enum.map(batch, fn subscription ->
        create_message_for_subscription(campaign, subscription)
      end)
    end)
  end)
end
```

### 4.2 작업 큐 최적화

Oban 작업 큐를 사용하여 처리량과 안정성을 최적화합니다:

1. 우선순위 큐: 중요한 트랜잭션 메시지는 높은 우선순위로 처리
2. 병렬 워커: 다수의 워커를 통한 동시 처리
3. 비율 제한: 외부 서비스 제한을 고려한 처리 비율 제한
4. 재시도 전략: 실패한 작업에 대한 지수 백오프 재시도

**작업 큐 설정 예시:**

```elixir
config :automata_signal, Oban,
  repo: AutomataSignal.Repo,
  plugins: [
    {Oban.Plugins.Pruner, max_age: 60 * 60 * 24 * 7},
    {Oban.Plugins.Cron, crontab: [
      {"0 0 * * *", AutomataSignal.Workers.DailyQuotaResetWorker}
    ]}
  ],
  queues: [
    messages: 50,        # 일반 메시지 큐
    campaigns: 10,       # 캠페인 처리 큐
    high_priority: 20,   # 중요 메시지 큐
    message_retry: 5     # 재시도 큐
  ]
```

### 4.3 데이터베이스 최적화

데이터베이스 작업 최적화:

1. 일괄 삽입: `INSERT INTO ... VALUES (...), (...), ...` 구문 활용
2. 인덱스 최적화: 자주 쿼리되는 필드에 인덱스 적용
3. 읽기/쓰기 분리: 분석 쿼리와 작업 큐를 별도 연결로 분리
4. 트랜잭션 관리: 일관성을 위한 트랜잭션 사용

## 5. 채널별 처리 특성

각 채널의 특성에 맞게 메시지 처리 방식이 조정됩니다:

### 5.1 푸시 알림 채널

- 현재 지원됨
- APNS(iOS)와 FCM(Android) 서비스 통합
- 토큰 기반 타겟팅
- 비동기 응답 처리

### 5.2 이메일 채널 (지원 예정)

- AWS SES 또는 SMTP 서버 통합 예정
- 이메일 템플릿 렌더링 (HTML/텍스트)
- 열람 추적 픽셀 및 링크 추적
- 바운스 및 스팸 신고 처리

### 5.3 SMS 채널 (지원 예정)

- 다양한 SMS 게이트웨이 통합 예정
- 국가별 포맷팅 규칙 적용
- 메시지 길이 제한 및 분할 처리
- 수신 확인 처리

### 5.4 카카오 알림톡 (지원 예정)

- 카카오 비즈니스 API 통합 예정
- 승인된 템플릿 기반 메시지 발송
- 버튼 액션 추적
- 대체 발송(SMS) 자동 처리

### 5.5 인앱 메시지 (지원 예정)

- 앱 내 직접 메시지 표시
- 다양한 레이아웃 템플릿 지원
- 메시지 트리거 조건 설정
- 오프라인 메시지 저장 및 표시

## 6. 오류 처리 및 재시도

### 6.1 오류 분류

메시지 처리 중 발생하는 오류는 다음과 같이 분류됩니다:

1. **영구적 오류**: 다시 시도해도 해결되지 않는 오류

   - 유효하지 않은 토큰/주소
   - 차단된 사용자
   - 구독 취소된 사용자
   - 서비스 인증 실패

2. **일시적 오류**: 재시도를 통해 해결될 수 있는 오류
   - 네트워크 연결 문제
   - 서비스 일시적 장애
   - 비율 제한 초과
   - 서버 과부하

### 6.2 재시도 전략

일시적 오류에 대한 재시도 전략:

```elixir
defmodule AutomataSignal.ErrorHandler do
  def handle_send_error(message, reason) do
    case classify_error(reason) do
      :permanent ->
        # 영구적 오류 처리
        AutomataSignal.Messages.mark_as_failed(message, reason)
        {:error, reason}

      :temporary ->
        # 일시적 오류 처리 및 재시도 스케줄링
        message = AutomataSignal.Messages.mark_as_errored(message, reason)
        schedule_retry(message)
        {:error, :retry_scheduled}
    end
  end

  defp classify_error(reason) do
    cond do
      reason in [:invalid_token, :unregistered, :not_registered] -> :permanent
      reason in [:service_unavailable, :internal_server_error, :timeout] -> :temporary
      # ... 기타 오류 분류 ...
      true -> :permanent  # 기본적으로 안전하게 영구적 오류로 처리
    end
  end

  defp schedule_retry(message) do
    # Oban 작업으로 재시도 스케줄링 (지수 백오프 적용)
    backoff = get_backoff_for_attempt(message.retry_count || 0)

    %{message_id: message.id}
    |> AutomataSignal.Workers.MessageRetryWorker.new(
      queue: :message_retry,
      scheduled_in: backoff
    )
    |> Oban.insert!()
  end

  defp get_backoff_for_attempt(attempt) do
    base = 30
    max_backoff = 60 * 60  # 최대 1시간

    backoff = base * :math.pow(2, attempt)
    min(backoff, max_backoff)
  end
end
```

## 7. 모니터링 및 알림

메시지 처리 흐름의 모니터링 포인트:

1. **처리량 지표**:

   - 초당 생성된 메시지 수
   - 초당 처리된 메시지 수
   - 작업 큐 길이
   - 처리 지연 시간

2. **상태 비율 지표**:

   - 성공/실패/오류 메시지 비율
   - 채널별 전송 성공률
   - 도달률 및 전환율

3. **이상 알림**:
   - 비정상적인 높은 실패율
   - 특정 채널 오류 증가
   - 작업 큐 백로그 증가
   - 외부 서비스 연결 문제

## 8. 성능 고려사항

### 8.1 처리량 목표

- 초당 10만 건(10초당 100만 건)의 메시지 처리
- 단일 노드에서 초당 5,000-10,000건 처리
- 메시지 전송 지연 시간 500ms 이하

### 8.2 리소스 사용

- 노드당 30-50개의 데이터베이스 연결
- 적절한 워커 수 설정 (CPU 코어 수 × 2 권장)
- 메모리 사용량 모니터링 및 제한 설정

### 8.3 스케일링 전략

- 메시지 볼륨 증가 시 노드 수 증가
- 리전별 트래픽에 따른 노드 분배
- 작업 큐를 통한 부하 분산

---

// File: automata-signal/4-sequences/SEQ-003-lifecycle

# [SEQ-003] 라이프사이클 시퀀스

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [REF-001] API 참조
- [REF-002] 상태 코드
- [SEQ-002] 메시지 처리 시퀀스
- [COMP-001] 템플릿 엔진

## 요약

본 문서는 Automata-Signal 시스템에서 메시지의 라이프사이클과 상태 전이 규칙을 정의합니다. 메시지 생성부터 최종 상태까지의 모든 상태와 전이 규칙을 설명합니다.

## 대상 독자

- 개발팀
- QA 팀
- 운영팀
- 분석팀

## 1. 메시지 상태 다이어그램

다음 다이어그램은 메시지 상태와 가능한 전이를 보여줍니다:

```mermaid
stateDiagram-v2
    [*] --> pending: 메시지 생성

    pending --> successful: 외부 서비스 전송 성공
    pending --> failed: 유효하지 않은 토큰
    pending --> errored: 일시적 서비스 장애

    successful --> received: 디바이스/채널 도달
    successful --> failed: 시간 초과

    errored --> pending: 재시도
    errored --> successful: 재시도 성공
    errored --> failed: 최대 재시도 초과

    received --> converted: 사용자 클릭/열람
    received --> [*]: 만료

    converted --> [*]
    failed --> [*]

    note right of pending
        작업 큐에 저장된 상태
    end note

    note right of successful
        외부 서비스에 성공적으로 전송됨
    end note

    note right of received
        클라이언트가 수신 확인
    end note

    note right of converted
        사용자가 메시지 확인/클릭
    end note
```

## 2. 메시지 상태 정의

| 상태       | 상태명  | 정의                                    | 설명                                         |
| ---------- | ------- | --------------------------------------- | -------------------------------------------- |
| pending    | 대기 중 | 메시지가 생성되어 작업 큐에 저장된 상태 | 메시지가 생성되고 처리를 기다리는 초기 상태  |
| successful | 전송됨  | 외부 서비스에 성공적으로 전송된 상태    | APNS, FCM 등의 서비스에 메시지가 전달됨      |
| received   | 수신됨  | 디바이스/채널에 메시지가 도달한 상태    | 사용자 기기가 메시지를 받고 SDK가 수신 확인  |
| converted  | 열람됨  | 사용자가 메시지를 클릭/확인한 상태      | 사용자가 메시지를 열람하거나 액션을 취함     |
| failed     | 실패    | 메시지 전송이 실패한 상태               | 영구적인 오류(잘못된 토큰, 구독 취소 등)     |
| errored    | 오류    | 일시적인 서비스 장애로 인한 오류 상태   | 일시적인 오류(네트워크 문제, 서비스 장애 등) |

## 3. 상태 전이 정의

| 전이    | 시작 상태           | 종료 상태  | 트리거                                 | 설명                                           |
| ------- | ------------------- | ---------- | -------------------------------------- | ---------------------------------------------- |
| send    | pending             | successful | 메시지가 외부 서비스에 성공적으로 전송 | 메시지가 APNS, FCM 등의 서비스에 전달되면 발생 |
| fail    | pending, successful | failed     | 영구적인 전송 실패                     | 유효하지 않은 토큰, 구독 취소 등으로 인한 실패 |
| error   | pending             | errored    | 일시적인 서비스 장애                   | 네트워크 문제, 서비스 접근 불가 등 일시적 문제 |
| retry   | errored             | pending    | 재시도 스케줄링                        | 일정 시간 후 메시지 전송 재시도                |
| receive | successful          | received   | 기기/채널 도달 확인                    | 사용자 기기가 메시지를 수신했음을 확인         |
| convert | received            | converted  | 사용자 메시지 클릭/열람                | 사용자가 메시지와 상호작용함                   |
| timeout | successful          | failed     | 수신 확인 시간 초과                    | 일정 시간 내에 수신 확인이 없을 경우           |
| expire  | received            | 종료       | 만료 기간 경과                         | 클릭/열람 없이 만료 기간이 지난 경우           |

## 4. 상태별 타임스탬프

각 상태에는 해당 상태에 진입한 시점을 기록하는 타임스탬프가 있습니다:

| 상태       | 타임스탬프 필드  | 설명                           |
| ---------- | ---------------- | ------------------------------ |
| pending    | created_at       | 메시지 생성 시점               |
| successful | sent_at          | 외부 서비스에 전송된 시점      |
| received   | received_at      | 사용자 기기에 도달한 시점      |
| converted  | converted_at     | 사용자가 메시지를 열람한 시점  |
| failed     | failed_at        | 메시지 전송이 실패한 시점      |
| errored    | (별도 필드 없음) | error_details에 시간 정보 포함 |

## 5. 메시지 상태 추적 및 분석

### 5.1 핵심 지표 계산

| 지표        | 계산 방법                                    | 설명                                           |
| ----------- | -------------------------------------------- | ---------------------------------------------- |
| 전송률      | successful / (successful + failed + errored) | 성공적으로 전송된 메시지의 비율                |
| 도달률      | received / successful                        | 전송된 메시지 중 실제 기기에 도달한 비율       |
| 전환률      | converted / received                         | 수신된 메시지 중 사용자 상호작용이 발생한 비율 |
| 전체 전환률 | converted / (successful + failed + errored)  | 전체 메시지 중 사용자 상호작용이 발생한 비율   |

### 5.2 지연 시간 측정

| 지표           | 계산 방법                  | 설명                                     |
| -------------- | -------------------------- | ---------------------------------------- |
| 전송 지연      | sent_at - created_at       | 메시지 생성부터 전송까지 소요된 시간     |
| 도달 지연      | received_at - sent_at      | 전송부터 기기 도달까지 소요된 시간       |
| 상호작용 지연  | converted_at - received_at | 수신부터 사용자 상호작용까지 소요된 시간 |
| 전체 처리 시간 | converted_at - created_at  | 메시지 생성부터 상호작용까지 전체 시간   |

## 6. Ash State Machine 구현

메시지 상태 관리는 `ash_state_machine` 확장을 사용하여 구현됩니다:

```elixir
defmodule AutomataSignal.Resources.Message do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [AshStateMachine.Resource]

  attributes do
    uuid_primary_key :id
    attribute :title, :string
    attribute :body, :string
    attribute :data, :map, default: %{}
    attribute :user_id, :uuid
    attribute :subscription_id, :uuid
    attribute :application_id, :uuid
    attribute :campaign_id, :uuid, allow_nil?: true

    attribute :status, :atom do
      constraints [one_of: [:pending, :successful, :failed, :errored, :received, :converted]]
      default :pending
    end

    attribute :channel_type, :atom do
      constraints [one_of: [:push, :email, :sms, :kakao_talk, :in_app]]
    end

    timestamps()
    attribute :sent_at, :utc_datetime
    attribute :received_at, :utc_datetime
    attribute :converted_at, :utc_datetime
    attribute :failed_at, :utc_datetime

    attribute :error_reason, :string
    attribute :error_details, :map, default: %{}
    attribute :version_history, :map, default: %{}
  end

  state_machine do
    field :status

    initial_states [:pending]

    transitions do
      transition :send, from: [:pending], to: :successful
      transition :fail, from: [:pending, :successful], to: :failed
      transition :error, from: [:pending], to: :errored
      transition :retry, from: [:errored], to: :pending
      transition :receive, from: [:successful], to: :received
      transition :convert, from: [:received], to: :converted
    end

    on_transition :send do
      set_attribute :sent_at, &DateTime.utc_now/0
    end

    on_transition :fail do
      set_attribute :failed_at, &DateTime.utc_now/0
    end

    on_transition :receive do
      set_attribute :received_at, &DateTime.utc_now/0
    end

    on_transition :convert do
      set_attribute :converted_at, &DateTime.utc_now/0
    end
  end

  # ... 관계 및 기타 정의 ...
end
```

## 7. 메시지 이벤트 추적

상태 변경 시 `MessageEvent` 리소스를 통해 세부 이벤트를 기록합니다:

```elixir
defmodule AutomataSignal.Resources.MessageEvent do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [AshPaperTrail.Resource]

  attributes do
    uuid_primary_key :id
    attribute :message_id, :uuid
    attribute :event_type, :atom do
      constraints [one_of: [:created, :sent, :received, :converted, :failed, :errored, :retried]]
    end
    attribute :occurred_at, :utc_datetime
    attribute :metadata, :map, default: %{}
  end

  relationships do
    belongs_to :message, AutomataSignal.Resources.Message
  end

  paper_trail do
    track_attribute :event_type
    track_attribute :metadata
  end

  # ... 액션 및 기타 정의 ...
end
```

## 8. 채널별 특이사항

### 8.1 푸시 알림 채널

- Apple/Google 서비스는 전송 확인만 제공하고 기기 도달 확인은 SDK를 통해 수집
- 배지, 사운드, 알림음과 같은 추가 데이터는 `data` 맵에 저장

### 8.2 이메일 채널 (지원 예정)

- 전송 확인과 열람 추적을 위한 특수 픽셀 포함
- 바운스 및 스팸 신고 상태도 추적

### 8.3 SMS 채널 (지원 예정)

- 전송 확인은 가능하나 읽음 확인은 불가능
- 전환 확인을 위한 링크 클릭 추적 가능

### 8.4 카카오 알림톡 (지원 예정)

- 전송 및 읽음 확인 지원
- 버튼 액션 클릭 추적 가능

### 8.5 인앱 메시지 (지원 예정)

- 앱 내에서 모든 상태 추적 가능
- 가장 정확한 전환율 측정 가능

## 9. 재시도 전략

메시지 전송 실패 시 다음과 같은 재시도 전략을 사용합니다:

| 실패 유형                 | 재시도 여부 | 재시도 간격                        | 최대 시도 횟수    |
| ------------------------- | ----------- | ---------------------------------- | ----------------- |
| 일시적 네트워크 오류      | 예          | 지수 백오프 (30초, 2분, 5분, 15분) | 5회               |
| 서비스 장애               | 예          | 선형 간격 (15분)                   | 24회 (최대 6시간) |
| 영구적 오류 (잘못된 토큰) | 아니오      | -                                  | -                 |
| 서비스 비율 제한          | 예          | 서비스별 조정 (일반적으로 1~5분)   | 3회               |

재시도 로직은 Oban 작업 스케줄러를 통해 구현됩니다:

```elixir
defmodule AutomataSignal.Workers.MessageRetryWorker do
  use Oban.Worker, queue: :message_retry

  @impl Oban.Worker
  def perform(%Oban.Job{args: %{"message_id" => message_id}, attempt: attempt}) do
    message = AutomataSignal.Messages.get_message(message_id)

    case attempt do
      n when n <= 5 ->
        # 지수 백오프 전략 사용
        AutomataSignal.Messages.retry_message(message)
        :ok
      _ ->
        # 최대 재시도 횟수 초과
        AutomataSignal.Messages.mark_as_failed(message, "최대 재시도 횟수 초과")
        :ok
    end
  end
end
```

## 10. 만료 정책

메시지 상태별 만료 정책은 다음과 같습니다:

| 상태       | 만료 시간 | 만료 후 액션                   |
| ---------- | --------- | ------------------------------ |
| pending    | 24시간    | 실패로 표시 (시간 초과)        |
| successful | 72시간    | 수신 확인이 없으면 실패로 표시 |
| received   | 30일      | 통계로만 유지 (분석용)         |
| converted  | 무기한    | 통계로만 유지 (분석용)         |
| failed     | 90일      | 보관 처리 (장기 보관)          |
| errored    | 24시간    | 재시도 또는 실패로 전환        |

## 11. 분석 및 보고

메시지 상태 데이터를 기반으로 다음과 같은 분석이 가능합니다:

1. **채널별 성과 비교**: 푸시 알림, 이메일, SMS 등 채널별 전환율 비교
2. **시간대별 참여율**: 메시지 발송 시간과 사용자 참여 간의 상관관계 분석
3. **메시지 유형별 성과**: 알림, 마케팅, 트랜잭션 메시지 등 유형별 성과 비교
4. **재시도 효과성**: 재시도 전략이 성공률에 미치는 영향 분석
5. **사용자 세그먼트 분석**: 사용자 특성에 따른 참여율 차이 분석

---

// File: automata-signal/5-references/REF-001-api

# [REF-001] API 참조

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [DESIGN-001] 아키텍처 개요
- [DESIGN-002] 시스템 아키텍처
- [REF-002] 상태 코드
- [REF-003] 오류 코드

## 요약

본 문서는 Automata-Signal API의 포괄적인 참조 문서입니다. API 엔드포인트, 요청/응답 형식, 인증 방법, 오류 처리 등에 대한 상세 정보를 제공합니다.

## 대상 독자

- 클라이언트 개발자
- API 통합 개발자
- 시스템 엔지니어
- QA 엔지니어

## 1. API 개요

### 1.1 기본 URL

```
https://api.automata-signal.com/api/v1
```

리전별 엔드포인트:

- 아시아: `https://api-asia.automata-signal.com/api/v1`
- 유럽: `https://api-eu.automata-signal.com/api/v1`
- 오세아니아: `https://api-oce.automata-signal.com/api/v1`

### 1.2 인증

모든 API 요청은 HTTP 헤더를 통해 API 키를 제공해야 합니다:

```
X-API-Key: your_api_key_here
```

API 키는 애플리케이션 관리 인터페이스에서 생성하고 관리할 수 있습니다.

### 1.3 요청 형식

모든 요청 본문은 JSON 형식을 사용해야 하며, `Content-Type` 헤더를 `application/json`으로 설정해야 합니다.

### 1.4 응답 형식

모든 응답은 표준 JSON 형식을 사용하며, 다음과 같은 일관된 구조를 가집니다:

```json
{
  "status": "success",
  "data": { ... }
}
```

오류 발생 시:

```json
{
  "status": "error",
  "error": {
    "code": "error_code",
    "message": "오류 설명",
    "details": { ... }
  }
}
```

### 1.5 HTTP 상태 코드

API는 다음과 같은 HTTP 상태 코드를 사용합니다:

| 상태 코드 | 설명                                        |
| --------- | ------------------------------------------- |
| 200       | 성공 (OK)                                   |
| 201       | 생성됨 (Created)                            |
| 400       | 잘못된 요청 (Bad Request)                   |
| 401       | 인증 실패 (Unauthorized)                    |
| 403       | 접근 권한 없음 (Forbidden)                  |
| 404       | 리소스 없음 (Not Found)                     |
| 422       | 처리 불가능한 엔티티 (Unprocessable Entity) |
| 429       | 요청 횟수 제한 초과 (Too Many Requests)     |
| 500       | 서버 오류 (Internal Server Error)           |

### 1.6 비율 제한

API는 다음과 같은 비율 제한이 적용됩니다:

| 계층              | 제한              | 헤더 정보             |
| ----------------- | ----------------- | --------------------- |
| 기본 계층         | 분당 300개 요청   | X-RateLimit-Limit     |
| 프리미엄 계층     | 분당 1,000개 요청 | X-RateLimit-Remaining |
| 엔터프라이즈 계층 | 분당 5,000개 요청 | X-RateLimit-Reset     |

비율 제한에 도달하면 429 상태 코드가 반환됩니다. 응답 헤더에는 다음 정보가 포함됩니다:

- `X-RateLimit-Limit`: 분당 최대 요청 수
- `X-RateLimit-Remaining`: 현재 기간 내 남은 요청 수
- `X-RateLimit-Reset`: 비율 제한 카운터가 재설정되는 시간(Unix 타임스탬프)

## 2. 구독 관리 API

구독은 특정 채널(푸시 알림, 이메일, SMS 등)을 통해 사용자에게 메시지를 전송하기 위한 등록 정보입니다.

### 2.1 구독 생성

**엔드포인트:** `POST /subscriptions`

새로운 구독을 생성합니다.

**요청 본문:**

```json
{
  "type": "iOSPush",
  "token": "device_push_token_here",
  "user_id": "optional_user_id_if_known",
  "device_info": {
    "device_model": "iPhone 13",
    "device_os": "iOS 15.4",
    "device_language": "ko",
    "app_version": "1.0.0",
    "sdk_version": "1.0.0",
    "country_code": "KR",
    "test_type": 0
  }
}
```

**필수 필드:**

- `type`: 구독 유형 (iOSPush, AndroidPush, Email, SMS, KakaoTalk, InAppMessage)
- `token`: 채널 토큰 (푸시 토큰, 이메일 주소, 전화번호 등)

**선택적 필드:**

- `user_id`: 사용자 ID (알려진 경우)
- `device_info`: 디바이스 관련 정보

**응답:**

```json
{
  "status": "success",
  "data": {
    "subscription_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "type": "iOSPush",
    "subscription_status": 1,
    "created_at": "2025-04-05T08:30:45Z"
  }
}
```

### 2.2 구독 조회

**엔드포인트:** `GET /subscriptions/:id`

특정 구독의 정보를 조회합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "type": "iOSPush",
    "user_id": "u1234567890",
    "subscription_status": 1,
    "device_info": {
      "device_model": "iPhone 13",
      "device_os": "iOS 15.4",
      "device_language": "ko",
      "app_version": "1.0.0",
      "sdk_version": "1.0.0",
      "country_code": "KR"
    },
    "tags": {
      "premium_user": "true",
      "user_level": "silver"
    },
    "subscribed_at": "2025-04-05T08:30:45Z",
    "last_active_at": "2025-04-05T10:15:22Z"
  }
}
```

### 2.3 구독 업데이트

**엔드포인트:** `PATCH /subscriptions/:id`

기존 구독 정보를 업데이트합니다.

**요청 본문:**

```json
{
  "token": "updated_token_value",
  "device_info": {
    "app_version": "1.0.1"
  }
}
```

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "type": "iOSPush",
    "subscription_status": 1,
    "updated_at": "2025-04-05T11:22:33Z"
  }
}
```

### 2.4 구독 비활성화

**엔드포인트:** `POST /subscriptions/:id/disable`

구독을 비활성화합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "subscription_status": -2,
    "unsubscribed_at": "2025-04-05T15:45:12Z"
  }
}
```

### 2.5 구독 활성화

**엔드포인트:** `POST /subscriptions/:id/enable`

비활성화된 구독을 다시 활성화합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "subscription_status": 1,
    "subscribed_at": "2025-04-05T16:10:30Z"
  }
}
```

### 2.6 토큰 업데이트

**엔드포인트:** `POST /subscriptions/:id/update-token`

구독 토큰을 업데이트합니다(예: 푸시 토큰 갱신).

**요청 본문:**

```json
{
  "token": "new_token_value"
}
```

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "token_updated_at": "2025-04-05T16:30:45Z"
  }
}
```

### 2.7 태그 관리

**엔드포인트:** `POST /subscriptions/:id/tags`

구독에 태그를 추가하거나 업데이트합니다.

**요청 본문:**

```json
{
  "tags": {
    "premium_user": "true",
    "user_level": "gold",
    "favorite_category": "electronics"
  }
}
```

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "tags": {
      "premium_user": "true",
      "user_level": "gold",
      "favorite_category": "electronics"
    }
  }
}
```

**엔드포인트:** `DELETE /subscriptions/:id/tags`

구독에서 태그를 제거합니다.

**요청 본문:**

```json
{
  "tag_keys": ["user_level", "favorite_category"]
}
```

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "tags": {
      "premium_user": "true"
    }
  }
}
```

### 2.8 구독 목록 조회

**엔드포인트:** `GET /subscriptions`

구독 목록을 조회합니다.

**쿼리 파라미터:**

- `user_id`: 특정 사용자의 구독만 조회
- `type`: 특정 유형의 구독만 조회
- `status`: 특정 상태의 구독만 조회
- `page`: 페이지 번호
- `per_page`: 페이지당 항목 수

**응답:**

```json
{
  "status": "success",
  "data": {
    "subscriptions": [
      {
        "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "type": "iOSPush",
        "user_id": "u1234567890",
        "subscription_status": 1,
        "subscribed_at": "2025-04-05T08:30:45Z"
      },
      {
        "id": "b2c3d4e5-f678-9012-abcd-ef1234567890",
        "type": "Email",
        "user_id": "u1234567890",
        "subscription_status": 1,
        "subscribed_at": "2025-04-05T09:15:22Z"
      }
    ],
    "pagination": {
      "page": 1,
      "per_page": 20,
      "total_items": 2,
      "total_pages": 1
    }
  }
}
```

## 3. 사용자 관리 API

사용자는 여러 구독 채널을 가질 수 있는 애플리케이션 사용자를 나타냅니다.

### 3.1 사용자 식별

**엔드포인트:** `POST /users/identify`

사용자를 식별하고 구독을 연결합니다.

**요청 본문:**

```json
{
  "external_id": "user_123",
  "subscriptions": ["a1b2c3d4-e5f6-7890-abcd-ef1234567890"]
}
```

**필수 필드:**

- `external_id`: 애플리케이션의 사용자 식별자

**선택적 필드:**

- `subscriptions`: 사용자와 연결할 구독 ID 목록

**응답:**

```json
{
  "status": "success",
  "data": {
    "user_id": "u1234567890",
    "external_id": "user_123",
    "created_at": "2025-04-05T12:34:56Z"
  }
}
```

### 3.2 사용자 로그아웃

**엔드포인트:** `POST /users/logout`

현재 구독과 사용자의 연결을 해제합니다.

**요청 본문:**

```json
{
  "subscriptions": ["a1b2c3d4-e5f6-7890-abcd-ef1234567890"]
}
```

**응답:**

```json
{
  "status": "success",
  "data": {
    "unlinked_subscriptions": ["a1b2c3d4-e5f6-7890-abcd-ef1234567890"]
  }
}
```

### 3.3 사용자 구독 조회

**엔드포인트:** `GET /users/:external_id/subscriptions`

사용자의 모든 구독을 조회합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "subscriptions": [
      {
        "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "type": "iOSPush",
        "subscription_status": 1,
        "subscribed_at": "2025-04-05T08:30:45Z"
      },
      {
        "id": "b2c3d4e5-f678-9012-abcd-ef1234567890",
        "type": "Email",
        "subscription_status": 1,
        "subscribed_at": "2025-04-05T09:15:22Z"
      }
    ]
  }
}
```

### 3.4 사용자 삭제 요청

**엔드포인트:** `DELETE /users/:external_id`

사용자 정보와 관련 구독을 삭제합니다(GDPR 요청).

**응답:**

```json
{
  "status": "success",
  "data": {
    "message": "User deletion request has been processed",
    "request_id": "del-1234567890"
  }
}
```

## 4. 메시지 API

메시지 API를 사용하여 개별 메시지를 전송하고 상태를 추적할 수 있습니다.

### 4.1 메시지 전송

**엔드포인트:** `POST /messages`

개별 메시지를 전송합니다.

**요청 본문:**

```json
{
  "subscription_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "title": "알림 제목",
  "body": "알림 내용 메시지",
  "data": {
    "action": "open_screen",
    "screen": "order_details",
    "order_id": "ORD-12345"
  }
}
```

**필수 필드:**

- `subscription_id`: 메시지를 전송할 구독 ID
- `title` 또는 `body`: 메시지 제목 또는 본문(둘 중 하나는 필수)

**선택적 필드:**

- `data`: 메시지와 함께 전달할 추가 데이터

**응답:**

```json
{
  "status": "success",
  "data": {
    "message_id": "m1234567890",
    "status": "pending",
    "created_at": "2025-04-05T13:45:30Z"
  }
}
```

### 4.2 템플릿 기반 메시지 전송

**엔드포인트:** `POST /messages/template`

템플릿을 사용하여 메시지를 전송합니다.

**요청 본문:**

```json
{
  "subscription_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "template_id": "t1234567890",
  "variables": {
    "user_name": "홍길동",
    "order_id": "ORD-12345",
    "order_amount": "35,000원",
    "estimated_delivery": "4월 10일"
  }
}
```

**필수 필드:**

- `subscription_id`: 메시지를 전송할 구독 ID
- `template_id`: 사용할 템플릿 ID

**선택적 필드:**

- `variables`: 템플릿에 적용할 변수 데이터

**응답:**

```json
{
  "status": "success",
  "data": {
    "message_id": "m2345678901",
    "status": "pending",
    "created_at": "2025-04-05T14:22:15Z"
  }
}
```

### 4.3 메시지 상태 조회

**엔드포인트:** `GET /messages/:id`

특정 메시지의 상태와 정보를 조회합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "m1234567890",
    "subscription_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "title": "알림 제목",
    "body": "알림 내용 메시지",
    "data": {
      "action": "open_screen",
      "screen": "order_details",
      "order_id": "ORD-12345"
    },
    "status": "successful",
    "created_at": "2025-04-05T13:45:30Z",
    "sent_at": "2025-04-05T13:45:32Z",
    "events": [
      {
        "event_type": "sent",
        "occurred_at": "2025-04-05T13:45:32Z"
      }
    ]
  }
}
```

### 4.4 메시지 상태 업데이트

**엔드포인트:** `POST /messages/:id/status`

메시지 상태를 업데이트합니다(SDK에서 수신 확인 시).

**요청 본문:**

```json
{
  "status": "received"
}
```

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "m1234567890",
    "status": "received",
    "received_at": "2025-04-05T13:46:05Z"
  }
}
```

### 4.5 메시지 변환 추적

**엔드포인트:** `POST /messages/:id/convert`

메시지 상호작용(클릭, 열기 등)을 추적합니다.

**요청 본문:**

```json
{
  "action": "clicked_button",
  "data": {
    "button_id": "confirm",
    "screen": "order_details"
  }
}
```

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "m1234567890",
    "status": "converted",
    "converted_at": "2025-04-05T13:48:22Z"
  }
}
```

### 4.6 메시지 전송 취소

**엔드포인트:** `POST /messages/:id/cancel`

아직 처리되지 않은 메시지의 전송을 취소합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "m1234567890",
    "status": "cancelled",
    "cancelled_at": "2025-04-05T13:50:10Z"
  }
}
```

## 5. 템플릿 API

템플릿 API를 사용하여 재사용 가능한 메시지 템플릿을 관리할 수 있습니다.

### 5.1 템플릿 생성

**엔드포인트:** `POST /templates`

새로운 메시지 템플릿을 생성합니다.

**요청 본문:**

```json
{
  "name": "주문 확인 알림",
  "title_template": "{{user_name}}님의 주문이 확인되었습니다",
  "body_template": "주문번호 {{order_id}}가 확인되었습니다. 결제금액: {{order_amount}}, 예상 배송일: {{estimated_delivery}}",
  "data_template": {
    "action": "open_screen",
    "screen": "order_details",
    "order_id": "{{order_id}}"
  },
  "description": "주문 확인 시 전송되는 알림 템플릿"
}
```

**필수 필드:**

- `name`: 템플릿 이름
- `title_template` 또는 `body_template`: 제목 또는 본문 템플릿(둘 중 하나는 필수)

**선택적 필드:**

- `data_template`: 추가 데이터 템플릿
- `description`: 템플릿 설명

**응답:**

```json
{
  "status": "success",
  "data": {
    "template_id": "t1234567890",
    "name": "주문 확인 알림",
    "created_at": "2025-04-05T15:10:22Z",
    "version": 1
  }
}
```

### 5.2 템플릿 조회

**엔드포인트:** `GET /templates/:id`

특정 템플릿의 정보를 조회합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "t1234567890",
    "name": "주문 확인 알림",
    "title_template": "{{user_name}}님의 주문이 확인되었습니다",
    "body_template": "주문번호 {{order_id}}가 확인되었습니다. 결제금액: {{order_amount}}, 예상 배송일: {{estimated_delivery}}",
    "data_template": {
      "action": "open_screen",
      "screen": "order_details",
      "order_id": "{{order_id}}"
    },
    "description": "주문 확인 시 전송되는 알림 템플릿",
    "created_at": "2025-04-05T15:10:22Z",
    "updated_at": "2025-04-05T15:10:22Z",
    "version": 1,
    "is_active": true
  }
}
```

### 5.3 템플릿 업데이트

**엔드포인트:** `PUT /templates/:id`

기존 템플릿 정보를 업데이트합니다.

**요청 본문:**

```json
{
  "title_template": "{{user_name}}님, 주문이 확인되었습니다",
  "body_template": "주문번호: {{order_id}}\n결제금액: {{order_amount}}\n예상 배송일: {{estimated_delivery}}",
  "data_template": {
    "action": "open_screen",
    "screen": "order_details",
    "order_id": "{{order_id}}",
    "highlight": true
  }
}
```

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "t1234567890",
    "version": 2,
    "updated_at": "2025-04-05T16:30:45Z"
  }
}
```

### 5.4 템플릿 비활성화

**엔드포인트:** `POST /templates/:id/disable`

템플릿을 비활성화합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "t1234567890",
    "is_active": false,
    "updated_at": "2025-04-05T17:15:30Z"
  }
}
```

### 5.5 템플릿 활성화

**엔드포인트:** `POST /templates/:id/enable`

비활성화된 템플릿을 다시 활성화합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "t1234567890",
    "is_active": true,
    "updated_at": "2025-04-05T17:45:12Z"
  }
}
```

### 5.6 템플릿 목록 조회

**엔드포인트:** `GET /templates`

템플릿 목록을 조회합니다.

**쿼리 파라미터:**

- `is_active`: 활성 템플릿만 조회(true/false)
- `page`: 페이지 번호
- `per_page`: 페이지당 항목 수

**응답:**

```json
{
  "status": "success",
  "data": {
    "templates": [
      {
        "id": "t1234567890",
        "name": "주문 확인 알림",
        "version": 2,
        "is_active": true,
        "created_at": "2025-04-05T15:10:22Z",
        "updated_at": "2025-04-05T16:30:45Z"
      },
      {
        "id": "t2345678901",
        "name": "배송 시작 알림",
        "version": 1,
        "is_active": true,
        "created_at": "2025-04-05T15:30:12Z",
        "updated_at": "2025-04-05T15:30:12Z"
      }
    ],
    "pagination": {
      "page": 1,
      "per_page": 20,
      "total_items": 2,
      "total_pages": 1
    }
  }
}
```

### 5.7 템플릿 렌더링 테스트

**엔드포인트:** `POST /templates/:id/render-test`

템플릿을 테스트 렌더링합니다.

**요청 본문:**

```json
{
  "variables": {
    "user_name": "홍길동",
    "order_id": "ORD-12345",
    "order_amount": "35,000원",
    "estimated_delivery": "4월 10일"
  }
}
```

**응답:**

```json
{
  "status": "success",
  "data": {
    "title": "홍길동님, 주문이 확인되었습니다",
    "body": "주문번호: ORD-12345\n결제금액: 35,000원\n예상 배송일: 4월 10일",
    "data": {
      "action": "open_screen",
      "screen": "order_details",
      "order_id": "ORD-12345",
      "highlight": true
    }
  }
}
```

## 6. 캠페인 API

캠페인 API를 사용하여 대규모 메시지 캠페인을 관리할 수 있습니다.

### 6.1 캠페인 생성

**엔드포인트:** `POST /campaigns`

새로운 메시지 캠페인을 생성합니다.

**요청 본문:**

```json
{
  "name": "4월 프로모션 캠페인",
  "template_id": "t1234567890",
  "targeting_criteria": {
    "tags": {
      "premium_user": "true",
      "user_level": ["silver", "gold", "platinum"]
    },
    "last_active_after": "2025-03-01T00:00:00Z",
    "countries": ["KR"]
  },
  "variables": {
    "promotion_name": "봄맞이 할인 행사",
    "discount_percent": "20%",
    "promotion_end_date": "4월 15일"
  },
  "scheduled_at": "2025-04-10T09:00:00Z"
}
```

**필수 필드:**

- `name`: 캠페인 이름
- `template_id` 또는 직접 메시지 내용(`title`, `body`, `data`)

**선택적 필드:**

- `targeting_criteria`: 대상 사용자 필터링 조건
- `variables`: 템플릿 변수 데이터
- `scheduled_at`: 예약 전송 시간(미설정 시 즉시 전송)

**응답:**

```json
{
  "status": "success",
  "data": {
    "campaign_id": "c1234567890",
    "name": "4월 프로모션 캠페인",
    "status": "scheduled",
    "scheduled_at": "2025-04-10T09:00:00Z",
    "created_at": "2025-04-05T18:30:45Z"
  }
}
```

### 6.2 캠페인 조회

**엔드포인트:** `GET /campaigns/:id`

특정 캠페인의 정보를 조회합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "c1234567890",
    "name": "4월 프로모션 캠페인",
    "template_id": "t1234567890",
    "targeting_criteria": {
      "tags": {
        "premium_user": "true",
        "user_level": ["silver", "gold", "platinum"]
      },
      "last_active_after": "2025-03-01T00:00:00Z",
      "countries": ["KR"]
    },
    "variables": {
      "promotion_name": "봄맞이 할인 행사",
      "discount_percent": "20%",
      "promotion_end_date": "4월 15일"
    },
    "status": "scheduled",
    "scheduled_at": "2025-04-10T09:00:00Z",
    "created_at": "2025-04-05T18:30:45Z",
    "created_by": "api_user",
    "total_recipients": 0,
    "successful_count": 0,
    "failed_count": 0
  }
}
```

### 6.3 캠페인 실행

**엔드포인트:** `POST /campaigns/:id/execute`

예약된 캠페인을 즉시 실행합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "c1234567890",
    "status": "in_progress",
    "started_at": "2025-04-05T19:15:30Z"
  }
}
```

### 6.4 캠페인 취소

**엔드포인트:** `POST /campaigns/:id/cancel`

예약되거나 진행 중인 캠페인을 취소합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "c1234567890",
    "status": "cancelled",
    "cancelled_at": "2025-04-05T19:45:12Z"
  }
}
```

### 6.5 캠페인 통계 조회

**엔드포인트:** `GET /campaigns/:id/stats`

캠페인의 전송 및 참여 통계를 조회합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "id": "c1234567890",
    "name": "4월 프로모션 캠페인",
    "status": "completed",
    "total_recipients": 5420,
    "successful_count": 5380,
    "failed_count": 40,
    "received_count": 4930,
    "converted_count": 1245,
    "channel_stats": {
      "push": {
        "total": 3200,
        "successful": 3180,
        "failed": 20,
        "received": 2950,
        "converted": 720
      },
      "email": {
        "total": 2220,
        "successful": 2200,
        "failed": 20,
        "received": 1980,
        "converted": 525
      }
    },
    "delivery_rate": 99.26,
    "receive_rate": 91.63,
    "conversion_rate": 25.25,
    "started_at": "2025-04-10T09:00:03Z",
    "completed_at": "2025-04-10T09:15:45Z"
  }
}
```

### 6.6 캠페인 목록 조회

**엔드포인트:** `GET /campaigns`

캠페인 목록을 조회합니다.

**쿼리 파라미터:**

- `status`: 특정 상태의 캠페인만 조회
- `from`: 시작 날짜/시간 필터(ISO 8601 형식)
- `to`: 종료 날짜/시간 필터(ISO 8601 형식)
- `page`: 페이지 번호
- `per_page`: 페이지당 항목 수

**응답:**

```json
{
  "status": "success",
  "data": {
    "campaigns": [
      {
        "id": "c1234567890",
        "name": "4월 프로모션 캠페인",
        "status": "scheduled",
        "scheduled_at": "2025-04-10T09:00:00Z",
        "created_at": "2025-04-05T18:30:45Z",
        "total_recipients": 0
      },
      {
        "id": "c2345678901",
        "name": "3월 이벤트 알림",
        "status": "completed",
        "started_at": "2025-03-15T10:00:00Z",
        "completed_at": "2025-03-15T10:12:34Z",
        "total_recipients": 4850,
        "successful_count": 4820,
        "failed_count": 30
      }
    ],
    "pagination": {
      "page": 1,
      "per_page": 20,
      "total_items": 2,
      "total_pages": 1
    }
  }
}
```

## 7. 분석 API

분석 API를 사용하여 메시지 성과 및 사용자 참여 데이터를 조회할 수 있습니다.

### 7.1 메시지 통계 조회

**엔드포인트:** `GET /analytics/messages`

전체 메시지 전송 및 참여 통계를 조회합니다.

**쿼리 파라미터:**

- `from`: 시작 날짜/시간 필터(ISO 8601 형식)
- `to`: 종료 날짜/시간 필터(ISO 8601 형식)
- `channel_type`: 채널 유형 필터
- `group_by`: 통계 그룹화 방식 (day, week, month, channel)

**응답:**

```json
{
  "status": "success",
  "data": {
    "period": {
      "from": "2025-04-01T00:00:00Z",
      "to": "2025-04-05T23:59:59Z"
    },
    "summary": {
      "total_sent": 125430,
      "successful": 124980,
      "failed": 450,
      "received": 115420,
      "converted": 28560,
      "delivery_rate": 99.64,
      "receive_rate": 92.35,
      "conversion_rate": 24.74
    },
    "by_channel": {
      "push": {
        "total_sent": 85230,
        "successful": 84950,
        "failed": 280,
        "received": 79820,
        "converted": 19450,
        "delivery_rate": 99.67,
        "receive_rate": 93.96,
        "conversion_rate": 24.37
      },
      "email": {
        "total_sent": 40200,
        "successful": 40030,
        "failed": 170,
        "received": 35600,
        "converted": 9110,
        "delivery_rate": 99.58,
        "receive_rate": 88.93,
        "conversion_rate": 25.59
      }
    },
    "by_day": [
      {
        "date": "2025-04-01",
        "total_sent": 25120,
        "successful": 25020,
        "failed": 100,
        "received": 23150,
        "converted": 5720
      },
      {
        "date": "2025-04-02",
        "total_sent": 24580,
        "successful": 24500,
        "failed": 80,
        "received": 22670,
        "converted": 5530
      }
      // ... 다른 날짜 데이터
    ]
  }
}
```

### 7.2 구독 통계 조회

**엔드포인트:** `GET /analytics/subscriptions`

구독 현황 통계를 조회합니다.

**쿼리 파라미터:**

- `from`: 시작 날짜/시간 필터(ISO 8601 형식)
- `to`: 종료 날짜/시간 필터(ISO 8601 형식)
- `group_by`: 통계 그룹화 방식 (day, week, month, channel)

**응답:**

```json
{
  "status": "success",
  "data": {
    "period": {
      "from": "2025-04-01T00:00:00Z",
      "to": "2025-04-05T23:59:59Z"
    },
    "summary": {
      "total_active": 250430,
      "new_subscriptions": 5280,
      "unsubscribed": 1240,
      "net_change": 4040
    },
    "by_channel": {
      "push": {
        "total_active": 180250,
        "new_subscriptions": 3750,
        "unsubscribed": 820,
        "net_change": 2930
      },
      "email": {
        "total_active": 70180,
        "new_subscriptions": 1530,
        "unsubscribed": 420,
        "net_change": 1110
      }
    },
    "by_day": [
      {
        "date": "2025-04-01",
        "new_subscriptions": 1050,
        "unsubscribed": 240,
        "net_change": 810
      },
      {
        "date": "2025-04-02",
        "new_subscriptions": 980,
        "unsubscribed": 210,
        "net_change": 770
      }
      // ... 다른 날짜 데이터
    ]
  }
}
```

### 7.3 사용자 참여 분석

**엔드포인트:** `GET /analytics/engagement`

사용자 참여 데이터를 조회합니다.

**쿼리 파라미터:**

- `from`: 시작 날짜/시간 필터(ISO 8601 형식)
- `to`: 종료 날짜/시간 필터(ISO 8601 형식)
- `segment`: 사용자 세그먼트 필터(태그 기반)

**응답:**

```json
{
  "status": "success",
  "data": {
    "period": {
      "from": "2025-04-01T00:00:00Z",
      "to": "2025-04-05T23:59:59Z"
    },
    "overall_engagement": {
      "total_users": 125000,
      "active_users": 85600,
      "engagement_rate": 68.48,
      "average_response_time": 125.4
    },
    "by_segment": {
      "premium_users": {
        "total_users": 32500,
        "active_users": 24800,
        "engagement_rate": 76.31,
        "average_response_time": 98.2
      },
      "regular_users": {
        "total_users": 92500,
        "active_users": 60800,
        "engagement_rate": 65.73,
        "average_response_time": 135.7
      }
    },
    "top_converting_messages": [
      {
        "template_id": "t1234567890",
        "template_name": "특별 할인 알림",
        "conversion_rate": 38.5,
        "total_sent": 12500
      },
      {
        "template_id": "t2345678901",
        "template_name": "재입고 알림",
        "conversion_rate": 36.2,
        "total_sent": 8750
      }
      // ... 다른 메시지 데이터
    ]
  }
}
```

### 7.4 사용량 및 할당량 조회

**엔드포인트:** `GET /analytics/usage`

앱의 메시지 사용량 및 할당량 정보를 조회합니다.

**응답:**

```json
{
  "status": "success",
  "data": {
    "current_period": {
      "start_date": "2025-04-01T00:00:00Z",
      "end_date": "2025-04-30T23:59:59Z"
    },
    "quotas": {
      "daily": {
        "limit": 100000,
        "used": 25430,
        "remaining": 74570,
        "reset_at": "2025-04-06T00:00:00Z"
      },
      "monthly": {
        "limit": 2000000,
        "used": 125430,
        "remaining": 1874570,
        "reset_at": "2025-05-01T00:00:00Z"
      }
    },
    "usage_by_channel": {
      "push": 85230,
      "email": 40200
    },
    "usage_trend": [
      {
        "date": "2025-04-01",
        "total": 25120,
        "push": 18250,
        "email": 6870
      },
      {
        "date": "2025-04-02",
        "total": 24580,
        "push": 17420,
        "email": 7160
      }
      // ... 다른 날짜 데이터
    ]
  }
}
```

## 8. 오류 처리

### 8.1 오류 응답 형식

모든 오류 응답은 다음 형식을 따릅니다:

```json
{
  "status": "error",
  "error": {
    "code": "error_code",
    "message": "오류에 대한 설명",
    "details": {
      // 추가 오류 세부 정보
    }
  }
}
```

### 8.2 일반 오류 코드

| 오류 코드             | 설명                                       | HTTP 상태 코드 |
| --------------------- | ------------------------------------------ | -------------- |
| invalid_request       | 잘못된 요청 형식 또는 필수 필드 누락       | 400            |
| authentication_failed | 인증 실패 (API 키 누락 또는 유효하지 않음) | 401            |
| permission_denied     | 권한 없음                                  | 403            |
| resource_not_found    | 요청한 리소스를 찾을 수 없음               | 404            |
| validation_error      | 데이터 유효성 검증 실패                    | 422            |
| rate_limit_exceeded   | 요청 비율 제한 초과                        | 429            |
| internal_server_error | 서버 내부 오류                             | 500            |

### 8.3 리소스별 오류 코드

#### 구독 관련 오류

| 오류 코드                 | 설명                    | HTTP 상태 코드 |
| ------------------------- | ----------------------- | -------------- |
| invalid_token             | 유효하지 않은 구독 토큰 | 400            |
| invalid_subscription_type | 지원되지 않는 구독 유형 | 400            |
| duplicate_subscription    | 중복된 구독 토큰        | 400            |
| subscription_disabled     | 비활성화된 구독         | 400            |

#### 메시지 관련 오류

| 오류 코드                 | 설명                         | HTTP 상태 코드 |
| ------------------------- | ---------------------------- | -------------- |
| message_too_large         | 메시지 크기 초과             | 400            |
| invalid_message_content   | 유효하지 않은 메시지 내용    | 400            |
| quota_exceeded            | 메시지 할당량 초과           | 403            |
| message_already_processed | 이미 처리된 메시지 수정 시도 | 400            |

#### 템플릿 관련 오류

| 오류 코드                  | 설명                        | HTTP 상태 코드 |
| -------------------------- | --------------------------- | -------------- |
| template_not_found         | 템플릿을 찾을 수 없음       | 404            |
| invalid_template_variables | 유효하지 않은 템플릿 변수   | 400            |
| missing_required_variable  | 필수 템플릿 변수 누락       | 400            |
| template_inactive          | 비활성화된 템플릿 사용 시도 | 400            |

#### 캠페인 관련 오류

| 오류 코드                  | 설명                         | HTTP 상태 코드 |
| -------------------------- | ---------------------------- | -------------- |
| campaign_not_found         | 캠페인을 찾을 수 없음        | 404            |
| invalid_targeting_criteria | 유효하지 않은 타겟팅 조건    | 400            |
| campaign_already_started   | 이미 시작된 캠페인 수정 시도 | 400            |
| campaign_already_completed | 이미 완료된 캠페인 취소 시도 | 400            |

### 8.4 오류 응답 예시

**인증 실패:**

```json
{
  "status": "error",
  "error": {
    "code": "authentication_failed",
    "message": "API 키가 유효하지 않습니다",
    "details": {
      "header": "X-API-Key"
    }
  }
}
```

**유효성 검증 실패:**

```json
{
  "status": "error",
  "error": {
    "code": "validation_error",
    "message": "요청 데이터의 유효성 검증에 실패했습니다",
    "details": {
      "fields": {
        "title": "제목은 필수 입력 항목입니다",
        "subscription_id": "유효한 UUID 형식이어야 합니다"
      }
    }
  }
}
```

**리소스 없음:**

```json
{
  "status": "error",
  "error": {
    "code": "resource_not_found",
    "message": "요청한 메시지를 찾을 수 없습니다",
    "details": {
      "id": "m9876543210"
    }
  }
}
```

**할당량 초과:**

```json
{
  "status": "error",
  "error": {
    "code": "quota_exceeded",
    "message": "일일 메시지 할당량을 초과했습니다",
    "details": {
      "limit": 100000,
      "used": 100000,
      "reset_at": "2025-04-06T00:00:00Z"
    }
  }
}
```

## 9. API 모범 사례

### 9.1 요청 최적화

- **배치 처리**: 가능한 한 배치 API를 사용하여 요청 수를 최소화하세요.
- **필요한 필드 지정**: 필요한 필드만 요청하여 응답 크기를 최적화하세요.
- **적절한 페이지 크기**: 목록 API에서 합리적인 페이지 크기(20-100개)를 사용하세요.
- **조건부 요청**: `If-Modified-Since` 헤더를 사용하여 변경된 데이터만 조회하세요.

### 9.2 오류 처리

- **모든 오류 처리**: 발생 가능한 모든 HTTP 상태 코드에 대해 처리 로직을 구현하세요.
- **재시도 전략**: 일시적인 오류(429, 500-504)에 대한 적절한 재시도 전략을 구현하세요.
- **백오프 알고리즘**: 재시도 시 지수 백오프 알고리즘을 사용하세요.
- **오류 로깅**: 오류 응답을 로깅하여 디버깅 및 문제 해결에 활용하세요.

### 9.3 보안 모범 사례

- **API 키 보호**: API 키를 소스 코드에 하드코딩하지 마세요.
- **HTTPS 사용**: 항상 HTTPS를 통해 API를 호출하세요.
- **최소 권한 원칙**: 필요한 최소한의 권한만 가진 API 키를 사용하세요.
- **키 순환**: 정기적으로 API 키를 갱신하세요.

### 9.4 성능 최적화

- **연결 풀링**: HTTP 클라이언트에서 연결 풀링을 활성화하세요.
- **요청 압축**: 대용량 요청에 대해 Gzip 압축을 활성화하세요.
- **비동기 처리**: 응답을 기다릴 필요가 없는 경우 비동기 호출을 사용하세요.
- **캐싱**: 자주 액세스하는 데이터를 적절히 캐싱하세요.

## 10. API 클라이언트 예제

### 10.1 cURL 예제

**메시지 전송:**

```bash
curl -X POST \
  https://api.automata-signal.com/api/v1/messages \
  -H 'Content-Type: application/json' \
  -H 'X-API-Key: your_api_key_here' \
  -d '{
    "subscription_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
    "title": "알림 제목",
    "body": "알림 내용 메시지",
    "data": {
      "action": "open_screen",
      "screen": "order_details",
      "order_id": "ORD-12345"
    }
  }'
```

**구독 목록 조회:**

```bash
curl -X GET \
  'https://api.automata-signal.com/api/v1/subscriptions?user_id=u1234567890&type=iOSPush' \
  -H 'X-API-Key: your_api_key_here'
```

### 10.2 Node.js 예제

```javascript
const axios = require('axios');

const API_KEY = 'your_api_key_here';
const BASE_URL = 'https://api.automata-signal.com/api/v1';

// 메시지 전송 함수
async function sendMessage(subscriptionId, title, body, data) {
  try {
    const response = await axios({
      method: 'post',
      url: `${BASE_URL}/messages`,
      headers: {
        'Content-Type': 'application/json',
        'X-API-Key': API_KEY,
      },
      data: {
        subscription_id: subscriptionId,
        title,
        body,
        data,
      },
    });

    return response.data;
  } catch (error) {
    if (error.response) {
      // API 오류 응답
      console.error('API Error:', error.response.data);
    } else {
      // 네트워크 오류
      console.error('Network Error:', error.message);
    }
    throw error;
  }
}

// 사용 예시
sendMessage('a1b2c3d4-e5f6-7890-abcd-ef1234567890', '알림 제목', '알림 내용 메시지', {
  action: 'open_screen',
  screen: 'order_details',
  order_id: 'ORD-12345',
})
  .then((result) => console.log('Message sent:', result))
  .catch((err) => console.error('Failed to send message:', err));
```

### 10.3 Python 예제

```python
import requests
import json

API_KEY = 'your_api_key_here'
BASE_URL = 'https://api.automata-signal.com/api/v1'

def send_message(subscription_id, title, body, data=None):
    """
    메시지를 전송합니다.

    Args:
        subscription_id (str): 구독 ID
        title (str): 메시지 제목
        body (str): 메시지 본문
        data (dict, optional): 추가 데이터

    Returns:
        dict: API 응답 데이터
    """
    headers = {
        'Content-Type': 'application/json',
        'X-API-Key': API_KEY
    }

    payload = {
        'subscription_id': subscription_id,
        'title': title,
        'body': body
    }

    if data:
        payload['data'] = data

    try:
        response = requests.post(
            f'{BASE_URL}/messages',
            headers=headers,
            data=json.dumps(payload)
        )

        response.raise_for_status()  # 4xx, 5xx 오류 발생 시 예외 발생
        return response.json()

    except requests.exceptions.HTTPError as err:
        print(f'HTTP Error: {err}')
        print(f'Response: {response.text}')
        raise
    except requests.exceptions.RequestException as err:
        print(f'Request Error: {err}')
        raise

# 사용 예시
if __name__ == '__main__':
    try:
        result = send_message(
            'a1b2c3d4-e5f6-7890-abcd-ef1234567890',
            '알림 제목',
            '알림 내용 메시지',
            {
                'action': 'open_screen',
                'screen': 'order_details',
                'order_id': 'ORD-12345'
            }
        )
        print('Message sent:', result)
    except Exception as e:
        print('Failed to send message:', e)
```

## 11. 결론

Automata-Signal API는 멀티채널 메시징 플랫폼을 위한 포괄적인 인터페이스를 제공합니다. 이 API를 통해 다양한 채널(푸시 알림, 이메일, SMS 등)을 통해 사용자에게 메시지를 전송하고, 대규모 캠페인을 관리하며, 메시지 성과를 추적할 수 있습니다.

API 사용 중 문제가 발생하거나 추가 도움이 필요한 경우 support@automata-signal.com으로 문의하거나 개발자 포럼을 이용해 주시기 바랍니다.

---

// File: automata-signal/5-references/REF-002-status-codes

# [REF-002] 상태 코드

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [SEQ-001] 초기화 시퀀스
- [SEQ-003] 라이프사이클 시퀀스
- [COMP-002] 어댑터 시스템
- [REF-001] API 참조

## 요약

본 문서는 Automata-Signal 시스템에서 사용하는 구독 상태 코드의 정의와 의미를 설명합니다. 각 채널별 구독 상태와 오류 코드를 포함합니다.

## 대상 독자

- 개발팀
- QA 팀
- 운영팀
- 고객 지원팀

## 1. 구독 상태 코드 체계

Automata-Signal은 다음과 같은 구독 상태 코드 체계를 사용합니다:

```mermaid
flowchart TD
    A[subscription_status] --> B[기본 상태: -2, -31, 0, 1, ...]
    A --> C[푸시 알림 오류: -3 ~ -24]
    A --> D[이메일 오류: -40 ~ -49]
    A --> E[SMS 오류: -50 ~ -59]
    A --> F[카카오톡 오류: -60 ~ -69]
    A --> G[인앱 메시지 오류: -70 ~ -79]
```

- 양수 값: 구독 활성화 상태
- 0 또는 -99: 초기 상태
- -2, -31: 기본 구독 취소 상태
- 음수 범위: 채널별 오류 상태

## 2. 기본 구독 상태

| 코드   | 상태명                | 정의                  | 설명                                                                               |
| ------ | --------------------- | --------------------- | ---------------------------------------------------------------------------------- |
| 1 이상 | SUBSCRIBED            | 구독됨                | 해당 채널에서 메시지를 수신할 수 있는 상태. 푸시 알림의 경우 유효한 토큰이 필요함. |
| 0, -99 | NEVER_SUBSCRIBED      | 구독된 적 없음        | 초기 상태. 해당 채널에 아직 구독되지 않음.                                         |
| -2     | UNSUBSCRIBED          | 구독 취소됨           | 사용자가 직접 구독을 취소한 상태. enabled 속성을 false로 설정할 때 권장되는 값.    |
| -31    | DISABLED_BY_API       | API를 통해 비활성화됨 | REST API를 통해 관리자나 시스템에 의해 비활성화된 경우.                            |
| -98    | PENDING_DOUBLE_OPT_IN | 이중 확인 대기 중     | SMS/이메일에서 더블 옵트인을 기다리는 상태.                                        |

## 3. 푸시 알림 관련 오류 코드

### 3.1 Android 관련 오류

| 코드             | 상태명                 | 정의                              | 설명                                                 | 권장 조치                                       |
| ---------------- | ---------------------- | --------------------------------- | ---------------------------------------------------- | ----------------------------------------------- |
| -3, -5           | ANDROID_SUPPORT_ERROR  | Android 지원 라이브러리 오류      | 앱의 Android 지원 라이브러리 추가 또는 업데이트 필요 | 앱 개발자에게 Firebase 라이브러리 업데이트 요청 |
| -4, -8, -11, -12 | PLAY_SERVICES_ERROR    | Android Google Play 서비스 오류   | Google Play 서비스 라이브러리 업그레이드 필요        | 사용자에게 Google Play 서비스 업데이트 안내     |
| -6               | SENDER_ID_MISMATCH     | Android 잘못된 프로젝트 번호      | FCMv1 Sender ID가 토큰 원본과 일치하지 않음          | 서버 설정에서 올바른 Sender ID 확인             |
| -7, -9           | OUTDATED_PLAY_SERVICES | Android 구버전 Google Play 서비스 | 기기의 Google Play 서비스 앱 업데이트 필요           | 사용자에게 Google Play 서비스 업데이트 안내     |

### 3.2 iOS 관련 오류

| 코드          | 상태명                      | 정의                | 설명                          | 권장 조치                                  |
| ------------- | --------------------------- | ------------------- | ----------------------------- | ------------------------------------------ |
| -13           | IOS_PUSH_CAPABILITY_MISSING | iOS 푸시 기능 누락  | 필요한 SDK 설정 단계가 누락됨 | 앱 개발자에게 푸시 알림 기능 구성 요청     |
| -14, -16, -17 | APNS_CONNECTION_ERROR       | iOS APNS 오류       | 기기가 APNS 연결에 문제 있음  | 네트워크 연결 확인 및 기기 재시작 권장     |
| -15           | IOS_SIMULATOR_ERROR         | iOS 시뮬레이터 오류 | iOS 16.4+ 시뮬레이터 필요     | 개발 환경에서만 발생, 실제 기기에서는 무시 |

### 3.3 공통 푸시 오류

| 코드               | 상태명                   | 정의                | 설명                                                   | 권장 조치                               |
| ------------------ | ------------------------ | ------------------- | ------------------------------------------------------ | --------------------------------------- |
| -10                | PUSH_UNSUBSCRIBED        | 구독되지 않음       | 앱 제거 또는 기기 설정에서 구독 취소됨, 웹 푸시 차단됨 | 사용자에게 앱 설정에서 알림 허용 안내   |
| -18                | PERMISSION_NOT_REQUESTED | 권한 요청 안됨      | 구독 권한 요청이 표시된 적 없음                        | 앱 시작 시 권한 요청 대화상자 표시      |
| -19                | PERMISSION_NO_RESPONSE   | 권한 요청 무응답    | 구독 권한 요청이 표시되었으나 응답하지 않음            | 적절한 시점에 권한 요청 재시도          |
| -22                | MANUALLY_UNSUBSCRIBED    | 수동 구독 취소      | 사용자가 권한을 철회함                                 | 푸시 알림 가치 설명 및 재구독 유도      |
| -20, -21, -23, -24 | WEB_PUSH_ERROR           | 웹 레코드 관련 오류 | 웹 푸시 권한 철회 또는 서비스 워커 오류                | 웹 푸시 설정 확인 및 서비스 워커 재등록 |

## 4. 이메일 관련 오류 코드 (지원 예정)

| 코드 | 상태명             | 정의                 | 설명                                       | 권장 조치                       |
| ---- | ------------------ | -------------------- | ------------------------------------------ | ------------------------------- |
| -40  | INVALID_EMAIL      | 유효하지 않은 이메일 | 이메일 형식이 올바르지 않음                | 유효한 이메일 주소 입력 요청    |
| -41  | EMAIL_SEND_FAILED  | 이메일 전송 실패     | 일반적인 이메일 전송 오류                  | 이메일 서비스 상태 확인         |
| -42  | HARD_BOUNCE        | 하드 바운스          | 영구적인 전송 실패 (존재하지 않는 주소 등) | 이메일 주소 확인 요청           |
| -43  | SOFT_BOUNCE        | 소프트 바운스        | 일시적인 전송 실패 (사서함 용량 초과 등)   | 일정 시간 후 재시도             |
| -44  | SPAM_REPORTED      | 스팸으로 신고됨      | 사용자가 스팸으로 신고함                   | 콘텐츠 품질 개선 및 재동의 요청 |
| -45  | EMAIL_UNSUBSCRIBED | 수신 거부            | 이메일 내 수신 거부 링크를 통해 구독 취소  | 재구독 유도 및 콘텐츠 가치 설명 |

## 5. SMS 관련 오류 코드 (지원 예정)

| 코드 | 상태명            | 정의                   | 설명                          | 권장 조치                 |
| ---- | ----------------- | ---------------------- | ----------------------------- | ------------------------- |
| -50  | INVALID_PHONE     | 유효하지 않은 전화번호 | 전화번호 형식이 올바르지 않음 | 유효한 전화번호 입력 요청 |
| -51  | SMS_SEND_FAILED   | SMS 전송 실패          | 일반적인 SMS 전송 오류        | SMS 서비스 상태 확인      |
| -52  | NUMBER_NOT_EXIST  | 번호 없음              | 존재하지 않는 전화번호        | 전화번호 확인 요청        |
| -53  | NETWORK_ERROR     | 네트워크 오류          | 통신사 네트워크 오류          | 나중에 재시도             |
| -54  | SMS_BLOCKED       | 차단됨                 | 사용자가 수신을 차단함        | 다른 채널 사용 고려       |
| -55  | SENDER_RESTRICTED | 발신 번호 제한         | 발신 번호에 대한 제한         | 발신 번호 등록 상태 확인  |

## 6. 카카오 알림톡 관련 오류 코드 (지원 예정)

| 코드 | 상태명                | 정의              | 설명                                | 권장 조치             |
| ---- | --------------------- | ----------------- | ----------------------------------- | --------------------- |
| -60  | KAKAO_NOT_USER        | 카카오톡 미사용자 | 카카오톡을 사용하지 않는 사용자     | 대체 메시지 채널 사용 |
| -61  | KAKAO_BLOCKED         | 알림톡 차단       | 사용자가 알림톡 수신을 차단함       | 다른 채널 사용 고려   |
| -62  | KAKAO_NOT_FRIEND      | 친구 추가 안됨    | 비즈니스 계정 친구 추가가 안된 상태 | 친구 추가 유도        |
| -63  | TEMPLATE_NOT_APPROVED | 템플릿 미승인     | 알림톡 템플릿이 승인되지 않음       | 템플릿 승인 재신청    |
| -64  | SEND_LIMIT_EXCEEDED   | 발송 한도 초과    | 일일 발송 한도 초과                 | 다음날까지 대기       |
| -65  | CHANNEL_ERROR         | 채널 오류         | 카카오 비즈니스 채널 오류           | 채널 설정 확인        |

## 7. 인앱 메시지 관련 오류 코드 (지원 예정)

| 코드 | 상태명               | 정의                 | 설명                                          | 권장 조치             |
| ---- | -------------------- | -------------------- | --------------------------------------------- | --------------------- |
| -70  | APP_VERSION_MISMATCH | 앱 버전 불일치       | 지원되지 않는 앱 버전                         | 앱 업데이트 권장      |
| -71  | INAPP_DISABLED       | 사용자 설정 비활성화 | 사용자가 앱 설정에서 인앱 메시지를 비활성화함 | 인앱 메시지 설정 안내 |
| -72  | TRIGGER_MISMATCH     | 표시 조건 불일치     | 표시 조건(트리거)에 부합하지 않음             | 트리거 조건 재설정    |
| -73  | STORAGE_INSUFFICIENT | 기기 저장공간 부족   | 인앱 메시지 에셋을 저장할 공간 부족           | 저장공간 확보 안내    |
| -74  | SDK_INIT_FAILED      | SDK 초기화 실패      | 인앱 메시지 SDK 초기화 오류                   | 앱 재시작 권장        |

## 8. 구독 상태 확인 및 관리

### 8.1 구독 상태 확인 방법

```elixir
# 활성 구독인지 확인
def is_active_subscription?(subscription) do
  subscription.subscription_status > 0
end

# 오류 상태인지 확인
def has_error?(subscription) do
  subscription.subscription_status < -2 and
  subscription.subscription_status != -31 and
  subscription.subscription_status != -99
end

# 오류 종류 확인
def get_error_category(subscription) do
  cond do
    subscription.subscription_status >= -24 and subscription.subscription_status <= -3 -> :push_error
    subscription.subscription_status >= -49 and subscription.subscription_status <= -40 -> :email_error
    subscription.subscription_status >= -59 and subscription.subscription_status <= -50 -> :sms_error
    subscription.subscription_status >= -69 and subscription.subscription_status <= -60 -> :kakao_error
    subscription.subscription_status >= -79 and subscription.subscription_status <= -70 -> :inapp_error
    true -> :other
  end
end
```

### 8.2 상태 전이 규칙

- 구독 상태는 일반적으로 높은 값에서 낮은 값으로 전이됩니다 (예: 1 → -2).
- 오류 상태(-3 ~ -79)는 오류 해결 시 다시 활성 상태(1 이상)로 복구될 수 있습니다.
- 사용자가 명시적으로 구독 취소한 경우(-2)는 사용자 동의 없이 활성 상태로 변경할 수 없습니다.
- API를 통한 비활성화(-31)는 API를 통해 다시 활성화할 수 있습니다.

## 9. 데이터베이스 스키마에서의 표현

```elixir
defmodule AutomataSignal.Resources.Subscription do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [
      AshArchival.Resource,
      AshCloak.Resource
    ]

  attributes do
    # ... 다른 속성들 ...

    # 구독 상태
    attribute :subscription_status, :integer, default: 0
    attribute :subscribed_at, :utc_datetime
    attribute :unsubscribed_at, :utc_datetime
  end

  calculations do
    calculate :is_subscribed, :boolean, expr: expr(subscription_status > 0)
    calculate :is_unsubscribed, :boolean, expr: expr(subscription_status == -2 or subscription_status == -31)
    calculate :has_error, :boolean, expr: expr(subscription_status < -2 and subscription_status != -31 and subscription_status != -99)
    calculate :error_code_range, :string, expr: expr(
      cond do
        subscription_status >= -24 and subscription_status <= -3 -> "push_error"
        subscription_status >= -49 and subscription_status <= -40 -> "email_error"
        subscription_status >= -59 and subscription_status <= -50 -> "sms_error"
        subscription_status >= -69 and subscription_status <= -60 -> "kakao_error"
        subscription_status >= -79 and subscription_status <= -70 -> "in_app_error"
        true -> "other"
      end
    )
  end

  # ... 관계 및 기타 정의 ...
end
```

## 10. 채널별 오류 코드 매핑

다음 테이블은 외부 서비스에서 반환하는 오류 코드를 내부 구독 상태 코드로 매핑하는 방법을 보여줍니다:

### 10.1 FCM 오류 코드 매핑

| FCM 오류             | 내부 코드 | 설명                         |
| -------------------- | --------- | ---------------------------- |
| UNREGISTERED         | -10       | 토큰이 더 이상 유효하지 않음 |
| SENDER_ID_MISMATCH   | -6        | 발신자 ID 불일치             |
| MISSING_REGISTRATION | -3        | 등록 토큰 누락               |
| INVALID_REGISTRATION | -4        | 유효하지 않은 등록 토큰      |
| ...                  | ...       | ...                          |

### 10.2 APNS 오류 코드 매핑

| APNS 오류              | 내부 코드 | 설명                       |
| ---------------------- | --------- | -------------------------- |
| BadDeviceToken         | -10       | 유효하지 않은 기기 토큰    |
| DeviceTokenNotForTopic | -14       | 토픽에 맞지 않는 기기 토큰 |
| Unregistered           | -10       | 등록되지 않은 기기         |
| ...                    | ...       | ...                        |

---

// File: automata-signal/6-planning/PLAN-001-requirements

# [PLAN-001] 요구사항

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 관련 문서

- [DESIGN-001] 아키텍처 개요
- [SEQ-001] 초기화 시퀀스
- [SEQ-002] 메시지 처리 시퀀스
- [REF-002] 상태 코드

## 요약

본 문서는 Automata-Signal 시스템의 기능 및 비기능 요구사항을 정의합니다. 제품의 목적, 핵심 기능, 성능 특성, 확장성 및 호환성 요구사항을 포함합니다.

## 대상 독자

- 제품 관리자
- 개발팀
- QA 팀
- 이해관계자

## 1. 제품 개요

### 1.1 배경 및 목적

모바일 애플리케이션과 웹 서비스의 성장으로 사용자 참여를 유도하는 효과적인 메시징 시스템의 필요성이 증가하고 있습니다. 기존 메시징 서비스들은 확장성, 안정성, 그리고 다양한 플랫폼 및 채널 지원에 제한이 있어, 글로벌 규모의 고성능 통합 메시징 시스템 개발이 요구되었습니다.

Automata-Signal은 다양한 메시징 채널을 통합하여 효율적인 사용자 참여를 촉진하고, 개인화된 메시지 전달을 가능하게 하는 확장 가능한 메시징 플랫폼입니다.

### 1.2 주요 목표

- 확장성 있는 멀티채널 메시징 플랫폼 구축
- 메시지 상태 추적을 통한 상세한 참여 분석
- 여러 플랫폼 및 디바이스에 대한 통합 지원
- 글로벌 규모의 고성능 메시지 처리
- 안정적이고 보안이 강화된 메시징 인프라 제공

## 2. 기능 요구사항

### 2.1 멀티채널 메시징

#### [FR-101] 푸시 알림 지원

- **우선순위**: 필수
- **설명**: iOS 및 Android 플랫폼에 푸시 알림 전송 지원
- **세부사항**:
  - Apple Push Notification Service(APNS)와 Firebase Cloud Messaging(FCM) 통합
  - 디바이스 토큰 관리 및 자동 갱신
  - 알림 배지, 사운드, 액션 지원
  - 포그라운드/백그라운드 알림 처리

#### [FR-102] 이메일 채널 지원 (지원 예정)

- **우선순위**: 보통
- **설명**: 이메일을 통한 메시지 전송 지원
- **세부사항**:
  - HTML 및 텍스트 이메일 템플릿
  - 이메일 열람 및 링크 클릭 추적
  - 바운스 및 스팸 신고 처리
  - 다국어 지원

#### [FR-103] SMS 채널 지원 (지원 예정)

- **우선순위**: 보통
- **설명**: SMS를 통한 메시지 전송 지원
- **세부사항**:
  - 국제 SMS 게이트웨이 통합
  - 양방향 SMS 지원
  - 전송 상태 추적
  - 단문 링크 추적

#### [FR-104] 카카오 알림톡 지원 (지원 예정)

- **우선순위**: 보통
- **설명**: 카카오 알림톡을 통한 메시지 전송 지원
- **세부사항**:
  - 카카오 비즈니스 API 통합
  - 승인된 알림톡 템플릿 기반 메시지
  - 버튼 액션 및 리치 메시지 지원
  - 대체 SMS 발송 자동화

#### [FR-105] 인앱 메시지 지원 (지원 예정)

- **우선순위**: 낮음
- **설명**: 앱 내에서 직접 메시지를 표시하는 기능
- **세부사항**:
  - 다양한 레이아웃 템플릿 (배너, 팝업, 전체화면)
  - 트리거 기반 표시 규칙
  - 사용자 상호작용 추적
  - 오프라인 메시지 지원

### 2.2 메시지 관리

#### [FR-201] 메시지 상태 추적

- **우선순위**: 필수
- **설명**: 메시지의 전체 라이프사이클 상태 추적
- **세부사항**:
  - 전송, 도달, 열람 상태 추적
  - 상태별 타임스탬프 기록
  - 채널별 상태 추적 차이 수용
  - 실패 사유 기록 및 분류

#### [FR-202] 템플릿 관리

- **우선순위**: 필수
- **설명**: 재사용 가능한 메시지 템플릿 관리
- **세부사항**:
  - 채널별 템플릿 지원
  - 변수 치환 기능
  - 버전 관리
  - 다국어 지원

#### [FR-203] 배치 처리 및 스케줄링

- **우선순위**: 필수
- **설명**: 대량 메시지의 효율적인 처리 및 스케줄링
- **세부사항**:
  - 특정 시간에 메시지 전송 예약
  - 시간대별 최적 전송 시간 자동 선택
  - 과부하 방지를 위한 비율 제한
  - 우선순위 기반 메시지 처리

#### [FR-204] 대량 메시지 캠페인

- **우선순위**: 보통
- **설명**: 타겟팅된 대규모 메시지 캠페인 관리
- **세부사항**:
  - 사용자 세그먼트 기반 타겟팅
  - 캠페인 성과 분석
  - A/B 테스트 (지원 예정)
  - 캠페인 예약 및 반복 설정

### 2.3 구독 관리

#### [FR-301] 채널별 구독 관리

- **우선순위**: 필수
- **설명**: 사용자의 채널별 구독 상태 관리
- **세부사항**:
  - 채널별 옵트인/옵트아웃 처리
  - 구독 상태 코드 체계
  - 구독 이력 추적
  - 채널별 구독 선호도 관리

#### [FR-302] 태그 기반 세그먼테이션

- **우선순위**: 보통
- **설명**: 태그를 사용한 구독 세그먼테이션
- **세부사항**:
  - 키-값 형태의 태그 저장
  - 태그 기반 타겟팅 쿼리
  - 자동 태그 지정 규칙
  - 태그 추가/제거 API

### 2.4 SDK 및 클라이언트

#### [FR-401] 통합 SDK 제공

- **우선순위**: 필수
- **설명**: 클라이언트 앱에서 사용할 통합 SDK 제공
- **세부사항**:
  - 크로스 플랫폼 지원 (Flutter)
  - 사용자 식별 및 구독 관리
  - 메시지 수신 및 상호작용 처리
  - 인앱 메시지 표시 컴포넌트 (지원 예정)

#### [FR-402] 자동 토큰 관리

- **우선순위**: 필수
- **설명**: 푸시 알림 토큰의 자동 등록 및 갱신
- **세부사항**:
  - 토큰 변경 감지 및 자동 업데이트
  - 토큰의 로컬 캐싱
  - 토큰 등록 실패 시 재시도 로직
  - 디바이스 정보 수집 및 전송

#### [FR-403] 사용자 식별 기능

- **우선순위**: 필수
- **설명**: 앱의 사용자 ID와 구독 정보 연결
- **세부사항**:
  - 로그인/로그아웃 처리
  - 익명 상태에서 식별 상태로 전환
  - 여러 디바이스에서 동일 사용자 관리
  - 사용자 ID 영구 삭제 지원

### 2.5 관리 및 모니터링

#### [FR-501] 관리자 대시보드 (지원 예정)

- **우선순위**: 낮음
- **설명**: 시스템 관리 및 모니터링을 위한 웹 대시보드
- **세부사항**:
  - 메시지 통계 및 성과 지표
  - 캠페인 관리 인터페이스
  - 구독 관리 및 검색
  - 시스템 상태 모니터링

#### [FR-502] 분석 및 보고서

- **우선순위**: 보통
- **설명**: 메시지 성과 및 사용자 참여 분석
- **세부사항**:
  - 채널별 성과 비교
  - 전송, 도달, 전환율 지표
  - 시간대별 성과 분석
  - 사용자 세그먼트별 참여도

## 3. 비기능 요구사항

### 3.1 성능 요구사항

#### [NFR-101] 처리량

- **우선순위**: 필수
- **설명**: 시스템은 고부하 상황에서도 안정적인 메시지 처리량을 제공해야 함
- **세부사항**:
  - 초당 10만 건(10초당 100만 건)의 메시지 처리 능력
  - 단일 노드에서 초당 5,000-10,000건 처리
  - 피크 시간 대응을 위한 버스트 처리 지원
  - 메시지 처리 대기열 적용

#### [NFR-102] 응답 시간

- **우선순위**: 필수
- **설명**: API 및 메시지 전송의 응답 시간 요구사항
- **세부사항**:
  - API 응답 시간: 95% 요청에 대해 200ms 이내
  - 메시지 전송 지연(서버에서 외부 서비스까지): 평균 500ms 이내
  - SDK 초기화 시간: 1초 이내
  - 인앱 메시지 표시 지연: 100ms 이내

#### [NFR-103] 동시 사용자

- **우선순위**: 필수
- **설명**: 시스템이 지원해야 하는 동시 사용자 수
- **세부사항**:
  - 동시 활성 사용자: 100만 이상
  - 동시 연결: 5만 이상
  - 사용자당 평균 구독 수: 3개 가정
  - 일일 활성 사용자: 500만 이상

### 3.2 확장성 요구사항

#### [NFR-201] 수평적 확장

- **우선순위**: 필수
- **설명**: 트래픽 증가에 따른 수평적 확장 지원
- **세부사항**:
  - 무중단 노드 추가/제거
  - 자동 노드 발견 및 클러스터링
  - 노드 간 작업 분배
  - 글로벌 분산 배포 지원

#### [NFR-202] 데이터 확장성

- **우선순위**: 필수
- **설명**: 데이터 볼륨 증가에 따른 확장성
- **세부사항**:
  - 월간 10억 건 이상의 메시지 처리
  - 앱당 최대 사용자 수: 1,000만
  - 효율적인 데이터 아카이빙
  - 데이터베이스 샤딩 지원

#### [NFR-203] 채널 확장성

- **우선순위**: 보통
- **설명**: 새로운 메시징 채널 추가 용이성
- **세부사항**:
  - 모듈화된 어댑터 패턴 적용
  - 채널별 구현 독립성
  - 최소한의 코드 변경으로 채널 추가
  - 채널별 기능 차이 수용

### 3.3 가용성 및 안정성

#### [NFR-301] 가용성

- **우선순위**: 필수
- **설명**: 시스템의 가용성 목표
- **세부사항**:
  - 99.95% 이상의 서비스 가용성
  - 지역 장애에도 서비스 유지
  - 무중단 배포 및 업그레이드
  - 자동 복구 메커니즘

#### [NFR-302] 데이터 내구성

- **우선순위**: 필수
- **설명**: 데이터 손실 방지 및 복구 요구사항
- **세부사항**:
  - 메시지 데이터 0% 손실 목표
  - 데이터베이스 복제 및 백업
  - 트랜잭션 로깅 및 재생
  - 최대 15분 복구 시간(RTO)

#### [NFR-303] 장애 격리

- **우선순위**: 보통
- **설명**: 부분 장애가 전체 시스템에 미치는 영향 최소화
- **세부사항**:
  - 채널별 격리
  - 앱별 할당량 분리
  - 회로 차단기 패턴 적용
  - 우아한 성능 저하

### 3.4 보안 요구사항

#### [NFR-401] 데이터 보안

- **우선순위**: 필수
- **설명**: 민감한 데이터 보호 요구사항
- **세부사항**:
  - 토큰 및 개인 식별 정보 암호화
  - 저장 및 전송 중 데이터 암호화
  - 키 관리 시스템
  - 데이터 접근 제어 및 감사

#### [NFR-402] 인증 및 권한

- **우선순위**: 필수
- **설명**: 시스템 접근 및 API 인증 요구사항
- **세부사항**:
  - API 키 기반 인증
  - 앱별 권한 범위 설정
  - 세션 관리 및 토큰 만료
  - 관리자 접근 제어

#### [NFR-403] 컴플라이언스

- **우선순위**: 보통
- **설명**: 규제 및 법적 요구사항 준수
- **세부사항**:
  - GDPR 준수
  - 개인정보 처리 방침
  - 데이터 보존 정책
  - CCPA 및 기타 지역 규제 준수

### 3.5 운영 요구사항

#### [NFR-501] 모니터링 및 알림

- **우선순위**: 필수
- **설명**: 시스템 상태 모니터링 및 경고
- **세부사항**:
  - 주요 성능 지표(KPI) 모니터링
  - 이상 탐지 및 알림
  - 로그 집계 및 분석
  - 상태 대시보드

#### [NFR-502] 배포 및 관리

- **우선순위**: 필수
- **설명**: 시스템 배포 및 관리 요구사항
- **세부사항**:
  - fly.io 기반 글로벌 분산 배포
  - 자동화된 CI/CD 파이프라인
  - 점진적 롤아웃 및 롤백
  - 구성 관리 및 환경 분리

## 4. 기술적 제약사항

### 4.1 기술 스택 제약

- **백엔드**: Elixir, Phoenix, Ash Framework
- **데이터베이스**: PostgreSQL
- **작업 큐**: Oban(ash_oban)
- **클라이언트**: Flutter
- **배포 환경**: fly.io

### 4.2 외부 의존성

- **Apple Push Notification Service(APNS)**: iOS 푸시 알림
- **Firebase Cloud Messaging(FCM)**: Android 푸시 알림
- **AWS SES/SMTP 서버**: 이메일 전송 (지원 예정)
- **SMS 게이트웨이**: SMS 전송 (지원 예정)
- **카카오 비즈니스 API**: 알림톡 전송 (지원 예정)

### 4.3 호환성 요구사항

- **iOS 지원**: iOS 14 이상
- **Android 지원**: Android 8.0 (API 레벨 26) 이상
- **웹 푸시 지원**: 최신 Chrome, Firefox, Safari (지원 예정)

## 5. 구현 우선순위 및 로드맵

### 5.1 Phase 1 (초기 출시)

- [FR-101] 푸시 알림 지원 (iOS/Android)
- [FR-201] 메시지 상태 추적
- [FR-301] 채널별 구독 관리
- [FR-401] 통합 SDK 제공 (Flutter)
- [FR-402] 자동 토큰 관리
- [FR-403] 사용자 식별 기능

### 5.2 Phase 2 (기능 확장)

- [FR-202] 템플릿 관리
- [FR-203] 배치 처리 및 스케줄링
- [FR-204] 대량 메시지 캠페인
- [FR-302] 태그 기반 세그먼테이션
- [FR-502] 분석 및 보고서

### 5.3 Phase 3 (추가 채널)

- [FR-102] 이메일 채널 지원
- [FR-103] SMS 채널 지원
- [FR-104] 카카오 알림톡 지원

### 5.4 Phase 4 (고급 기능)

- [FR-105] 인앱 메시지 지원
- [FR-501] 관리자 대시보드
- A/B 테스트 지원
- 사용자 여정 관리

---

// File: automata-signal/README

# [APP-001] Automata-Signal

| 버전 | 날짜       | 변경 내용      |
| ---- | ---------- | -------------- |
| 1.0  | 2025-04-02 | 최초 문서 작성 |

## 개요

Automata-Signal은 확장성 있는 멀티채널 메시징 플랫폼으로, 다양한 메시징 채널을 통합하여 사용자 참여를 증대시키고 효과적인 메시지 전달을 가능하게 합니다. 글로벌 규모의 고성능 메시징 서비스를 제공하기 위해 설계되었습니다.

### 지원 채널

- **푸시 알림** (iOS, Android) - 현재 지원
- **이메일** - 지원 예정
- **SMS** - 지원 예정
- **카카오 알림톡** - 지원 예정
- **인앱 메시지** - 지원 예정

### 주요 특징

- 멀티채널 통합 메시징
- 메시지 상태 추적 (발송→도달→오픈)
- 대량 메시지 캠페인 및 스케줄링
- 사용자 및 채널별 구독 관리
- 템플릿 기반 개인화 메시지
- 분산 아키텍처 기반 고성능 처리
- 통합 SDK 제공

## 기술 스택

- **백엔드**: Elixir, Phoenix, Ash Framework
- **데이터베이스**: PostgreSQL
- **작업 큐**: Oban(ash_oban)
- **푸시 서비스**: Pigeon(APNS/FCM)
- **클라이언트**: Flutter
- **배포**: fly.io(글로벌 분산 배포)

## 문서 가이드

### 개발자 가이드

- [[GUIDE-001] 시작하기](1-guides/GUIDE-001-getting-started.md) - 프로젝트 설정 및 초기화 과정
- [[GUIDE-002] 프로젝트 구조](1-guides/GUIDE-002-project-structure.md) - 프로젝트 구조 및 구성 요소 설명
- [[GUIDE-003] 개발 워크플로우](1-guides/GUIDE-003-development-workflow.md) - 개발, 테스트, 배포 과정 설명
- [[GUIDE-004] 코딩 표준](1-guides/GUIDE-004-coding-standards.md) - 개발 표준 및 코딩 규칙

### 시스템 설계

- [[DESIGN-001] 아키텍처 개요](2-designs/DESIGN-001-architecture-overview.md) - 시스템 아키텍처 전체 개요
- [[DESIGN-002] 시스템 아키텍처](2-designs/DESIGN-002-system-architecture.md) - 상세 시스템 아키텍처
- [[DESIGN-003] 데이터 모델](2-designs/DESIGN-003-data-model.md) - 데이터베이스 모델 및 스키마
- [[DESIGN-004] 배포 구조](2-designs/DESIGN-004-deployment.md) - 분산 배포 구조

### 컴포넌트

- [[COMP-001] 템플릿 엔진](3-components/COMP-001-template-engine.md) - 템플릿 엔진 설계 및 구현
- [[COMP-002] 어댑터 시스템](3-components/COMP-002-adapters.md) - 채널 어댑터 시스템
- [[COMP-003] 메시징 시스템](3-components/COMP-003-messaging.md) - 멀티채널 메시징 시스템

### 시퀀스

- [[SEQ-001] 초기화 시퀀스](4-sequences/SEQ-001-initialization.md) - SDK 초기화 및 사용자 식별
- [[SEQ-002] 메시지 처리 시퀀스](4-sequences/SEQ-002-message-processing.md) - 메시지 전송 및 처리 과정
- [[SEQ-003] 라이프사이클 시퀀스](4-sequences/SEQ-003-lifecycle.md) - 메시지 상태 전이 흐름
- [[SEQ-004] 캠페인 관리 시퀀스](4-sequences/SEQ-004-campaign-management.md) - 캠페인 생성 및 처리 흐름

### 참조 자료

- [[REF-001] API 참조](5-references/REF-001-api.md) - API 명세 및 사용법
- [[REF-002] 상태 코드](5-references/REF-002-status-codes.md) - 구독 및 메시지 상태 코드
- [[REF-003] 오류 코드](5-references/REF-003-error-codes.md) - 채널별 오류 코드 사전
- [[REF-004] 용어집](5-references/REF-004-glossary.md) - 핵심 용어 정의

### 프로젝트 계획

- [[PLAN-001] 요구사항](6-planning/PLAN-001-requirements.md) - 시스템 기능 및 비기능 요구사항
- [[PLAN-002] 로드맵](6-planning/PLAN-002-roadmap.md) - 개발 일정 및 마일스톤
- [[PLAN-003] 이슈 추적](6-planning/PLAN-003-issues.md) - 현재 이슈 및 버그 목록

---

// File: automata-signal/tech-spec

# Automata-Signal: 기술 명세서

## 1. 서론

### 목적

본 문서는 Automata-Signal 시스템의 기술적 설계와 구현 계획을 상세히 기술하며, 개발팀, 이해관계자 및 시스템 운영자에게 필요한 기술적 정보를 제공합니다.

### 배경

모바일 애플리케이션과 웹 서비스의 성장으로 사용자 참여를 유도하는 효과적인 메시징 시스템의 필요성이 증가하고 있습니다. 기존 메시징 서비스들은 확장성, 안정성, 그리고 다양한 플랫폼 및 채널 지원에 제한이 있어, 글로벌 규모의 고성능 통합 메시징 시스템 개발이 요구되었습니다.

## 2. 제품 개요

### 기능적 요구사항

- **멀티채널 메시징 지원**:
  - 푸시 알림 (iOS, Android)
  - 이메일 (지원 예정)
  - SMS (지원 예정)
  - 카카오 알림톡 (지원 예정)
  - 인앱 메시지 (지원 예정)
- 메시지 상태 관리 및 추적 (발송→도달→오픈)
- 대량 메시지 배치 처리 및 스케줄링
- 사용자 및 채널별 구독 관리
- 메시지 템플릿 관리와 개인화 (채널별 최적화)
- 메시지 캠페인 관리 및 타겟팅
- 통합 SDK 제공 (구독 관리, 사용자 식별, 메시지 처리)
- 멀티채널 통합 분석 및 보고서 생성

### 비기능적 요구사항

- **성능**: 초당 10만 건(10초당 100만 건)의 메시지 처리 능력
- **확장성**: 사용자, 채널 및 메시지 볼륨 증가에 유연한 대응
- **안정성**: fly.io 기반 글로벌 분산 배포로 99.95% 이상의 가용성
- **보안**: 민감한 사용자 데이터 및 인증 토큰 암호화
- **유지보수성**: Umbrella 구조와 어댑터 패턴을 통한 모듈성 및 확장성 보장
- **감사 추적**: 모든 메시지 상태 변경 기록 및 추적
- **채널 독립성**: 새로운 메시징 채널을 쉽게 추가할 수 있는 확장 가능한 구조

## 3. 시스템 아키텍처

### 3.1 전체 아키텍처 개요

```mermaid
flowchart TB
    subgraph Client ["클라이언트"]
        C1[클라이언트 애플리케이션<br>Flutter]
        SDK[Automata SDK<br>구독 등록/사용자 식별]
    end

    subgraph Backend ["Automata Umbrella"]
        subgraph Signal ["automata_signal"]
            API[API 게이트웨이<br>Phoenix]
            Elixir[분산 메시지 처리 클러스터<br>Elixir/Ash]
            TemplateEngine[템플릿 렌더링 엔진]
            CampaignManager[캠페인 관리자]

            subgraph Adapters ["채널 어댑터"]
                PushClient[푸시 클라이언트<br>Pigeon]
                EmailClient[이메일 클라이언트<br>지원 예정]
                SMSClient[SMS 클라이언트<br>지원 예정]
                KakaoClient[카카오톡 클라이언트<br>지원 예정]
                InAppClient[인앱 메시지 클라이언트<br>지원 예정]
            end
        end
        subgraph Other ["기타 앱 모듈"]
            Analytics[automata_analytics]
            Admin[automata_admin]
        end
        DB[(PostgreSQL<br>작업 큐/상태 저장)]
    end

    subgraph External ["외부 시스템"]
        APNS[Apple Push<br>Notification Service]
        FCM[Firebase Cloud<br>Messaging]
        SMTP[SMTP 서버/AWS SES<br>지원 예정]
        SMSGateway[SMS 게이트웨이<br>지원 예정]
        KakaoAPI[카카오 알림톡 API<br>지원 예정]

        UserDevice[사용자 기기<br>iOS/Android]
        UserEmail[사용자 이메일]
        UserPhone[사용자 휴대폰]
        UserKakao[사용자 카카오톡]
        InAppSDK[인앱 메시지 SDK<br>지원 예정]
    end

    C1 <--"SDK 초기화/로그인"--> SDK
    SDK <--"API 요청"--> API
    C1 <--"API 요청"--> API
    API --> Elixir
    Elixir <--"작업 큐/상태 저장"--> DB

    Elixir --"푸시 알림 요청"--> PushClient
    Elixir --"이메일 요청"--> EmailClient
    Elixir --"SMS 요청"--> SMSClient
    Elixir --"알림톡 요청"--> KakaoClient
    Elixir --"인앱 메시지 요청"--> InAppClient

    PushClient --"iOS 푸시 알림"--> APNS
    PushClient --"Android 푸시 알림"--> FCM
    EmailClient -.->|지원 예정| SMTP
    SMSClient -.->|지원 예정| SMSGateway
    KakaoClient -.->|지원 예정| KakaoAPI
    InAppClient -.->|지원 예정| InAppSDK

    APNS --"iOS 알림 전달"--> UserDevice
    FCM --"Android 알림 전달"--> UserDevice
    SMTP -.->|지원 예정| UserEmail
    SMSGateway -.->|지원 예정| UserPhone
    KakaoAPI -.->|지원 예정| UserKakao
    InAppSDK -.->|지원 예정| C1

    UserDevice --"상태 피드백(수신/열람)"--> C1
    C1 --"상태 업데이트"--> API
    API --"상태 기록"--> DB

    CampaignManager --> TemplateEngine
    CampaignManager --> Elixir
    Elixir --> Analytics
    Analytics --> DB
    Admin --> DB

```

Automata-Signal은 Elixir Umbrella 프로젝트 구조를 기반으로 구축된 분산 시스템으로, 다음과 같은 주요 구성 요소로 이루어져 있습니다:

1. **API 게이트웨이**: Phoenix Framework 기반으로 REST API를 제공합니다.
2. **분산 메시지 처리 클러스터**: Elixir/OTP, libcluster, GenServer를 활용한 고성능 메시지 처리 시스템입니다.
3. **채널 어댑터**:
   - 푸시 클라이언트: Pigeon 라이브러리를 통해 iOS(APNS)와 Android(FCM) 플랫폼에 알림 전송
   - 이메일 클라이언트: 향후 구현 예정
   - SMS 클라이언트: 향후 구현 예정
   - 카카오 알림톡 클라이언트: 향후 구현 예정
   - 인앱 메시지 클라이언트: 향후 구현 예정
4. **템플릿 렌더링 엔진**: 메시지 템플릿 및 변수를 처리하여 개인화된 메시지를 생성합니다.
5. **캠페인 관리자**: 대규모 메시지 캠페인 생성, 스케줄링 및 타겟팅을 처리합니다.
6. **작업 큐 및 상태 저장소**: PostgreSQL, ash_oban, ash_state_machine을 활용한 작업 관리 및 상태 추적 시스템입니다.
7. **SDK**: 구독 등록, 토큰 관리, 사용자 식별 등의 기능을 제공하는 클라이언트 라이브러리입니다.
8. **분석 모듈**: 메시지 상태 및 사용자 참여 데이터 분석을 위한 컴포넌트입니다.
9. **관리자 모듈**: 시스템 관리 및 모니터링을 위한 인터페이스입니다.

### 3.2 Elixir 노드 내부 아키텍처

```mermaid
flowchart TB
    subgraph "Automata-Signal 노드"
        Phoenix[Phoenix Endpoint]
        AshAPI[Ash JSON API]

        subgraph "Ash Resources"
            Message[Message<br>ash_state_machine]
            Subscription[Subscription<br>ash_cloak]
            User[User<br>ash_archival]
            SubscriptionEvent[SubscriptionEvent]
            MessageEvent[MessageEvent<br>ash_paper_trail]
            Application[Application]
            MessageQuota[MessageQuota<br>ash_money<br>ash_double_entry]
            MessageTemplate[MessageTemplate]
            MessageCampaign[MessageCampaign]
        end

        Libcluster[libcluster 노드 연결]

        Oban[ash_oban 워커]
        Service[Message Service]
        GenServer[분산 GenServer]
        TemplateService[Template Service]
        CampaignService[Campaign Service]
        BillingService[Billing Service<br>ash_money]

        subgraph "Channel Adapters"
            PushAdapter[Push Adapter]
            EmailAdapter[Email Adapter<br>지원 예정]
            SMSAdapter[SMS Adapter<br>지원 예정]
            KakaoAdapter[KakaoTalk Adapter<br>지원 예정]
            InAppAdapter[InApp Message Adapter<br>지원 예정]
        end

        subgraph "External Services"
            APNSService[APNS]
            FCMService[FCM]
            EmailService[SMTP/SES<br>지원 예정]
            SMSService[SMS Gateway<br>지원 예정]
            KakaoService[Kakao API<br>지원 예정]
        end

        Phoenix --> AshAPI
        Phoenix --> Oban

        AshAPI --> Message
        AshAPI --> Subscription
        AshAPI --> User
        AshAPI --> SubscriptionEvent
        AshAPI --> MessageEvent
        AshAPI --> Application
        AshAPI --> MessageQuota
        AshAPI --> MessageTemplate
        AshAPI --> MessageCampaign

        Oban --> Service
        Oban --> CampaignService
        Oban --> BillingService

        Message --> Service
        Subscription --> Service
        User --> Service
        MessageQuota --> Service
        MessageQuota --> BillingService
        MessageTemplate --> TemplateService
        MessageCampaign --> CampaignService

        CampaignService --> TemplateService
        CampaignService --> Service
        CampaignService --> BillingService

        Libcluster --> GenServer
        GenServer --> Service

        Service --> PushAdapter
        Service --> EmailAdapter
        Service --> SMSAdapter
        Service --> KakaoAdapter
        Service --> InAppAdapter

        PushAdapter --> APNSService
        PushAdapter --> FCMService
        EmailAdapter -.->|지원 예정| EmailService
        SMSAdapter -.->|지원 예정| SMSService
        KakaoAdapter -.->|지원 예정| KakaoService
    end

```

Elixir 노드 내부에서는 다양한 컴포넌트들이 유기적으로 상호작용하여 메시징 기능을 제공합니다:

1. **Phoenix Endpoint**: 클라이언트 요청을 받아 처리하는 웹 서버 엔드포인트입니다.
2. **Ash JSON API**: Ash Framework 기반의 RESTful API를 제공하며, 리소스에 대한 CRUD 작업을 처리합니다.
3. **Ash Resources**:
   - **Application**: 메시징 서비스를 사용하는 애플리케이션 정보 관리
   - **User**: 사용자 정보 및 외부 ID 매핑 관리 (ash_archival 확장으로 논리적 삭제 지원)
   - **Subscription**: 사용자의 구독 정보 관리 (ash_cloak 확장으로 토큰 암호화)
   - **Message**: 메시지 내용 및 상태 관리 (ash_state_machine 확장으로 상태 전이 관리)
   - **MessageEvent**: 메시지 이벤트 추적 (ash_paper_trail 확장으로 변경 이력 관리)
   - **SubscriptionEvent**: 구독 상태 변경 추적
   - **MessageQuota**: 앱별 할당량 관리 (ash_money 확장으로 과금 관리, ash_double_entry 확장으로 정확한 사용량 추적)
   - **MessageTemplate**: 재사용 가능한 메시지 템플릿 관리
   - **MessageCampaign**: 대량 메시지 발송 캠페인 관리
4. **서비스 컴포넌트**:
   - **Message Service**: 메시지 생성 및 전송 로직 구현
   - **Template Service**: 템플릿 렌더링 및 변수 치환 처리
   - **Campaign Service**: 캠페인 처리 및 대상자 필터링
   - **Billing Service**: 과금 및 할당량 관리 (ash_money 활용)
5. **작업 처리 컴포넌트**:
   - **ash_oban 워커**: 비동기 작업 처리 및 스케줄링
   - **분산 GenServer**: 노드 간 상태 공유 및 작업 분배
6. **채널 어댑터**:
   - **Push Adapter**: iOS/Android 푸시 알림 처리
   - **Email Adapter**: 이메일 메시지 처리 (지원 예정)
   - **SMS Adapter**: SMS 메시지 처리 (지원 예정)
   - **KakaoTalk Adapter**: 카카오 알림톡 처리 (지원 예정)
   - **InApp Message Adapter**: 인앱 메시지 처리 (지원 예정)
7. **노드 연결**:
   - **libcluster**: 자동 노드 발견 및 연결로 분산 클러스터 구성

### 3.3 데이터 모델 아키텍처

```mermaid
erDiagram
    APPLICATION {
        uuid id PK
        string name
        string api_key
        jsonb settings
        datetime created_at
        datetime updated_at
        boolean is_active
    }

    USER {
        uuid id PK
        string external_id
        uuid application_id FK
        datetime created_at
        datetime last_active_at
        boolean is_archived
    }
    %% Note: (external_id, application_id) must be unique

    SUBSCRIPTION {
        uuid id PK
        string token
        enum type
        uuid user_id FK
        uuid application_id FK
        string device_model
        string device_os
        string device_language
        string app_version
        string sdk_version
        string country_code
        integer test_type
        jsonb tags
        integer subscription_status
        datetime subscribed_at
        datetime unsubscribed_at
        datetime last_active_at
        int total_messages_received
        int total_messages_converted
        boolean is_archived
    }

    MESSAGE_TEMPLATE {
        uuid id PK
        uuid application_id FK
        string name
        string title_template
        string body_template
        jsonb data_template
        string description
        datetime created_at
        datetime updated_at
        boolean is_active
        int version
    }

    MESSAGE_CAMPAIGN {
        uuid id PK
        uuid application_id FK
        uuid template_id FK
        string name
        string title
        string body
        jsonb data
        enum campaign_type
        datetime scheduled_at
        datetime created_at
        datetime sent_at
        string created_by
        jsonb targeting_criteria
        int total_recipients
        int successful_count
        int failed_count
        enum status
    }

    MESSAGE {
        uuid id PK
        string title
        string body
        jsonb data
        uuid user_id FK
        uuid subscription_id FK
        uuid application_id FK
        uuid campaign_id FK
        enum status
        enum channel_type
        datetime created_at
        datetime sent_at
        datetime received_at
        datetime converted_at
        datetime failed_at
        string error_reason
        jsonb error_details
        jsonb version_history
    }

    MESSAGE_EVENT {
        uuid id PK
        uuid message_id FK
        enum event_type
        datetime occurred_at
        jsonb metadata
        jsonb version_history
    }

    SUBSCRIPTION_EVENT {
        uuid id PK
        uuid user_id FK
        uuid subscription_id FK
        uuid application_id FK
        enum event_type
        string channel
        string source
        string reason
        datetime occurred_at
    }

    MESSAGE_QUOTA {
        uuid id PK
        uuid application_id FK
        int daily_quota
        int monthly_quota
        int daily_used
        int monthly_used
        datetime reset_date
    }

    APPLICATION ||--o{ USER : "has"
    APPLICATION ||--o{ SUBSCRIPTION : "has"
    APPLICATION ||--o{ MESSAGE : "sends"
    APPLICATION ||--o{ SUBSCRIPTION_EVENT : "has"
    APPLICATION ||--o{ MESSAGE_QUOTA : "has"
    APPLICATION ||--o{ MESSAGE_TEMPLATE : "has"
    APPLICATION ||--o{ MESSAGE_CAMPAIGN : "has"
    USER ||--o{ SUBSCRIPTION : "has"
    USER ||--o{ MESSAGE : "receives"
    SUBSCRIPTION ||--o{ MESSAGE : "receives"
    MESSAGE ||--o{ MESSAGE_EVENT : "generates"
    USER ||--o{ SUBSCRIPTION_EVENT : "has"
    SUBSCRIPTION ||--o{ SUBSCRIPTION_EVENT : "has"
    MESSAGE_TEMPLATE ||--o{ MESSAGE_CAMPAIGN : "used_by"
    MESSAGE_CAMPAIGN ||--o{ MESSAGE : "generates"

```

### 주요 엔티티

1. **Application**: 메시징 서비스를 이용하는 앱 정보 (API 키, 설정 등)
2. **User**: 각 앱의 사용자 정보. `external_id`를 통해 앱 내에서 사용자 식별 (이메일, 이름 등 저장하지 않음)
3. **Subscription**: 사용자의 구독 정보 (푸시 알림, 이메일, SMS, 카카오톡 등)
4. **MessageTemplate**: 재사용 가능한 메시지 형식 템플릿 정의
5. **MessageCampaign**: 대량 메시지 발송을 위한 캠페인 정의
6. **Message**: 개별 사용자의 구독 채널에 전송된 메시지와 상태 정보
7. **MessageEvent**: 메시지 상태 변경 이벤트 기록
8. **SubscriptionEvent**: 구독/구독취소 이벤트 기록
9. **MessageQuota**: 앱별 메시지 할당량 및 사용량 관리

### 주요 데이터 모델 특징

1. **복합 유니크 제약조건**: User 테이블에서 `(external_id, application_id)` 조합은 유니크해야 합니다. 이를 통해 한 앱 내에서 사용자 식별자의 유일성을 보장합니다.
2. **Subscription 메타데이터**: 구독 채널에 대한 상세 정보 저장
   - `type`: 구독 채널 유형 (예: `iOSPush`, `AndroidPush`, `Email`, `SMS`, `KakaoTalk`, `InAppMessage`)
   - `token`: 채널별 식별자 (푸시 토큰, 이메일 주소, 전화번호 등)
   - 디바이스 관련 정보 (푸시 알림 채널인 경우):
     - `device_model`, `device_os`: 디바이스 하드웨어 및 OS 정보
     - `device_language`: 디바이스 설정 언어
     - `app_version`, `sdk_version`: 앱 및 SDK 버전 관리
   - `country_code`: 지역별 분석 및 규제 준수
   - `test_type`: 테스트 환경 설정 (0: Production, 1: Development, 2: Ad-Hoc)
   - `tags`: 유연한 태그 데이터 저장(JSON)
3. **구독 상태 코드 체계**:

```mermaid
flowchart TD
    A[subscription_status] --> B[기본 상태: -2, -31, 0, 1, ...]
    A --> C[푸시 알림 오류: -3 ~ -24]
    A --> D[이메일 오류: -40 ~ -49]
    A --> E[SMS 오류: -50 ~ -59]
    A --> F[카카오톡 오류: -60 ~ -69]
    A --> G[인앱 메시지 오류: -70 ~ -79]

```

### 기본 구독 상태

| 코드   | 정의                  | 설명                                                                               |
| ------ | --------------------- | ---------------------------------------------------------------------------------- |
| 1 이상 | 구독됨                | 해당 채널에서 메시지를 수신할 수 있는 상태. 푸시 알림의 경우 유효한 토큰이 필요함. |
| 0, -99 | 구독된 적 없음        | 초기 상태. 해당 채널에 아직 구독되지 않음.                                         |
| -2     | 구독 취소됨           | 사용자가 직접 구독을 취소한 상태. enabled 속성을 false로 설정할 때 권장되는 값.    |
| -31    | API를 통해 비활성화됨 | REST API를 통해 관리자나 시스템에 의해 비활성화된 경우.                            |
| -98    | 이중 확인 대기 중     | SMS/이메일에서 더블 옵트인을 기다리는 상태.                                        |

### 푸시 알림 관련 오류 코드

| 코드             | 정의                              | 설명                                                   |
| ---------------- | --------------------------------- | ------------------------------------------------------ |
| -3, -5           | Android 지원 라이브러리 오류      | 앱의 Android 지원 라이브러리 추가 또는 업데이트 필요   |
| -4, -8, -11, -12 | Android Google Play 서비스 오류   | Google Play 서비스 라이브러리 업그레이드 필요          |
| -6               | Android 잘못된 프로젝트 번호      | FCMv1 Sender ID가 토큰 원본과 일치하지 않음            |
| -7, -9           | Android 구버전 Google Play 서비스 | 기기의 Google Play 서비스 앱 업데이트 필요             |
| -10              | 구독되지 않음                     | 앱 제거 또는 기기 설정에서 구독 취소됨, 웹 푸시 차단됨 |
| -13              | iOS 푸시 기능 누락                | 필요한 SDK 설정 단계가 누락됨                          |
| -14, -16, -17    | iOS APNS 오류                     | 기기가 APNS 연결에 문제 있음                           |
| -15              | iOS 시뮬레이터 오류               | iOS 16.4+ 시뮬레이터 필요                              |
| -18              | 권한 요청 안됨                    | 구독 권한 요청이 표시된 적 없음                        |
| -19              | 권한 요청 무응답                  | 구독 권한 요청이 표시되었으나 응답하지 않음            |
| -20, -21         | 웹 레코드 임시 상태               | 웹 푸시 권한 철회됨                                    |
| -22              | 수동 구독 취소                    | 사용자가 권한을 철회함                                 |
| -23, -24         | 웹 서비스 워커 오류               | 웹 푸시 관련 오류                                      |

### 이메일 관련 오류 코드 (지원 예정)

| 코드 | 정의                 | 설명                                       |
| ---- | -------------------- | ------------------------------------------ |
| -40  | 유효하지 않은 이메일 | 이메일 형식이 올바르지 않음                |
| -41  | 이메일 전송 실패     | 일반적인 이메일 전송 오류                  |
| -42  | 하드 바운스          | 영구적인 전송 실패 (존재하지 않는 주소 등) |
| -43  | 소프트 바운스        | 일시적인 전송 실패 (사서함 용량 초과 등)   |
| -44  | 스팸으로 신고됨      | 사용자가 스팸으로 신고함                   |
| -45  | 수신 거부            | 이메일 내 수신 거부 링크를 통해 구독 취소  |

### SMS 관련 오류 코드 (지원 예정)

| 코드 | 정의                   | 설명                          |
| ---- | ---------------------- | ----------------------------- |
| -50  | 유효하지 않은 전화번호 | 전화번호 형식이 올바르지 않음 |
| -51  | SMS 전송 실패          | 일반적인 SMS 전송 오류        |
| -52  | 번호 없음              | 존재하지 않는 전화번호        |
| -53  | 네트워크 오류          | 통신사 네트워크 오류          |
| -54  | 차단됨                 | 사용자가 수신을 차단함        |
| -55  | 발신 번호 제한         | 발신 번호에 대한 제한         |

### 카카오 알림톡 관련 오류 코드 (지원 예정)

| 코드 | 정의              | 설명                                |
| ---- | ----------------- | ----------------------------------- |
| -60  | 카카오톡 미사용자 | 카카오톡을 사용하지 않는 사용자     |
| -61  | 알림톡 차단       | 사용자가 알림톡 수신을 차단함       |
| -62  | 친구 추가 안됨    | 비즈니스 계정 친구 추가가 안된 상태 |
| -63  | 템플릿 미승인     | 알림톡 템플릿이 승인되지 않음       |
| -64  | 발송 한도 초과    | 일일 발송 한도 초과                 |
| -65  | 채널 오류         | 카카오 비즈니스 채널 오류           |

### 인앱 메시지 관련 오류 코드 (지원 예정)

| 코드 | 정의                        | 설명                                          |
| ---- | --------------------------- | --------------------------------------------- |
| -70  | 앱 버전 불일치              | 지원되지 않는 앱 버전                         |
| -71  | 사용자 설정에 의한 비활성화 | 사용자가 앱 설정에서 인앱 메시지를 비활성화함 |
| -72  | 표시 조건 불일치            | 표시 조건(트리거)에 부합하지 않음             |
| -73  | 기기 저장공간 부족          | 인앱 메시지 에셋을 저장할 공간 부족           |
| -74  | SDK 초기화 실패             | 인앱 메시지 SDK 초기화 오류                   |

1. **채널별 메시지 형식**: 각 채널 유형에 따라 메시지 형식과 내용이 달라질 수 있음
   - 푸시 알림: 제목, 본문, 액션 데이터
   - 이메일: 제목, HTML 본문, 첨부파일
   - SMS: 단문 메시지
   - 카카오톡: 알림톡 템플릿 ID 및 변수
   - 인앱 메시지: 제목, 본문, 레이아웃 타입, 액션, 표시 규칙
2. **템플릿 기반 메시지**: 템플릿은 고정된 구조에 변수 플레이스홀더를 포함
   - `title_template`, `body_template`: 제목 및 본문에 `{{variable}}` 형태의 변수 포함
   - 예: "안녕하세요 `{{user_name}}`님, `{{event_name}}` 이벤트가 시작됩니다"
   - 채널별 템플릿 지원: 이메일용 HTML 템플릿, 카카오톡용 알림톡 템플릿 등
3. **캠페인-메시지 관계**: 모든 메시지는 개별 발송이거나 캠페인의 일부로 생성됨
   - 개별 메시지: `campaign_id`가 null
   - 캠페인 메시지: 동일한 `campaign_id`를 공유하는 다수의 메시지 인스턴스
4. **메시지 테이블 공유**: 모든 채널(푸시, 이메일, SMS, 카카오 알림톡, 인앱 메시지)의 메시지는 동일한 `MESSAGE` 테이블을 사용하며, `channel_type` 필드로 구분

### Subscription 리소스 예시

```elixir
defmodule AutomataSignal.Resources.Subscription do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [
      AshArchival.Resource,
      AshCloak.Resource
    ]

  attributes do
    uuid_primary_key :id
    attribute :token, :string, sensitive?: true
    attribute :type, :atom do
      constraints [one_of: [:iOSPush, :AndroidPush, :Email, :SMS, :KakaoTalk, :InAppMessage]]
    end
    attribute :user_id, :uuid
    attribute :application_id, :uuid

    # 디바이스 메타데이터 (푸시 알림 구독인 경우)
    attribute :device_model, :string
    attribute :device_os, :string
    attribute :device_language, :string
    attribute :app_version, :string
    attribute :sdk_version, :string
    attribute :country_code, :string
    attribute :test_type, :integer, default: 0
    attribute :tags, :map, default: %{}

    # 구독 상태
    attribute :subscription_status, :integer, default: 0
    attribute :subscribed_at, :utc_datetime
    attribute :unsubscribed_at, :utc_datetime

    # 통계 지표
    attribute :last_active_at, :utc_datetime
    attribute :total_messages_received, :integer, default: 0
    attribute :total_messages_converted, :integer, default: 0
  end

  encrypted_attributes do
    attribute :token
  end

  archival do
    archive_attribute :is_archived
    archive_timestamp_attribute :archived_at
  end

  # 구독 상태 코드 관련 함수
  calculations do
    calculate :is_push_channel, :boolean, expr: expr(type in [:iOSPush, :AndroidPush])
    calculate :is_messaging_channel, :boolean, expr: expr(type in [:Email, :SMS, :KakaoTalk])
    calculate :is_in_app_channel, :boolean, expr: expr(type == :InAppMessage)

    calculate :is_subscribed, :boolean, expr: expr(subscription_status > 0)
    calculate :is_unsubscribed, :boolean, expr: expr(subscription_status == -2 or subscription_status == -31)
    calculate :has_error, :boolean, expr: expr(subscription_status < -2 and subscription_status != -31 and subscription_status != -99)
    calculate :error_code_range, :string, expr: expr(
      cond do
        subscription_status >= -24 and subscription_status <= -3 -> "push_error"
        subscription_status >= -49 and subscription_status <= -40 -> "email_error"
        subscription_status >= -59 and subscription_status <= -50 -> "sms_error"
        subscription_status >= -69 and subscription_status <= -60 -> "kakao_error"
        subscription_status >= -79 and subscription_status <= -70 -> "in_app_error"
        true -> "other"
      end
    )
  end

  relationships do
    belongs_to :user, AutomataSignal.Resources.User
    belongs_to :application, AutomataSignal.Resources.Application
    has_many :messages, AutomataSignal.Resources.Message,
      destination_field: :subscription_id
    has_many :subscription_events, AutomataSignal.Resources.SubscriptionEvent,
      destination_field: :subscription_id
  end

  # ... 추가 액션 및 기타 설정 ...
end

```

### Message 리소스 예시

```elixir
defmodule AutomataSignal.Resources.Message do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [AshStateMachine.Resource]

  attributes do
    uuid_primary_key :id
    attribute :title, :string
    attribute :body, :string
    attribute :data, :map, default: %{}
    attribute :user_id, :uuid
    attribute :subscription_id, :uuid
    attribute :application_id, :uuid
    attribute :campaign_id, :uuid, allow_nil?: true

    attribute :status, :atom do
      constraints [one_of: [:pending, :successful, :failed, :errored, :received, :converted]]
      default :pending
    end

    attribute :channel_type, :atom do
      constraints [one_of: [:push, :email, :sms, :kakao_talk, :in_app]]
    end

    timestamps()
    attribute :sent_at, :utc_datetime
    attribute :received_at, :utc_datetime
    attribute :converted_at, :utc_datetime
    attribute :failed_at, :utc_datetime

    attribute :error_reason, :string
    attribute :error_details, :map, default: %{}
    attribute :version_history, :map, default: %{}
  end

  state_machine do
    field :status

    initial_states [:pending]

    transitions do
      transition :send, from: [:pending], to: :successful
      transition :fail, from: [:pending, :successful], to: :failed
      transition :error, from: [:pending], to: :errored
      transition :retry, from: [:errored], to: :pending
      transition :receive, from: [:successful], to: :received
      transition :convert, from: [:received], to: :converted
    end

    on_transition :send do
      set_attribute :sent_at, &DateTime.utc_now/0
    end

    on_transition :fail do
      set_attribute :failed_at, &DateTime.utc_now/0
    end

    on_transition :receive do
      set_attribute :received_at, &DateTime.utc_now/0
    end

    on_transition :convert do
      set_attribute :converted_at, &DateTime.utc_now/0
    end
  end

  relationships do
    belongs_to :user, AutomataSignal.Resources.User
    belongs_to :subscription, AutomataSignal.Resources.Subscription
    belongs_to :application, AutomataSignal.Resources.Application
    belongs_to :campaign, AutomataSignal.Resources.MessageCampaign, allow_nil?: true
    has_many :events, AutomataSignal.Resources.MessageEvent,
      destination_field: :message_id
  end

  # ... 액션 및 기타 설정 ...
end

```

### MessageQuota 리소스 예시

```elixir
defmodule AutomataSignal.Resources.MessageQuota do
  use Ash.Resource,
    data_layer: Ash.DataLayer.Postgres,
    extensions: [
      AshMoney.Resource,
      AshDoubleEntry.Resource
    ]

  attributes do
    uuid_primary_key :id
    attribute :application_id, :uuid
    attribute :daily_quota, :integer
    attribute :monthly_quota, :integer
    attribute :daily_used, :integer, default: 0
    attribute :monthly_used, :integer, default: 0
    attribute :reset_date, :utc_datetime

    # 과금 관련 필드 (ash_money 사용)
    attribute :unit_price, :money  # 메시지당 단가
    attribute :credit_balance, :money, default: 0  # 남은 크레딧
    attribute :billing_currency, :string, default: "KRW"
  end

  relationships do
    belongs_to :application, AutomataSignal.Resources.Application
  end

  # ash_double_entry 설정
  double_entry do
    # 사용량 계정 정의
    account :daily_usage do
      # 일일 사용량 증가 및 감소
      change_attribute :daily_used
      credit_type :increase  # 사용량 증가는 credit 작업
      debit_type :decrease   # 사용량 감소는 debit 작업
    end

    account :monthly_usage do
      # 월간 사용량 증가 및 감소
      change_attribute :monthly_used
      credit_type :increase
      debit_type :decrease
    end

    # 크레딧 계정 정의 (ash_money와 통합)
    account :credit_balance do
      change_attribute :credit_balance
      credit_type :increase  # 크레딧 증가
      debit_type :decrease   # 크레딧 감소 (사용)
    end
  end

  # ... 액션 및 기타 설정 ...
end

```

### 3.4 SDK 아키텍처

```mermaid
classDiagram
    class AutomataSignal {
        -String appId
        -AutomataSignalConfig config
        -SubscriptionManager subscriptionManager
        -UserManager userManager
        -MessageManager messageManager
        -InAppMessageManager inAppMessageManager
        +initialize(String appId, AutomataSignalConfig config)
        +login(String externalId)
        +logout()
        +setLanguage(String language)
        +addTags(Map tags)
        +removeTags(List tagNames)
        +disablePush()
        +enablePush()
        +registerEmail(String email)
        +registerSMS(String phoneNumber)
        +registerKakaoTalk(String phoneNumber)
        +fetchInAppMessages()
        +displayInAppMessage(String messageId)
    }

    class AutomataSignalConfig {
        +bool autoRegisterPush
        +bool autoPromptPermission
        +bool trackMessageEvents
        +String defaultLanguage
        +bool foregroundNotificationsEnabled
        +bool enableInAppMessages
    }

    class SubscriptionManager {
        -Map<String, String> subscriptionIds
        -Map deviceInfo
        +registerPushSubscription()
        +registerEmailSubscription(String email)
        +registerSMSSubscription(String phoneNumber)
        +registerKakaoSubscription(String phoneNumber)
        +updateToken(SubscriptionType type, String token)
        -collectDeviceInfo()
    }

    class UserManager {
        -String externalId
        -String automataId
        +identifyUser(String externalId)
        +logoutUser()
        +updateUserProperties(Map properties)
    }

    class MessageManager {
        -MessageEventListener listener
        +setMessageOpenedHandler(Function handler)
        +setMessageReceivedHandler(Function handler)
        +sendReceiptConfirmation(String messageId)
        +clearMessages()
    }

    class InAppMessageManager {
        -List<InAppMessage> cachedMessages
        +initialize()
        +fetchMessages()
        +displayMessage(String messageId)
        +trackAction(String messageId, String actionId)
        -evaluateTriggers(InAppMessage message)
    }

    class SubscriptionType {
        <<enumeration>>
        iOSPush
        AndroidPush
        Email
        SMS
        KakaoTalk
        InAppMessage
    }

    AutomataSignal --> AutomataSignalConfig
    AutomataSignal --> SubscriptionManager
    AutomataSignal --> UserManager
    AutomataSignal --> MessageManager
    AutomataSignal --> InAppMessageManager
    SubscriptionManager --> SubscriptionType

```

### SDK 구현 예시 (Flutter)

```dart
// 메인 SDK 클래스
class AutomataSignal {
  static final AutomataSignal _instance = AutomataSignal._internal();
  factory AutomataSignal() => _instance;
  AutomataSignal._internal();

  String? _appId;
  late AutomataSignalConfig config;
  late SubscriptionManager _subscriptionManager;
  late UserManager _userManager;
  late MessageManager _messageManager;
  late InAppMessageManager _inAppMessageManager; // 인앱 메시지 매니저 (지원 예정)

  Future<void> initialize(String appId, [AutomataSignalConfig? config]) async {
    _appId = appId;
    this.config = config ?? AutomataSignalConfig();

    _subscriptionManager = SubscriptionManager(appId);
    _userManager = UserManager(appId);
    _messageManager = MessageManager(appId);
    _inAppMessageManager = InAppMessageManager(appId); // 인앱 메시지 매니저 초기화 (지원 예정)

    // 푸시 알림 구독 등록 (기본)
    if (this.config.autoRegisterPush) {
      await _subscriptionManager.registerPushSubscription();

      // 권한 요청 (설정에 따라)
      if (this.config.autoPromptPermission) {
        await requestNotificationPermission();
      }
    }

    // 인앱 메시지 초기화 (지원 예정)
    if (this.config.enableInAppMessages) {
      await _inAppMessageManager.initialize();
    }
  }

  // 사용자 식별
  Future<void> login(String externalId) async {
    await _userManager.identifyUser(externalId);
  }

  Future<void> logout() async {
    await _userManager.logoutUser();
  }

  // 채널별 구독 등록
  Future<String?> registerEmail(String email) async {
    return await _subscriptionManager.registerEmailSubscription(email);
  }

  Future<String?> registerSMS(String phoneNumber) async {
    return await _subscriptionManager.registerSMSSubscription(phoneNumber);
  }

  Future<String?> registerKakaoTalk(String phoneNumber) async {
    return await _subscriptionManager.registerKakaoSubscription(phoneNumber);
  }

  // 인앱 메시지 관련 메서드 (지원 예정)
  Future<void> fetchInAppMessages() async {
    // 지원 예정
    return await _inAppMessageManager.fetchMessages();
  }

  Future<void> displayInAppMessage(String messageId) async {
    // 지원 예정
    return await _inAppMessageManager.displayMessage(messageId);
  }

  Future<void> trackInAppMessageAction(String messageId, String actionId) async {
    // 지원 예정
    return await _inAppMessageManager.trackAction(messageId, actionId);
  }

  // 구독 관련 메서드
  Future<void> disableChannel(SubscriptionType type) async {
    await _subscriptionManager.disableSubscription(type);
  }

  Future<void> enableChannel(SubscriptionType type) async {
    await _subscriptionManager.enableSubscription(type);
  }

  // 기타 API 메서드들...
}

// 설정 클래스
class AutomataSignalConfig {
  final bool autoRegisterPush;
  final bool autoPromptPermission;
  final bool trackMessageEvents;
  final String? defaultLanguage;
  final bool foregroundNotificationsEnabled;
  final bool enableInAppMessages; // 인앱 메시지 활성화 옵션 (지원 예정)

  AutomataSignalConfig({
    this.autoRegisterPush = true,
    this.autoPromptPermission = true,
    this.trackMessageEvents = true,
    this.defaultLanguage,
    this.foregroundNotificationsEnabled = true,
    this.enableInAppMessages = true, // 기본적으로 활성화
  });
}

// 구독 유형 열거형
enum SubscriptionType {
  iOSPush,
  AndroidPush,
  Email,
  SMS,
  KakaoTalk,
  InAppMessage, // 인앱 메시지 타입 추가 (지원 예정)
}

```

```dart
// 앱에서의 사용 예시
void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // SDK 초기화
  await AutomataSignal().initialize('YOUR_APP_ID',
    AutomataSignalConfig(
      autoRegisterPush: true,
      autoPromptPermission: true,
      foregroundNotificationsEnabled: true,
      enableInAppMessages: true, // 인앱 메시지 활성화
    )
  );

  runApp(MyApp());
}

// 사용자 로그인 시
Future<void> onUserLogin(String userId) async {
  await AutomataSignal().login(userId);

  // 로그인 후 인앱 메시지 확인 (지원 예정)
  await AutomataSignal().fetchInAppMessages();
}

// 사용자 로그아웃 시
Future<void> onUserLogout() async {
  await AutomataSignal().logout();
}

// 다양한 채널 등록 예시
Future<void> registerUserChannels(User user) async {
  // 이메일 채널 등록
  if (user.email != null) {
    String? emailSubscriptionId = await AutomataSignal().registerEmail(user.email!);
    print('Email subscription registered: $emailSubscriptionId');
  }

  // SMS 채널 등록
  if (user.phoneNumber != null) {
    String? smsSubscriptionId = await AutomataSignal().registerSMS(user.phoneNumber!);
    print('SMS subscription registered: $smsSubscriptionId');
  }

  // 카카오톡 채널 등록
  if (user.phoneNumber != null) {
    String? kakaoSubscriptionId = await AutomataSignal().registerKakaoTalk(user.phoneNumber!);
    print('KakaoTalk subscription registered: $kakaoSubscriptionId');
  }
}

// 인앱 메시지 처리 예시 (지원 예정)
class MyHomePage extends StatefulWidget {
  @override
  _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    // 인앱 메시지 리스너 설정
    AutomataSignal().setInAppMessageClickHandler((messageId, actionId) {
      // 메시지 클릭 처리
      print('In-app message clicked: $messageId, action: $actionId');
    });
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      // 앱이 포그라운드로 돌아올 때 인앱 메시지 확인
      AutomataSignal().fetchInAppMessages();
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }
}

```

### 3.5 메시지 처리 흐름

### 3.5.1 SDK 초기화 및 사용자 식별 흐름

```mermaid
sequenceDiagram
    participant App as 앱
    participant SDK as Automata SDK
    participant API as API 게이트웨이
    participant Server as Elixir 서버
    participant DB as 데이터베이스

    App->>SDK: initialize(APP_ID)
    SDK->>SDK: 디바이스 정보 수집
    SDK->>API: 디바이스 등록 요청
    API->>Server: 요청 처리
    Server->>DB: 새 Subscription 레코드 생성 (iOSPush/AndroidPush)
    DB-->>Server: 구독 ID 반환
    Server-->>API: 구독 ID 응답
    API-->>SDK: 구독 ID 저장

    Note over App,SDK: 사용자 로그인 시

    App->>SDK: login("external_id")
    SDK->>API: 사용자 식별 요청
    API->>Server: 요청 처리

    alt 기존 external_id가 존재
        Server->>DB: external_id로 User 조회
        DB-->>Server: 기존 User 정보
        Server->>DB: 현재 Subscription을 기존 User에 연결
    else 새로운 external_id
        Server->>DB: 새 User 레코드 생성
        DB-->>Server: 새 User ID
        Server->>DB: Subscription-User 연결
    end

    Server-->>API: 성공 응답
    API-->>SDK: 사용자 연결 완료
    SDK-->>App: 로그인 완료 콜백

    Note over App,SDK: 추가 채널 등록 (예: 이메일)

    App->>SDK: registerEmail("user@example.com")
    SDK->>API: 이메일 구독 등록 요청
    API->>Server: 요청 처리
    Server->>DB: 새 Subscription 레코드 생성 (type: Email)
    DB-->>Server: 구독 ID 반환
    Server-->>API: 구독 ID 응답
    API-->>SDK: 구독 ID 저장
    SDK-->>App: 이메일 등록 완료 콜백

    Note over App,SDK: 사용자 로그아웃 시

    App->>SDK: logout()
    SDK->>API: 사용자 연결 해제 요청
    API->>Server: 요청 처리
    Server->>DB: Subscription-User 연결 해제
    DB-->>Server: 성공 확인
    Server-->>API: 성공 응답
    API-->>SDK: 로그아웃 완료
    SDK-->>App: 로그아웃 완료 콜백

```

모바일 SDK 초기화 및 사용자 식별 과정을 상세하게 설명합니다:

1. **SDK 초기화**:
   - 앱은 `initialize(APP_ID)`를 호출하여 Automata SDK를 초기화합니다.
   - SDK는 디바이스 정보(모델, OS, 언어 등)를 수집하고 API를 통해 서버에 푸시 알림 구독을 등록합니다.
   - 서버는 새로운 Subscription 레코드를 생성하고 구독 ID를 반환합니다.
   - 이 시점에서 구독은 익명 상태로 등록됩니다(특정 사용자와 연결되지 않음).
2. **사용자 로그인**:
   - 앱에서 사용자 인증 후, `login("external_id")`를 호출하여 사용자 식별 정보를 제공합니다.
   - `external_id`는 앱의 고유 사용자 식별자로, 이메일이나 사용자 ID 등이 될 수 있습니다.
   - 서버는 `external_id`로 기존 User를 검색하거나 새로운 User를 생성합니다.
   - 현재 등록된 구독들이 해당 User와 연결되어 개인화된 메시지를 받을 수 있게 됩니다.
   - 같은 `external_id`로 여러 구독이 로그인하면, 모든 구독이 동일한 User에 연결됩니다.
3. **추가 채널 등록**:
   - 앱에서 `registerEmail()`, `registerSMS()`, `registerKakaoTalk()` 등을 호출하여 추가 채널을 등록합니다.
   - 서버는 해당 채널에 대한 새로운 Subscription 레코드를 생성하고 현재 로그인된 사용자와 연결합니다.
   - 이렇게 하나의 사용자는 여러 채널(푸시, 이메일, SMS, 카카오톡 등)을 통해 메시지를 받을 수 있게 됩니다.
4. **사용자 로그아웃**:
   - 앱에서 `logout()`을 호출하면 구독과 사용자 간의 연결이 해제됩니다.
   - 구독은 익명 상태로 돌아가고, 개인화된 메시지는 중단됩니다.
   - 구독 토큰은 여전히 유효하므로 일반 메시지는 계속 받을 수 있습니다.

이 흐름은 OneSignal과 유사한 방식으로 구독 등록 및 사용자 식별을 처리하며, 한 사용자가 여러 채널과 디바이스를 사용하는 시나리오와 여러 사용자가 한 디바이스를 공유하는 시나리오 모두를 지원합니다.

### 3.5.2 메시지 처리 흐름

```mermaid
sequenceDiagram
    participant Client as 클라이언트 앱
    participant API as API 게이트웨이
    participant Template as 템플릿 서비스
    participant Campaign as 캠페인 관리자
    participant Elixir as Elixir 서버 클러스터
    participant DB as PostgreSQL
    participant Oban as ash_oban 작업 큐
    participant Adapter as 채널 어댑터
    participant External as 외부 서비스 (APNS/FCM/등)
    participant User as 사용자 디바이스/이메일/SMS
    participant Analytics as 분석 시스템

    alt 개별 메시지 발송
        Client->>API: 메시지 요청
        API->>Elixir: 요청 전달
        Elixir->>DB: 메시지 데이터 저장
        Elixir->>Oban: 작업 큐에 추가
    else 템플릿 기반 개별 메시지
        Client->>API: 템플릿 기반 메시지 요청
        API->>Template: 템플릿 렌더링 요청
        Template->>DB: 템플릿 조회
        DB-->>Template: 템플릿 데이터
        Template->>Template: 변수 치환 및 렌더링
        Template-->>API: 렌더링된 메시지 콘텐츠
        API->>Elixir: 요청 전달
        Elixir->>DB: 메시지 데이터 저장
        Elixir->>Oban: 작업 큐에 추가
    else 캠페인 메시지
        Client->>API: 캠페인 생성 요청
        API->>Campaign: 캠페인 생성
        Campaign->>DB: 캠페인 저장

        alt 템플릿 기반 캠페인
            Campaign->>Template: 템플릿 렌더링 요청
            Template->>DB: 템플릿 조회
            DB-->>Template: 템플릿 데이터
            Template-->>Campaign: 렌더링된 기본 콘텐츠
        end

        Campaign->>DB: 타겟팅 조건으로 사용자/구독 조회
        DB-->>Campaign: 대상 리스트
        Campaign->>Elixir: 대량 메시지 생성 요청
        Elixir->>DB: 메시지 배치 저장
        Elixir->>Oban: 작업 큐에 배치 추가
    end

    Note over Elixir: 비동기 처리

    Oban-->>Elixir: 작업 스케줄링

    Elixir->>Adapter: 메시지 전송 요청

    alt 푸시 알림 채널
        Adapter->>External: APNS/FCM 요청
        External->>User: 푸시 알림 전달
        External-->>Adapter: 응답
    else 이메일 채널 (지원 예정)
        Adapter-->>External: SMTP 요청 (지원 예정)
    else SMS 채널 (지원 예정)
        Adapter-->>External: SMS 게이트웨이 요청 (지원 예정)
    else 카카오 알림톡 (지원 예정)
        Adapter-->>External: 카카오 API 요청 (지원 예정)
    else 인앱 메시지 (지원 예정)
        Adapter-->>Client: 인앱 메시지 데이터 제공 (지원 예정)
    end

    Adapter-->>Elixir: 응답 처리
    Elixir->>DB: 상태 업데이트 (successful)
    Elixir->>Analytics: 메시지 발송 이벤트

    User-->>Client: 메시지 수신 확인
    Client->>API: 상태 업데이트 (received)
    API->>Elixir: 상태 업데이트 요청
    Elixir->>DB: 상태 업데이트 기록
    Elixir->>Analytics: 메시지 수신 이벤트

    User-->>Client: 사용자 메시지 클릭
    Client->>API: 상태 업데이트 (converted)
    API->>Elixir: 상태 업데이트 요청
    Elixir->>DB: 상태 업데이트 기록
    Elixir->>Analytics: 메시지 열람 이벤트

```

메시지 처리 흐름은 개별 메시지, 템플릿 기반 메시지, 대량 캠페인의 세 가지 주요 경로를 포함합니다. 현재 푸시 알림 채널만 구현되어 있으며 나머지 채널(이메일, SMS, 카카오 알림톡, 인앱 메시지)은 향후 구현될 예정입니다:

1. **개별 메시지 발송**:
   - 클라이언트 앱이 특정 사용자/구독에 메시지 전송을 요청합니다.
   - 서버는 메시지 데이터를 저장하고 작업 큐에 추가합니다.
2. **템플릿 기반 개별 메시지**:
   - 클라이언트가 템플릿 ID와 변수를 제공하여 메시지를 요청합니다.
   - 템플릿 서비스가 템플릿을 조회하고 변수를 치환하여 최종 콘텐츠를 생성합니다.
   - 렌더링된 콘텐츠로 메시지를 생성하고 작업 큐에 추가합니다.
3. **캠페인 메시지**:
   - 클라이언트가 대량 발송을 위한 캠페인을 생성합니다.
   - 캠페인 관리자는 캠페인 정보를 저장하고, 템플릿 기반 캠페인인 경우 템플릿 서비스에 렌더링을 요청합니다.
   - 타겟팅 조건에 맞는 사용자/구독을 조회하여 대량의 메시지를 생성합니다.
   - 생성된 메시지를 배치로 작업 큐에 추가합니다.
4. **비동기 처리 및 전송**:
   - 작업 큐는 서버 부하에 따라 메시지 전송 작업을 스케줄링합니다.
   - 채널 어댑터가 메시지 유형에 따라 적절한 외부 서비스로 전송 요청을 처리합니다.
     - 푸시 알림: 즉시 APNS 또는 FCM으로 전송
     - 이메일/SMS/카카오 알림톡/인앱 메시지: 지원 예정
   - 전송 결과에 따라 메시지 상태가 업데이트되고 이벤트가 기록됩니다.
5. **상태 추적**:
   - 클라이언트 SDK는 메시지 수신 및 사용자 상호작용을 서버에 보고합니다.
   - 서버는 메시지 상태를 업데이트하고 분석 데이터를 수집합니다.

이 흐름은 개별 메시지부터 대량 캠페인까지 다양한 시나리오를 효율적으로 처리하며, 템플릿을 활용한 개인화와 상태 추적을 통한 상세한 분석을 제공합니다. 향후 이메일, SMS, 카카오 알림톡, 인앱 메시지 채널이 구현되면 이 흐름이 확장될 예정입니다.

### 3.6 채널 어댑터 시스템

Automata-Signal은 다양한 메시징 채널을 지원하기 위해 모듈화된 어댑터 시스템을 구현합니다. 각 채널 어댑터는 특정 메시징 서비스와의 통합을 담당합니다:

### 푸시 알림 어댑터 (지원)

```elixir
defmodule AutomataSignal.Adapters.PushAdapter do
  use GenServer
  alias AutomataSignal.Adapters.Base

  # APNS 설정
  @apns_config %{
    cert: {:file, "path/to/cert.pem"},
    key: {:file, "path/to/key.pem"},
    mode: :prod  # :dev 또는 :prod
  }

  # FCM 설정
  @fcm_config %{
    key: "your_server_key"
  }

  # 구독 유형에 따라 적절한 어댑터 선택
  def send_message(%{subscription: subscription} = message) do
    case subscription.type do
      :iOSPush -> send_ios_message(message)
      :AndroidPush -> send_android_message(message)
      _ -> {:error, :invalid_subscription_type}
    end
  end

  # ... 디바이스 타입별 전송 로직 ...

  # 디바이스의 test_type에 따라 APNS 환경 결정
  defp get_apns_config(%{test_type: 1}), do: %{@apns_config | mode: :dev}
  defp get_apns_config(%{test_type: 2}), do: %{@apns_config | mode: :dev}
  defp get_apns_config(_), do: @apns_config

  # 오류 코드 매핑
  defp map_error_to_subscription_code(:unregistered), do: -10
  # ... 기타 오류 코드 매핑 ...
end

```

### 이메일 어댑터 (지원 예정)

```elixir
defmodule AutomataSignal.Adapters.EmailAdapter do
  use GenServer
  alias AutomataSignal.Adapters.Base

  def send_message(%{subscription: %{type: :Email, token: email}} = message) do
    # 지원 예정:
    # Swoosh를 사용한 이메일 전송
    {:error, :not_implemented_yet}
  end

  # ... 지원 예정 응답 처리 로직 ...
end

```

### SMS 어댑터 (지원 예정)

```elixir
defmodule AutomataSignal.Adapters.SMSAdapter do
  use GenServer
  alias AutomataSignal.Adapters.Base

  def send_message(%{subscription: %{type: :SMS, token: phone_number}} = message) do
    # 지원 예정:
    # SMS 게이트웨이를 통한 전송
    {:error, :not_implemented_yet}
  end

  # ... 지원 예정 응답 처리 로직 ...
end

```

### 카카오톡 어댑터 (지원 예정)

```elixir
defmodule AutomataSignal.Adapters.KakaoAdapter do
  use GenServer
  alias AutomataSignal.Adapters.Base

  def send_message(%{subscription: %{type: :KakaoTalk, token: phone_number}} = message) do
    # 지원 예정:
    # 카카오 알림톡 API를 통한 전송
    {:error, :not_implemented_yet}
  end

  # ... 지원 예정 응답 처리 로직 ...
end

```

### 인앱 메시지 어댑터 (지원 예정)

```elixir
defmodule AutomataSignal.Adapters.InAppAdapter do
  use GenServer
  alias AutomataSignal.Adapters.Base

  def send_message(%{subscription: %{type: :InAppMessage}} = message) do
    # 지원 예정:
    # SDK를 통한 인앱 메시지 전달 로직
    {:error, :not_implemented_yet}
  end

  # ... 지원 예정 응답 처리 로직 ...
end

```

이 어댑터 시스템의 주요 이점:

- **일관된 인터페이스**: 모든 채널에 동일한 `send_message/1` 인터페이스 제공
- **모듈성**: 새로운 채널 추가가 기존 코드에 영향을 주지 않음
- **단계적 구현**: 푸시 알림부터 시작하여 다른 채널은 향후 단계적으로 구현 가능
- **채널별 최적화**: 각 채널의 고유한 특성과 기능을 최대한 활용
- **오류 처리 통합**: 채널별 오류 코드를 표준화된 내부 코드로 변환
- **채널별 지표 수집**: 각 채널의 성능 및 효율성을 독립적으로 모니터링

### 3.7 멀티채널 메시징 시스템

Automata-Signal은 다양한 채널을 통해 메시지를 전송할 수 있는 통합 메시징 플랫폼으로 설계되었습니다:

| 채널          | 기술                  | 지원      | 장점                                 |
| ------------- | --------------------- | --------- | ------------------------------------ |
| iOS 푸시      | Pigeon/APNS           | 지원      | 즉각적인 모바일 알림, 유저 참여 증대 |
| Android 푸시  | Pigeon/FCM            | 지원      | 크로스 플랫폼 모바일 알림 지원       |
| 이메일        | Swoosh/SMTP/SES       | 지원 예정 | 풍부한 콘텐츠 전달, 마케팅 캠페인    |
| SMS           | 다양한 SMS 게이트웨이 | 지원 예정 | 높은 도달률, 중요 알림에 적합        |
| 카카오 알림톡 | 카카오 비즈니스 API   | 지원 예정 | 한국 시장 타겟팅, 공식 채널 식별     |
| 인앱 메시지   | SDK 내장 컴포넌트     | 지원 예정 | 앱 내 직접 전달, 높은 참여율         |

각 채널에 대한 전용 어댑터는 메시지 형식, 전송 프로토콜, 오류 처리 등을 처리하여 일관된 인터페이스를 제공합니다.

### 3.8 배포 아키텍처

```mermaid
flowchart TB
    subgraph fly ["fly.io"]
        subgraph nrt ["도쿄 리전 (nrt)"]
            nrt1[Elixir 노드 #1]
            nrt2[Elixir 노드 #2]
        end

        subgraph fra ["프랑크푸르트 (fra)"]
            fra1[Elixir 노드 #1]
            fra2[Elixir 노드 #2]
        end

        subgraph syd ["시드니 리전 (syd)"]
            syd1[Elixir 노드 #1]
            syd2[Elixir 노드 #2]
        end

        db[(PostgreSQL 클러스터<br>프라이머리: nrt)]
    end

    %% 노드 간 연결
    nrt1 <--> fra1
    nrt1 <--> syd1
    fra1 <--> syd1

    nrt2 <--> fra2
    nrt2 <--> syd2
    fra2 <--> syd2

    %% 데이터베이스 연결
    nrt1 --> db
    nrt2 --> db
    fra1 --> db
    fra2 --> db
    syd1 --> db
    syd2 --> db

```

Automata-Signal은 fly.io 플랫폼을 활용한 글로벌 분산 배포를 구현합니다:

- **다중 리전 배포**: 지역적으로 분산된 여러 데이터 센터에 배포하여 지연 시간 최소화 및 중복성 제공
- **노드 간 통신**: libcluster를 활용하여 Elixir 노드 간 자동 연결 및 통신 구현
- **데이터베이스 복제**: 프라이머리 리전에 메인 데이터베이스를 두고 다른 리전에 복제본 유지
- **근접성 기반 라우팅**: 사용자에게 가장 가까운 리전으로 요청 라우팅

## 4. 핵심 기술 사항

### 사용된 기술 스택

**백엔드**:

- **프로그래밍 언어**: Elixir - 동시성 처리와 분산 시스템 구축에 최적화된 언어
- **웹 프레임워크**: Phoenix - 고성능 웹 API 개발용 프레임워크
- **데이터 모델링**: Ash Framework - 풍부한 도메인 모델링 및 확장 기능 제공
- **데이터베이스**: PostgreSQL - 트랜잭션 안정성과 확장성이 뛰어난 관계형 DB
- **작업 큐**: Oban(ash_oban) - 백그라운드 작업 처리 및 스케줄링
- **푸시 서비스**: Pigeon - iOS와 Android 푸시 통합 라이브러리
- **분산 시스템**: libcluster와 Erlang/OTP - 노드 발견 및 분산 처리
- **템플릿 엔진**: EEx 기반 커스텀 템플릿 엔진 - 변수 치환 및 조건부 콘텐츠 지원

**클라이언트**:

- **모바일 프레임워크**: Flutter - 크로스 플랫폼 모바일 개발
- **푸시 통합**: firebase_messaging, flutter_local_notifications
- **SDK 구조**: 모듈화된 SDK - 구독 등록, 사용자 식별, 메시지 처리

**인프라**:

- **클라우드 플랫폼**: fly.io - 글로벌 엣지 배포 지원
- **모니터링**: 내장 모니터링 및 로깅 시스템

### 기술적 특징 및 이점

### Ash Framework 확장 모듈 활용

| 모듈              | 용도             | 설명                                                          |
| ----------------- | ---------------- | ------------------------------------------------------------- |
| ash_state_machine | 메시지 상태 관리 | 메시지 라이프사이클을 상태 머신으로 관리                      |
| ash_oban          | 비동기 작업 처리 | 메시지 전송 작업 큐 관리 및 스케줄링                          |
| ash_paper_trail   | 변경 내역 추적   | 메시지 상태 변경 기록 및 감사 추적                            |
| ash_archival      | 논리적 삭제      | 사용자 및 구독 데이터의 소프트 삭제 처리                      |
| ash_cloak         | 데이터 암호화    | 민감한 사용자 데이터 및 토큰 암호화                           |
| ash_money         | 과금 처리        | 정확한 통화 변환 및 요금 계산 (향후 유료 과금제 도입 시 활용) |
| ash_double_entry  | 사용량 추적      | 앱별 메시지 할당량 및 사용량 정확한 추적                      |
| ash_csv           | 데이터 내보내기  | 통계 데이터 및 보고서 CSV 내보내기                            |

### 템플릿 엔진 구현

템플릿 엔진은 다음과 같은 기능을 제공합니다:

```elixir
defmodule AutomataSignal.TemplateEngine do
  @doc """
  템플릿에 변수를 적용하여 최종 텍스트를 생성합니다.

  ## 예시
    template = "안녕하세요 {{user_name}}님, {{event_name}} 이벤트가 시작됩니다"
    variables = %{"user_name" => "홍길동", "event_name" => "여름 세일"}

    render_template(template, variables)
    # => "안녕하세요 홍길동님, 여름 세일 이벤트가 시작됩니다"
  """
  def render_template(template, variables) when is_binary(template) and is_map(variables) do
    Regex.replace(~r/\{\{([^}]+)\}\}/, template, fn _, var_name ->
      Map.get(variables, var_name, "")
    end)
  end

  @doc """
  템플릿 객체(title_template, body_template, data_template)에
  변수를 적용하여 최종 메시지 콘텐츠를 생성합니다.
  """
  def render_message_content(template, variables) do
    %{
      title: render_template(template.title_template, variables),
      body: render_template(template.body_template, variables),
      data: render_data_template(template.data_template, variables)
    }
  end

  # 중첩된 데이터 구조에 변수 적용
  defp render_data_template(data_template, variables) when is_map(data_template) do
    data_template
    |> Enum.map(fn {k, v} -> {k, render_data_value(v, variables)} end)
    |> Enum.into(%{})
  end

  defp render_data_value(value, variables) when is_binary(value) do
    render_template(value, variables)
  end

  defp render_data_value(value, variables) when is_map(value) do
    render_data_template(value, variables)
  end

  defp render_data_value(value, variables) when is_list(value) do
    Enum.map(value, &render_data_value(&1, variables))
  end

  defp render_data_value(value, _variables), do: value
end

```

### 메시지 상태 추적 시스템

```mermaid
stateDiagram-v2
    [*] --> pending: 메시지 생성

    pending --> successful: 외부 서비스 전송 성공
    pending --> failed: 유효하지 않은 토큰
    pending --> errored: 일시적 서비스 장애

    successful --> received: 디바이스/채널 도달
    successful --> failed: 시간 초과

    errored --> successful: 재시도 성공
    errored --> failed: 최대 재시도 초과

    received --> converted: 사용자 클릭/열람
    received --> [*]: 만료

    converted --> [*]
    failed --> [*]

    note right of pending
        작업 큐에 저장된 상태
    end note

    note right of successful
        외부 서비스에 성공적으로 전송됨
    end note

    note right of received
        클라이언트가 수신 확인
    end note

    note right of converted
        사용자가 메시지 확인/클릭
    end note

```

메시지의 전체 라이프사이클을 추적하여 상세한 상태 정보와 분석 데이터를 제공합니다:

| 상태              | 정의                          | 측정 방식                  |
| ----------------- | ----------------------------- | -------------------------- |
| successful (발송) | 외부 서비스에 성공적으로 전달 | 서비스 응답 확인           |
| failed (실패)     | 유효하지 않은 토큰/구독 취소  | 오류 코드 분석             |
| errored (오류)    | 일시적 서비스 장애            | 서비스 불가 응답           |
| received (도달)   | 사용자 기기/채널에 도달       | 클라이언트 SDK 확인 신호   |
| converted (열람)  | 사용자가 메시지 클릭/확인     | 클라이언트 SDK 열람 이벤트 |

## 5. 성능 및 부하 요구사항

### 5.1 성능 지표

| 항목                   | 사양                     | 비고                    |
| ---------------------- | ------------------------ | ----------------------- |
| 최대 처리량            | 초당 10만 건             | 분산 노드 구성 시       |
| 버스트 처리            | 10초당 100만 건          | 큐 기반 버퍼링으로 처리 |
| 평균 E2E 지연          | 500ms 이하               | 네트워크 상태 양호 시   |
| 데이터베이스 동시 접속 | 최대 50 connections/노드 | 커넥션 풀링 적용        |
| 단일 노드 처리량       | 초당 5,000-10,000건      | HW 사양에 따라 변동     |

### 5.2 부하 테스트 계획

1. **단일 노드 부하 테스트**:
   - 목표: 단일 노드의 최대 처리량 측정
   - 방법: 점진적으로 요청 수를 증가시키며 응답 시간 및 오류율 모니터링
   - 지표: 초당 처리량, 응답 지연 시간, CPU/메모리 사용량
2. **분산 클러스터 부하 테스트**:
   - 목표: 전체 시스템의 확장성 검증
   - 방법: 다중 노드 환경에서 대량 메시지 요청 시뮬레이션
   - 지표: 전체 처리량, 노드 간 부하 분산, 데이터베이스 병목 현상
3. **장애 복구 테스트**:
   - 목표: 노드 장애 시 복구 능력 검증
   - 방법: 임의 노드 중단 및 복구 시 시스템 동작 테스트
   - 지표: 복구 시간, 메시지 손실률, 서비스 연속성
4. **지속 부하 테스트**:
   - 목표: 장시간 운영 시 안정성 검증
   - 방법: 72시간 지속적인 중간 부하 유지
   - 지표: 메모리 누수, 성능 저하, 오류 발생 패턴
5. **앱별 할당량 테스트**:
   - 목표: 할당량 제한 및 과금 메커니즘 검증
   - 방법: 여러 앱의 할당량 초과 시나리오 시뮬레이션
   - 지표: 할당량 추적 정확도, 제한 적용 정확성
6. **SDK 성능 테스트**:
   - 목표: SDK의 성능 및 안정성 검증
   - 방법: 다양한 디바이스 환경에서 초기화, 로그인, 채널 등록 성능 측정
   - 지표: 배터리 소모, 메모리 사용량, 응답 시간
7. **멀티채널 부하 테스트** (향후):
   - 목표: 다양한 채널의 동시 처리 능력 검증
   - 방법: 여러 채널에 대한 혼합 부하 생성
   - 지표: 채널별 처리 속도, 시스템 전체 처리량

### 5.3 시스템 요구사항

| 구성 요소   | 최소 사양                                      | 권장 사양                                          |
| ----------- | ---------------------------------------------- | -------------------------------------------------- |
| Elixir 노드 | CPU: 2 vCPU<br />RAM: 2GB<br />DISK: 20GB      | CPU: 4+ vCPU<br />RAM: 4GB+<br />DISK: 40GB+       |
| PostgreSQL  | CPU: 4 vCPU<br />RAM: 8GB<br />DISK: 100GB SSD | CPU: 8+ vCPU<br />RAM: 16GB+<br />DISK: 500GB+ SSD |
| 네트워크    | 1Gbps                                          | 10Gbps                                             |

## 6. 모니터링 및 운영

### 모니터링 전략

1. **시스템 모니터링**:
   - CPU, 메모리, 디스크 I/O, 네트워크 트래픽 등 기본 시스템 지표
   - 노드 상태 및 클러스터 연결 상태
   - 데이터베이스 성능 및 연결 풀 상태
2. **애플리케이션 모니터링**:
   - 요청 처리량, 응답 시간, 오류율
   - 채널별 전송 상태 및 성능
   - 작업 큐 길이 및 작업 처리 시간
   - 템플릿 렌더링 성능
   - 캠페인 처리 진행 상황
3. **비즈니스 지표 모니터링**:
   - 메시지 상태별 분포 및 변화율
   - 앱별 할당량 사용 현황
   - 구독/구독취소 추이
   - 템플릿 및 캠페인 사용 통계
   - 채널별 성과 분석 및 비교
   - 메시지 전환율(수신→열람) 분석
4. **SDK 성능 모니터링**:
   - 초기화 시간
   - 구독 등록 성공률
   - 사용자 식별 성공률
   - 클라이언트 오류 발생률
5. **알림 설정**:
   - 시스템 성능 저하 시 알림
   - 오류율 임계값 초과 시 알림
   - 앱별 할당량 소진 임계값 도달 시 알림
   - 캠페인 진행 상황 알림

### 운영 계획

1. **장애 대응 절차**:
   - 단계별 에스컬레이션 프로세스
   - 자동화된 복구 절차
   - 백업 및 복원 계획
2. **성능 최적화**:
   - 정기적인 성능 검토 및 병목 지점 식별
   - 데이터베이스 쿼리 최적화
   - 템플릿 렌더링 캐싱 전략
   - 주기적인 리소스 확장 계획 검토
3. **유지보수 계획**:
   - 무중단 업데이트 전략
   - 정기적인 데이터베이스 유지보수
   - 보안 패치 및 의존성 업데이트 일정
   - SDK 버전 관리 및 호환성 전략
4. **백업 전략**:
   - 일일 데이터베이스 전체 백업
   - 시간별 증분 백업
   - 다중 리전 백업 저장
5. **채널 관리 전략** (향후):
   - 채널별 성능 및 안정성 모니터링
   - 채널 추가 및 삭제 프로세스
   - 채널별 할당량 및 비용 관리

## 7. 구현 로드맵

```mermaid
gantt
    title Automata-Signal 구현 로드맵
    dateFormat YYYY-MM-DD

    section 1. 기본 인프라
    핵심 API 서버 구현      :a1, 2025-04-01, 14d
    PostgreSQL 설정         :a2, after a1, 7d
    앱 관리 모듈 구현       :a3, after a1, 10d

    section 2. 푸시 알림 채널
    Pigeon 통합             :b1, after a2, 7d
    푸시 어댑터 구현         :b2, after b1, 7d
    푸시 알림 상태 추적      :b3, after b2, 7d

    section 3. 분산 시스템
    libcluster 설정          :c1, after b3, 7d
    GenServer 분산 처리      :c2, after c1, 14d

    section 4. 작업 처리
    Oban 작업 큐 구현        :d1, after c2, 7d
    비동기 처리 시스템        :d2, after d1, 7d

    section 5. 템플릿 및 캠페인
    템플릿 엔진 개발         :e1, after d2, 10d
    캠페인 관리 시스템       :e2, after e1, 14d
    타겟팅 엔진 구현         :e3, after e2, 10d

    section 6. SDK 개발
    SDK 코어 기능           :f1, after e3, 14d
    구독 관리 기능          :f2, after f1, 7d
    사용자 식별 기능        :f3, after f2, 7d

    section 7. 할당량 관리
    앱별 할당량 시스템       :g1, after a3, 10d
    사용량 추적 기능         :g2, after g1, 7d
    과금 모델 구현           :g3, after g2, 10d

    section 8. 분석 시스템
    통계 API                :h1, after d2, 14d
    앱별 분석 기능           :h2, after h1, 7d
    대시보드 구현            :h3, after h2, 10d

    section 9. 추가 채널 준비
    채널 어댑터 인터페이스    :i1, after b3, 7d
    이메일/SMS/카카오 타입 정의 :i2, after i1, 7d

    section 10. 성능 최적화
    부하 테스트              :j1, after f3, 7d
    성능 튜닝                :j2, after j1, 7d
    글로벌 배포             :j3, after j2, 7d

    section 11. 미래 확장
    이메일 채널 지원         :k1, 2025-10-01, 14d
    SMS 채널 지원           :k2, 2025-10-15, 14d
    카카오 알림톡 지원       :k3, 2025-11-01, 14d
    인앱 메시지 지원         :k4, 2025-11-15, 14d

```

### 개발 일정

| 단계                   | 주요 목표                   | 소요 시간 | 내용                                                                                                          |
| ---------------------- | --------------------------- | --------- | ------------------------------------------------------------------------------------------------------------- |
| 1. 기본 인프라 구축    | 핵심 API 서버, 리소스 설계  | 4주       | - Umbrella 프로젝트 구조 설정<br />- Ash 리소스 정의<br />- 데이터베이스 스키마 설계<br />- 앱 관리 모듈 구현 |
| 2. 푸시 알림 채널 구현 | 푸시 알림 발송 및 상태 관리 | 3주       | - Pigeon 푸시 서비스 통합<br />- 푸시 어댑터 구현<br />- 상태 머신 구현                                       |
| 3. 분산 처리 시스템    | 분산 노드 구성              | 3주       | - libcluster 설정<br />- 분산 GenServer 구현<br />- 노드 간 작업 분배                                         |
| 4. 비동기 작업 처리    | 작업 큐 구현                | 2주       | - ash_oban 워커 구현<br />- 재시도 전략 설정<br />- 배치 처리 최적화                                          |
| 5. 템플릿 및 캠페인    | 템플릿 기반 메시지 기능     | 4주       | - 템플릿 엔진 개발<br />- 변수 처리 로직<br />- 캠페인 관리 시스템<br />- 타겟팅 기능                         |
| 6. SDK 개발            | SDK 구현                    | 4주       | - Flutter SDK 핵심 기능<br />- 구독 등록 기능<br />- 사용자 식별 및 로그인<br />- 메시지 추적 콜백            |
| 7. 할당량 관리         | 앱별 사용량 제한 및 과금    | 4주       | - 앱별 할당량 모델 구현<br />- 사용량 추적 시스템<br />- 과금 모델 및 보고서                                  |
| 8. 통계 및 분석 시스템 | 데이터 분석 기능            | 4주       | - 통계 API 구현<br />- 앱별, 채널별 분석 기능<br />- 대시보드 데이터 제공                                     |
| 9. 추가 채널 준비      | 미래 채널 확장 준비         | 2주       | - 채널 어댑터 인터페이스 정의<br />- 이메일/SMS/카카오/인앱 타입 정의                                         |
| 10. 성능 최적화        | 성능 향상                   | 3주       | - 성능 테스트<br />- 병목 지점 분석<br />- 시스템 튜닝<br />- 글로벌 배포                                     |
| 11. 미래 확장          | 추가 채널 지원              | 향후 계획 | - 이메일 채널 지원<br />- SMS 채널 지원<br />- 카카오 알림톡 지원<br />- 인앱 메시지 지원                     |

### 자원 할당

1. **개발 팀 구성**:
   - 백엔드 개발자 (Elixir) - 3명
   - 프론트엔드 개발자 (Flutter) - 2명
   - DevOps 엔지니어 - 1명
   - QA 엔지니어 - 1명
2. **하드웨어 요구사항**:
   - 개발 환경: 각 개발자 워크스테이션
   - 테스트 환경: 6-8 노드 클러스터
   - 운영 환경: 최소 12 노드 분산 클러스터 (리전당 4노드)
3. **외부 서비스 및 도구**:
   - fly.io 계정 및 리소스
   - APNS 및 FCM 개발자 계정
   - 모니터링 및 로깅 도구
   - CI/CD 파이프라인

## 8. 결론

Automata-Signal은 Elixir의 분산 처리 능력과 Ash Framework의 강력한 도메인 모델링 기능을 활용하여 구축된 통합 멀티채널 메시징 플랫폼입니다. 초기에는 푸시 알림에 집중하되, 향후 이메일, SMS, 카카오 알림톡, 인앱 메시지 등의 채널을 쉽게 추가할 수 있는 확장 가능한 아키텍처로 설계되었습니다. 초당 10만 건의 메시지를 처리할 수 있는 확장성과 글로벌 분산 배포를 통한 높은 가용성을 제공합니다.

핵심 차별점:

- **멀티채널 통합 아키텍처**: 다양한 채널을 단일 플랫폼에서 통합 관리할 수 있는 확장 가능한 구조
- **고성능 분산 처리**: Elixir/OTP 기반 경량 프로세스 모델을 통한 높은 동시성 처리
- **확장 가능한 어댑터 시스템**: 새로운 채널을 쉽게 추가할 수 있는 모듈화된 어댑터 아키텍처
- **통합 SDK**: OneSignal과 유사한 사용자 경험의 크로스 플랫폼 SDK, 다양한 채널 구독 관리 지원
- **사용자 식별 시스템**: external_id 기반의 사용자 식별 및 멀티 채널/디바이스 지원
- **단계적 구현 접근법**: 처음에는 푸시 알림에 집중하고, 향후 단계적으로 추가 채널 지원
- **강력한 템플릿 기능**: 재사용 가능한 템플릿과 변수 치환을 통한 개인화, 채널별 최적화
- **대량 캠페인 관리**: 타겟팅 조건 기반의 대규모 메시지 캠페인 관리
- **정교한 상태 추적**: 메시지의 전체 라이프사이클 추적을 통한 상세한 참여 분석
- **앱별 사용량 관리**: 앱 단위의 할당량 관리 및 사용량 기반 과금 모델 지원
- **글로벌 확장성**: fly.io를 활용한 지역 분산 배포로 전 세계 어디서나 낮은 지연 시간 보장
- **모듈화된 설계**: Umbrella 구조를 통한 명확한 관심사 분리 및 유지보수성 향상
- **표준화된 구독 상태 코드**: 멀티채널 환경에 최적화된 구독 상태 관리 시스템

이 시스템은 엄격한 코드 품질 원칙, TDD 방식, SOLID 원칙을 적용하여 개발되며, 모든 구성 요소는 철저한 테스트 및 문서화를 통해 장기적인 유지보수를 지원합니다. 초기에는 푸시 알림 기능에 집중하되, 미래에 다양한 메시징 채널을 쉽게 추가할 수 있는 유연한 기반을 제공합니다.

---

// File: vibe-coding/APP-000-global-rules

# [APP-000] Global rules

## 1️⃣ 구현 작업 원칙

- SOLID 원칙을 사용해서 구현하세요:
  - 단일 책임 원칙 (Single Responsibility Principle)
  - 개방-폐쇄 원칙 (Open-Closed Principle)
  - 리스코프 치환 원칙 (Liskov Substitution Principle)
  - 인터페이스 분리 원칙 (Interface Segregation Principle)
  - 의존성 역전 원칙 (Dependency Inversion Principle)
- TDD로 구현하세요: 테스트 주도 개발 방식으로 먼저 테스트를 작성하고 구현하세요.
- Clean Architecture를 사용해서 구현하세요: 책임과 관심사를 명확히 분리하여 구현하세요.
- 영어로 코드 및 변수 명을 작성하되, 주석과 문서는 한국어로 작성하세요.

## 2️⃣ 코드 품질 원칙

- 단순성: 언제나 복잡한 솔루션보다 가장 단순한 솔루션을 우선시하세요.
- 중복 방지: 코드 중복을 피하고, 가능한 기존 기능을 재사용하세요 (DRY 원칙).
- 가드레일: 테스트 외에는 개발이나 프로덕션 환경에서 모의 데이터를 사용하지 마세요.
- 효율성: 명확성을 희생하지 않으면서 코드를 최적화하세요.
- 파일은 간결하게 유지하고, 200-300줄 이내로 하며, 필요에 따라 리팩토링하세요.

## 3️⃣ 리팩토링

- 리팩토링이 필요한 경우 계획을 설명하고 허락을 받은 다음 진행하세요.
- 코드 구조를 개선하는 것이 목표이며, 기능 변경은 아닙니다.
- 리팩토링 후에는 모든 테스트가 통과하는지 확인하세요.

## 4️⃣ 디버깅

- 디버깅 시에는 원인 및 해결책을 설명하고 허락을 받은 다음 진행하세요.
- 에러 해결이 중요한 것이 아니라 제대로 동작하는 것이 중요합니다.
- 원인이 불분명할 경우 분석을 위해 상세 로그를 추가하세요.

## 5️⃣ 언어

- 한국어로 소통하세요.
- 문서와 주석도 한국어로 작성하세요.
- 기술적인 용어나 라이브러리 이름 등은 원문을 유지해도 됩니다.

## 6️⃣ Git 커밋

- `no-verify`를 절대 사용하지 마세요.
- 명확하고 일관된 커밋 메시지를 작성하세요.
- 적절한 크기로 커밋을 유지하세요.

## 7️⃣ 코드 내부 문서화

- 모든 모듈 상단에는 모듈의 목적과 책임을 간략하게 설명하는 주석을 추가하세요.
- 함수와 메서드에는 다음 정보를 포함하는 주석을 작성하세요:
  - 함수의 목적
  - 매개변수 설명
  - 반환 값 설명
  - 발생 가능한 예외
- 복잡한 로직이나 알고리즘은 단계별로 주석을 추가하여 설명하세요.
- 코드에 구현된 비즈니스 규칙이나 중요한 결정 사항을 주석으로 기록하세요.
- 성능에 영향을 미치는 최적화나 특별한 고려사항을 주석으로 설명하세요.
- 임시적인 해결책이나 향후 개선이 필요한 부분은 TODO 주석으로 명확히 표시하세요.
- 주석은 코드와 함께 업데이트하여 항상 최신 상태를 유지하세요.

## 8️⃣ 컨텍스트 관리

- 컨텍스트가 100k 토큰을 초과하면 `context-summary.md`에 요약하고 세션을 재시작하세요.
- 이모지를 사용하여 컨텍스트 유지를 확인하세요 (예: 모든 응답 시작에 🚀).

---

// File: vibe-coding/APP-001-workspace-rules

# [APP-001] Workspace rules

## 1️⃣ 기술 스택 - "이 도구들을 사용하세요"

### 개발 도구

- 프로젝트 구조: Elixir Umbrella 앱
- 백엔드: Elixir, Ash Framework
- Ash Framework 확장 모듈: ash_state_machine, ash_oban, ash_paper_trail, ash_archival, ash_cloak, ash_money, ash_double_entry, ash_csv
- 데이터베이스: PostgreSQL (Oban 작업 큐 포함)
- 클라이언트: Flutter
- 멀티채널 지원:
  - 푸시 알림: Pigeon (FCM/APNS 클라이언트)
  - 이메일: Swoosh (지원 예정)
  - SMS: 다양한 SMS 게이트웨이 (지원 예정)
  - 카카오 알림톡: 카카오 비즈니스 API (지원 예정)
  - 인앱 메시지: SDK 내장 컴포넌트 (지원 예정)
- 배포: fly.io (글로벌 분산 배포)

### 추가 정보

- 추가 도구가 명시적으로 요청되면 여기에 포함될 수 있습니다.
- 명시적인 승인 없이는 스택을 변경하지 마세요.
- 외부 메시지 큐(Kafka, RabbitMQ 등)를 사용하지 말고 Oban과 PostgreSQL만 사용하세요.
- 초기 구현은 푸시 알림에 집중하고, 다른 채널은 추후 단계적으로 구현할 예정입니다.

## 2️⃣ 워크플로우 선호도 - "이런 방식으로 작업하세요"

### 기본 과정

- 초점: 지정된 코드만 수정하고, 다른 부분은 그대로 두세요.
- 단계: 큰 작업을 단계로 나누고, 각 단계 후에는 승인을 기다리세요.
- 계획: 큰 변경 전에는 설계 및 작업개요 문서 `../7-progress/[이슈명]_design.md`와 구현 계획 문서 `../7-progress/[이슈명]_plan.md`를 작성하고 확인을 기다리세요.
- 추적: 작업 진행 상황, 완료된 작업, 그리고 앞으로 진행할 작업 항목을 `../7-progress/status.md` 파일에 기록하세요. 각 작업 항목에는 상태(완료/진행중/예정)를 명확히 표시하세요.

### 고급 워크플로우

- 테스팅: 주요 기능에 대한 포괄적인 테스트를 포함하고, 엣지 케이스 테스트를 제안하세요.
- 적응성: 피드백에 따라 체크포인트 빈도를 조정하세요(더 많거나 적은 세분화).
- 분산 처리: libcluster와 GenServer를 활용한 분산 처리 패턴을 적용하세요.
- 상태 추적: 메시지의 전체 라이프사이클(발송→도달→오픈)을 추적하는 로직을 구현하세요.
- 변경 추적: ash_paper_trail을 사용하여 상태 변경을 기록하세요.
- 상태 관리: ash_state_machine을 사용하여 메시지 라이프사이클을 관리하세요.
- 어댑터 패턴: 각 채널별 구현을 위한 어댑터 패턴을 적용하세요.
- 템플릿 시스템: 다양한 채널에 최적화된 메시지 템플릿 시스템을 구현하세요.
- 캠페인 관리: 대량 메시지 캠페인 생성 및 타겟팅 시스템을 구현하세요.

## 3️⃣ 커뮤니케이션 선호도 - "이렇게 소통하세요"

### 기본 소통

- 요약: 각 컴포넌트 완료 후에 완료된 작업을 요약하세요.
- 변경 규모: 변경을 작은(Small), 중간(Medium), 큰(Large) 규모로 분류하세요.
- 명확화: 요청이 불명확하면 진행 전에 질문하세요.

### 정밀 소통

- 계획: 큰 변경의 경우 구현 계획을 제공하고 승인을 기다리세요.
- 추적: 항상 완료된 작업과 대기 중인 작업을 명시하세요.
- 감정적 신호: 긴급성이 표시되면(예: "이것은 중요합니다—집중해주세요!") 주의와 정확성을 우선시하세요.

## 4️⃣ 프로젝트 구조

### Umbrella 앱 구조

- **automata/** - Elixir Umbrella 프로젝트 루트
  - **docs/** - 프로젝트 문서
    - **automata-signal/**
      - **README.md** - 프로젝트 개요
      - **1-guides/** - 개발자 가이드
      - **2-designs/** - 시스템 설계
      - **3-components/** - 컴포넌트
      - **4-sequences/** - 시퀀스
      - **5-references/** - 참조 자료
      - **6-planning/** - 프로젝트 계획
      - **7-progress/** - 프로젝트 진행
  - **apps/** - Umbrella 하위 애플리케이션
    - **automata_signal/** - 통합 메시징 서비스 앱
      - **lib/** - 소스 코드
        - **automata_signal/** - 비즈니스 로직
          - **resources/** - Ash 리소스 정의
          - **services/** - 서비스 로직 모듈
          - **workers/** - ash_oban 비동기 작업자
          - **adapters/** - 채널별 어댑터 모듈
          - **templates/** - 메시지 템플릿 시스템
          - **campaigns/** - 캠페인 관리 모듈
        - **automata_signal_web/** - 웹 인터페이스
          - **controllers/** - API 엔드포인트 처리
          - **views/** - 응답 데이터 포맷팅
      - **priv/** - 정적 파일 및 마이그레이션
      - **test/** - 단위 및 통합 테스트
      - **client/** - Flutter 모바일 클라이언트
    - **automata_admin/** - 관리자 인터페이스 앱
    - **automata_analytics/** - 데이터 분석 앱
  - **config/** - Umbrella 공통 설정

### 명명 규칙

- 파일명: 스네이크 케이스(snake_case) 사용 (예: message_service.ex)
- 모듈명: 파스칼 케이스(PascalCase) 사용 (예: MessageService)
- 함수와 변수명: 스네이크 케이스(snake_case) 사용 (예: send_message())
- 상수: 대문자 스네이크 케이스(UPPER_SNAKE_CASE) 사용 (예: MAX_QUEUE_SIZE)

## 5️⃣ 성능 고려사항

- 배치 처리: 대량 메시지 전송 시 적절한 배치 크기로 처리하세요(100~500개 권장).
- 컨넥션 풀링: PostgreSQL 연결을 효율적으로 관리하세요(30-50개 연결 제한).
- 비동기 처리: 모든 메시지 전송은 비동기적으로 처리하세요.
- 분산 노드: 글로벌 리전(도쿄, 프랑크푸르트, 시드니 등)에 분산 배포하세요.
- 초당 10만 건: 초당 10만 건의 처리량을 목표로 최적화하세요(10초당 100만 건의 버스트 처리 지원).
- 채널별 최적화: 각 채널의 특성에 맞게 전송 로직을 최적화하세요.
- 템플릿 캐싱: 자주 사용되는 템플릿을 캐싱하여 렌더링 성능을 향상시키세요.
- 할당량 관리: ash_money와 ash_double_entry를 활용하여 정확한 앱별 메시지 할당량 및 과금을 관리하세요.
- 과금 트랜잭션: 할당량 소비와 비용 계산 작업은 원자적 트랜잭션으로 처리하세요.

## 6️⃣ 모니터링 및 관찰성

- 구조화된 로깅: 모든 로그를 JSON 형식으로 출력하세요.
- 지표 수집: 채널별 성공률, 도달률, 오픈률 등 핵심 비즈니스 지표를 수집하세요.
- 오류 추적: 모든 오류를 채널별로 분류하고 구조화된 방식으로 기록하세요.
- 성능 측정: 각 단계별(전송, 도달, 열람) 및 채널별 지연 시간을 측정하세요.
- 데이터 내보내기: ash_csv를 활용하여 통계 데이터를 내보내세요.
- 멀티채널 분석: 통합된 분석 대시보드를 위한 채널별 데이터를 수집하세요.
- 사용자 참여 추적: 채널별 사용자 참여도 및 효과성을 측정하세요.

## 7️⃣ Ash Framework 활용 방안

- ash_state_machine: 메시지 상태 전이(pending→successful→received→converted)를 명확하게 정의하고, 상태 변경 시 조건 및 콜백 함수를 설정하세요.
- ash_oban: 모든 비동기 작업을 Oban 워커로 구현하고, 재시도 전략, 우선순위 및 스케줄링을 설정하세요.
- ash_paper_trail: 메시지 및 구독 상태 변경에 대한 감사 추적을 유지하세요.
- ash_archival: 사용자 및 구독 데이터를 삭제하지 말고 논리적 보관 처리하세요.
- ash_cloak: 민감한 개인 정보(이메일, 전화번호) 및 인증 토큰을 암호화하세요.
- ash_money: 사용량 기반 과금을 위한 비용 추적 시스템을 구현하세요.
- ash_double_entry: 메시지 할당량 및 사용량을 이중 원장으로 정확하게 추적하세요.
- ash_csv: 채널별 성과 분석 및 보고서 생성을 위한 CSV 내보내기 기능을 구현하세요.

## 8️⃣ 활용 방법

이 규칙 세트는 AI 지원 개발을 위한 템플릿입니다. 다음과 같이 사용하세요:

1. 프로젝트 시작 시 이 규칙을 참조하세요.
2. 필요에 따라 규칙을 조정하세요.
3. AI 모델에게 이 파일의 내용을 따르도록 지시하세요.
4. 프로젝트를 진행하면서 이 규칙이 어떻게 도움이 되는지 평가하세요.

이 규칙 세트를 통해 AI와의 협업이 더 효율적이고 예측 가능해질 것입니다.